<?php

declare (strict_types=1);
namespace ApiClients\Client\GitHubEnterprise;

use ApiClients\Client\GitHubEnterprise\Hydrator;
use ApiClients\Client\GitHubEnterprise\Operation;
use ApiClients\Client\GitHubEnterprise\Schema;
use ApiClients\Client\GitHubEnterprise\WebHook;
final class Client implements ClientInterface
{
    private readonly \ApiClients\Contracts\HTTP\Headers\AuthenticationInterface $authentication;
    private readonly \React\Http\Browser $browser;
    private readonly \League\OpenAPIValidation\Schema\SchemaValidator $requestSchemaValidator;
    private readonly \League\OpenAPIValidation\Schema\SchemaValidator $responseSchemaValidator;
    /**
     * @var array<class-string, \EventSauce\ObjectHydrator\ObjectMapper>
     */
    private array $hydrator = array();
    private readonly WebHooks $webHooks;
    private readonly Hydrators $hydrators;
    public function __construct(\ApiClients\Contracts\HTTP\Headers\AuthenticationInterface $authentication, \React\Http\Browser $browser)
    {
        $this->authentication = $authentication;
        $this->browser = $browser->withBase('{protocol}://{hostname}/api/v3');
        $this->requestSchemaValidator = new \League\OpenAPIValidation\Schema\SchemaValidator(\League\OpenAPIValidation\Schema\SchemaValidator::VALIDATE_AS_REQUEST);
        $this->responseSchemaValidator = new \League\OpenAPIValidation\Schema\SchemaValidator(\League\OpenAPIValidation\Schema\SchemaValidator::VALIDATE_AS_RESPONSE);
        $this->hydrators = new Hydrators();
        $this->webHooks = new WebHooks($this->requestSchemaValidator, $this->hydrators);
    }
    /**
     * @return ($call is Operation\Meta\Root::OPERATION_MATCH ? Schema\Root : ($call is Operation\EnterpriseAdmin\ListGlobalWebhooks::OPERATION_MATCH ? Schema\GlobalHook : ($call is Operation\EnterpriseAdmin\CreateGlobalWebhook::OPERATION_MATCH ? Schema\GlobalHook : ($call is Operation\EnterpriseAdmin\GetGlobalWebhook::OPERATION_MATCH ? Schema\GlobalHook : ($call is Operation\EnterpriseAdmin\DeleteGlobalWebhook::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\EnterpriseAdmin\UpdateGlobalWebhook::OPERATION_MATCH ? Schema\GlobalHook2 : ($call is Operation\EnterpriseAdmin\PingGlobalWebhook::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\EnterpriseAdmin\ListPublicKeys::OPERATION_MATCH ? Schema\PublicKeyFull : ($call is Operation\EnterpriseAdmin\DeletePublicKey::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\EnterpriseAdmin\UpdateLdapMappingForTeam::OPERATION_MATCH ? Schema\LdapMappingTeam : ($call is Operation\EnterpriseAdmin\SyncLdapMappingForTeam::OPERATION_MATCH ? Schema\Operation\EnterpriseAdmin\SyncLdapMappingForTeam\Response\Applicationjson\H201 : ($call is Operation\EnterpriseAdmin\UpdateLdapMappingForUser::OPERATION_MATCH ? Schema\LdapMappingUser : ($call is Operation\EnterpriseAdmin\SyncLdapMappingForUser::OPERATION_MATCH ? Schema\Operation\EnterpriseAdmin\SyncLdapMappingForTeam\Response\Applicationjson\H201 : ($call is Operation\EnterpriseAdmin\CreateOrg::OPERATION_MATCH ? Schema\OrganizationSimple : ($call is Operation\EnterpriseAdmin\UpdateOrgName::OPERATION_MATCH ? Schema\Operation\EnterpriseAdmin\UpdateOrgName\Response\Applicationjson\H202 : ($call is Operation\EnterpriseAdmin\ListPreReceiveEnvironments::OPERATION_MATCH ? Schema\PreReceiveEnvironment : ($call is Operation\EnterpriseAdmin\CreatePreReceiveEnvironment::OPERATION_MATCH ? Schema\PreReceiveEnvironment : ($call is Operation\EnterpriseAdmin\GetPreReceiveEnvironment::OPERATION_MATCH ? Schema\PreReceiveEnvironment : ($call is Operation\EnterpriseAdmin\DeletePreReceiveEnvironment::OPERATION_MATCH ? Schema\Operation\EnterpriseAdmin\DeletePreReceiveEnvironment\Response\Applicationjson\H422 : ($call is Operation\EnterpriseAdmin\UpdatePreReceiveEnvironment::OPERATION_MATCH ? Schema\PreReceiveEnvironment|Schema\Operation\EnterpriseAdmin\DeletePreReceiveEnvironment\Response\Applicationjson\H422 : ($call is Operation\EnterpriseAdmin\StartPreReceiveEnvironmentDownload::OPERATION_MATCH ? Schema\PreReceiveEnvironmentDownloadStatus|Schema\Operation\EnterpriseAdmin\DeletePreReceiveEnvironment\Response\Applicationjson\H422 : ($call is Operation\EnterpriseAdmin\GetDownloadStatusForPreReceiveEnvironment::OPERATION_MATCH ? Schema\PreReceiveEnvironmentDownloadStatus : ($call is Operation\EnterpriseAdmin\ListPreReceiveHooks::OPERATION_MATCH ? Schema\PreReceiveHook : ($call is Operation\EnterpriseAdmin\CreatePreReceiveHook::OPERATION_MATCH ? Schema\PreReceiveHook : ($call is Operation\EnterpriseAdmin\GetPreReceiveHook::OPERATION_MATCH ? Schema\PreReceiveHook : ($call is Operation\EnterpriseAdmin\DeletePreReceiveHook::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\EnterpriseAdmin\UpdatePreReceiveHook::OPERATION_MATCH ? Schema\PreReceiveHook : ($call is Operation\EnterpriseAdmin\ListPersonalAccessTokens::OPERATION_MATCH ? Schema\Authorization : ($call is Operation\EnterpriseAdmin\DeletePersonalAccessToken::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\EnterpriseAdmin\CreateUser::OPERATION_MATCH ? Schema\SimpleUser : ($call is Operation\EnterpriseAdmin\DeleteUser::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\EnterpriseAdmin\UpdateUsernameForUser::OPERATION_MATCH ? Schema\Operation\EnterpriseAdmin\UpdateOrgName\Response\Applicationjson\H202 : ($call is Operation\EnterpriseAdmin\CreateImpersonationOAuthToken::OPERATION_MATCH ? Schema\Authorization : ($call is Operation\EnterpriseAdmin\DeleteImpersonationOAuthToken::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Apps\GetAuthenticated::OPERATION_MATCH ? Schema\Integration : ($call is Operation\Apps\CreateFromManifest::OPERATION_MATCH ? Schema\Operation\Apps\CreateFromManifest\Response\Applicationjson\H201|Schema\BasicError|Schema\ValidationErrorSimple : ($call is Operation\Apps\GetWebhookConfigForApp::OPERATION_MATCH ? Schema\WebhookConfig : ($call is Operation\Apps\UpdateWebhookConfigForApp::OPERATION_MATCH ? Schema\WebhookConfig : ($call is Operation\Apps\ListWebhookDeliveries::OPERATION_MATCH ? Schema\HookDeliveryItem|Schema\BasicError|Schema\ScimError|Schema\ValidationError : ($call is Operation\Apps\GetWebhookDelivery::OPERATION_MATCH ? Schema\HookDelivery|Schema\BasicError|Schema\ScimError|Schema\ValidationError : ($call is Operation\Apps\RedeliverWebhookDelivery::OPERATION_MATCH ? Schema\AuditLogEvent\Config|Schema\BasicError|Schema\ScimError|Schema\ValidationError : ($call is Operation\Apps\ListInstallationRequestsForAuthenticatedApp::OPERATION_MATCH ? Schema\IntegrationInstallationRequest|Schema\BasicError : ($call is Operation\Apps\ListInstallations::OPERATION_MATCH ? Schema\Installation : ($call is Operation\Apps\GetInstallation::OPERATION_MATCH ? Schema\Installation|Schema\BasicError : ($call is Operation\Apps\DeleteInstallation::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Apps\CreateInstallationAccessToken::OPERATION_MATCH ? Schema\InstallationToken|Schema\BasicError|Schema\ValidationError : ($call is Operation\Apps\SuspendInstallation::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Apps\UnsuspendInstallation::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\OauthAuthorizations\ListGrants::OPERATION_MATCH ? Schema\ApplicationGrant|Schema\BasicError : ($call is Operation\OauthAuthorizations\GetGrant::OPERATION_MATCH ? Schema\ApplicationGrant|Schema\BasicError : ($call is Operation\OauthAuthorizations\DeleteGrant::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Apps\DeleteAuthorization::OPERATION_MATCH ? Schema\ValidationError : ($call is Operation\Apps\CheckToken::OPERATION_MATCH ? Schema\Authorization|Schema\ValidationError|Schema\BasicError : ($call is Operation\Apps\DeleteToken::OPERATION_MATCH ? Schema\ValidationError : ($call is Operation\Apps\ResetToken::OPERATION_MATCH ? Schema\Authorization|Schema\ValidationError : ($call is Operation\Apps\ScopeToken::OPERATION_MATCH ? Schema\Authorization|Schema\BasicError|Schema\ValidationError : ($call is Operation\Apps\GetBySlug::OPERATION_MATCH ? Schema\Integration|Schema\BasicError : ($call is Operation\OauthAuthorizations\ListAuthorizations::OPERATION_MATCH ? Schema\Authorization|Schema\BasicError : ($call is Operation\OauthAuthorizations\CreateAuthorization::OPERATION_MATCH ? Schema\Authorization|Schema\ValidationError|Schema\BasicError : ($call is Operation\OauthAuthorizations\GetOrCreateAuthorizationForApp::OPERATION_MATCH ? Schema\Authorization|Schema\ValidationError|Schema\BasicError : ($call is Operation\OauthAuthorizations\GetOrCreateAuthorizationForAppAndFingerprint::OPERATION_MATCH ? Schema\Authorization|Schema\ValidationError : ($call is Operation\OauthAuthorizations\GetAuthorization::OPERATION_MATCH ? Schema\Authorization|Schema\BasicError : ($call is Operation\OauthAuthorizations\DeleteAuthorization::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\OauthAuthorizations\UpdateAuthorization::OPERATION_MATCH ? Schema\Authorization|Schema\ValidationError : ($call is Operation\CodesOfConduct\GetAllCodesOfConduct::OPERATION_MATCH ? Schema\CodeOfConduct : ($call is Operation\CodesOfConduct\GetConductCode::OPERATION_MATCH ? Schema\CodeOfConduct|Schema\BasicError : ($call is Operation\Emojis\Get::OPERATION_MATCH ? Schema\Operation\Emojis\Get\Response\Applicationjson\H200 : ($call is Operation\EnterpriseAdmin\GetAnnouncement::OPERATION_MATCH ? Schema\Announcement : ($call is Operation\EnterpriseAdmin\RemoveAnnouncement::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\EnterpriseAdmin\SetAnnouncement::OPERATION_MATCH ? Schema\Announcement : ($call is Operation\EnterpriseAdmin\GetLicenseInformation::OPERATION_MATCH ? Schema\LicenseInfo : ($call is Operation\EnterpriseAdmin\GetAllStats::OPERATION_MATCH ? Schema\EnterpriseOverview : ($call is Operation\EnterpriseAdmin\GetCommentStats::OPERATION_MATCH ? Schema\EnterpriseCommentOverview : ($call is Operation\EnterpriseAdmin\GetGistStats::OPERATION_MATCH ? Schema\EnterpriseGistOverview : ($call is Operation\EnterpriseAdmin\GetHooksStats::OPERATION_MATCH ? Schema\EnterpriseHookOverview : ($call is Operation\EnterpriseAdmin\GetIssueStats::OPERATION_MATCH ? Schema\EnterpriseIssueOverview : ($call is Operation\EnterpriseAdmin\GetMilestoneStats::OPERATION_MATCH ? Schema\EnterpriseMilestoneOverview : ($call is Operation\EnterpriseAdmin\GetOrgStats::OPERATION_MATCH ? Schema\EnterpriseOrganizationOverview : ($call is Operation\EnterpriseAdmin\GetPagesStats::OPERATION_MATCH ? Schema\EnterprisePageOverview : ($call is Operation\EnterpriseAdmin\GetPullRequestStats::OPERATION_MATCH ? Schema\EnterprisePullRequestOverview : ($call is Operation\EnterpriseAdmin\GetRepoStats::OPERATION_MATCH ? Schema\EnterpriseRepositoryOverview : ($call is Operation\EnterpriseAdmin\GetUserStats::OPERATION_MATCH ? Schema\EnterpriseUserOverview : ($call is Operation\Actions\GetActionsCacheUsageForEnterprise::OPERATION_MATCH ? Schema\ActionsCacheUsageOrgEnterprise : ($call is Operation\Actions\GetActionsCacheUsagePolicyForEnterprise::OPERATION_MATCH ? Schema\ActionsCacheUsagePolicyEnterprise : ($call is Operation\Actions\SetActionsCacheUsagePolicyForEnterprise::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\EnterpriseAdmin\GetGithubActionsPermissionsEnterprise::OPERATION_MATCH ? Schema\ActionsEnterprisePermissions : ($call is Operation\EnterpriseAdmin\SetGithubActionsPermissionsEnterprise::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\EnterpriseAdmin\ListSelectedOrganizationsEnabledGithubActionsEnterprise::OPERATION_MATCH ? Schema\Operation\EnterpriseAdmin\ListSelectedOrganizationsEnabledGithubActionsEnterprise\Response\Applicationjson\H200 : ($call is Operation\EnterpriseAdmin\SetSelectedOrganizationsEnabledGithubActionsEnterprise::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\EnterpriseAdmin\EnableSelectedOrganizationGithubActionsEnterprise::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\EnterpriseAdmin\DisableSelectedOrganizationGithubActionsEnterprise::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\EnterpriseAdmin\GetAllowedActionsEnterprise::OPERATION_MATCH ? Schema\SelectedActions : ($call is Operation\EnterpriseAdmin\SetAllowedActionsEnterprise::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\GetGithubActionsDefaultWorkflowPermissionsEnterprise::OPERATION_MATCH ? Schema\ActionsGetDefaultWorkflowPermissions : ($call is Operation\Actions\SetGithubActionsDefaultWorkflowPermissionsEnterprise::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\EnterpriseAdmin\ListSelfHostedRunnerGroupsForEnterprise::OPERATION_MATCH ? Schema\Operation\EnterpriseAdmin\ListSelfHostedRunnerGroupsForEnterprise\Response\Applicationjson\H200 : ($call is Operation\EnterpriseAdmin\CreateSelfHostedRunnerGroupForEnterprise::OPERATION_MATCH ? Schema\RunnerGroupsEnterprise : ($call is Operation\EnterpriseAdmin\GetSelfHostedRunnerGroupForEnterprise::OPERATION_MATCH ? Schema\RunnerGroupsEnterprise : ($call is Operation\EnterpriseAdmin\DeleteSelfHostedRunnerGroupFromEnterprise::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\EnterpriseAdmin\UpdateSelfHostedRunnerGroupForEnterprise::OPERATION_MATCH ? Schema\RunnerGroupsEnterprise : ($call is Operation\EnterpriseAdmin\ListOrgAccessToSelfHostedRunnerGroupInEnterprise::OPERATION_MATCH ? Schema\Operation\EnterpriseAdmin\ListSelectedOrganizationsEnabledGithubActionsEnterprise\Response\Applicationjson\H200 : ($call is Operation\EnterpriseAdmin\SetOrgAccessToSelfHostedRunnerGroupInEnterprise::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\EnterpriseAdmin\AddOrgAccessToSelfHostedRunnerGroupInEnterprise::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\EnterpriseAdmin\RemoveOrgAccessToSelfHostedRunnerGroupInEnterprise::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\EnterpriseAdmin\ListSelfHostedRunnersInGroupForEnterprise::OPERATION_MATCH ? Schema\Operation\EnterpriseAdmin\ListSelfHostedRunnersInGroupForEnterprise\Response\Applicationjson\H200 : ($call is Operation\EnterpriseAdmin\SetSelfHostedRunnersInGroupForEnterprise::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\EnterpriseAdmin\AddSelfHostedRunnerToGroupForEnterprise::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\EnterpriseAdmin\RemoveSelfHostedRunnerFromGroupForEnterprise::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\EnterpriseAdmin\ListSelfHostedRunnersForEnterprise::OPERATION_MATCH ? Schema\Operation\EnterpriseAdmin\ListSelfHostedRunnersForEnterprise\Response\Applicationjson\H200 : ($call is Operation\EnterpriseAdmin\ListRunnerApplicationsForEnterprise::OPERATION_MATCH ? Schema\RunnerApplication : ($call is Operation\EnterpriseAdmin\CreateRegistrationTokenForEnterprise::OPERATION_MATCH ? Schema\AuthenticationToken : ($call is Operation\EnterpriseAdmin\CreateRemoveTokenForEnterprise::OPERATION_MATCH ? Schema\AuthenticationToken : ($call is Operation\EnterpriseAdmin\GetSelfHostedRunnerForEnterprise::OPERATION_MATCH ? Schema\Runner : ($call is Operation\EnterpriseAdmin\DeleteSelfHostedRunnerFromEnterprise::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise::OPERATION_MATCH ? Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError : ($call is Operation\EnterpriseAdmin\SetCustomLabelsForSelfHostedRunnerForEnterprise::OPERATION_MATCH ? Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationErrorSimple : ($call is Operation\EnterpriseAdmin\AddCustomLabelsToSelfHostedRunnerForEnterprise::OPERATION_MATCH ? Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationErrorSimple : ($call is Operation\EnterpriseAdmin\RemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise::OPERATION_MATCH ? Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationErrorSimple : ($call is Operation\EnterpriseAdmin\RemoveCustomLabelFromSelfHostedRunnerForEnterprise::OPERATION_MATCH ? Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationErrorSimple : ($call is Operation\EnterpriseAdmin\GetAuditLog::OPERATION_MATCH ? Schema\AuditLogEvent : ($call is Operation\SecretScanning\ListAlertsForEnterprise::OPERATION_MATCH ? Schema\OrganizationSecretScanningAlert|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 : ($call is Operation\Billing\GetGithubAdvancedSecurityBillingGhe::OPERATION_MATCH ? Schema\AdvancedSecurityActiveCommitters|Schema\BasicError : ($call is Operation\Activity\ListPublicEvents::OPERATION_MATCH ? Schema\Event|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 : ($call is Operation\Activity\GetFeeds::OPERATION_MATCH ? Schema\Feed : ($call is Operation\Gists\List_::OPERATION_MATCH ? Schema\BaseGist|Schema\BasicError : ($call is Operation\Gists\Create::OPERATION_MATCH ? Schema\GistSimple|Schema\ValidationError|Schema\BasicError : ($call is Operation\Gists\ListPublic::OPERATION_MATCH ? Schema\BaseGist|Schema\ValidationError|Schema\BasicError : ($call is Operation\Gists\ListStarred::OPERATION_MATCH ? Schema\BaseGist|Schema\BasicError : ($call is Operation\Gists\Get::OPERATION_MATCH ? Schema\GistSimple|Schema\Operation\Gists\Get\Response\Applicationjson\H403|Schema\BasicError : ($call is Operation\Gists\Delete::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Gists\Update::OPERATION_MATCH ? Schema\GistSimple|Schema\ValidationError|Schema\BasicError : ($call is Operation\Gists\ListComments::OPERATION_MATCH ? Schema\GistComment|Schema\BasicError : ($call is Operation\Gists\CreateComment::OPERATION_MATCH ? Schema\GistComment|Schema\BasicError : ($call is Operation\Gists\GetComment::OPERATION_MATCH ? Schema\GistComment|Schema\BasicError|Schema\Operation\Gists\Get\Response\Applicationjson\H403 : ($call is Operation\Gists\DeleteComment::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Gists\UpdateComment::OPERATION_MATCH ? Schema\GistComment|Schema\BasicError : ($call is Operation\Gists\ListCommits::OPERATION_MATCH ? Schema\GistCommit|Schema\BasicError : ($call is Operation\Gists\ListForks::OPERATION_MATCH ? Schema\GistSimple|Schema\BasicError : ($call is Operation\Gists\Fork::OPERATION_MATCH ? Schema\BaseGist|Schema\BasicError|Schema\ValidationError : ($call is Operation\Gists\CheckIsStarred::OPERATION_MATCH ? Schema\Operation\Gists\CheckIsStarred\Response\Applicationjson\H404|Schema\BasicError : ($call is Operation\Gists\Star::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Gists\Unstar::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Gists\GetRevision::OPERATION_MATCH ? Schema\GistSimple|Schema\ValidationError|Schema\BasicError : ($call is Operation\Gitignore\GetAllTemplates::OPERATION_MATCH ? Schema\Operation\Gitignore\GetAllTemplates\Response\Applicationjson\H200 : ($call is Operation\Gitignore\GetTemplate::OPERATION_MATCH ? Schema\GitignoreTemplate : ($call is Operation\Apps\ListReposAccessibleToInstallation::OPERATION_MATCH ? Schema\Operation\Apps\ListReposAccessibleToInstallation\Response\Applicationjson\H200|Schema\BasicError : ($call is Operation\Apps\RevokeInstallationAccessToken::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Issues\List_::OPERATION_MATCH ? Schema\Issue|Schema\ValidationError|Schema\BasicError : ($call is Operation\Licenses\GetAllCommonlyUsed::OPERATION_MATCH ? Schema\LicenseSimple : ($call is Operation\Licenses\Get::OPERATION_MATCH ? Schema\License|Schema\BasicError : ($call is Operation\Markdown\Render::OPERATION_MATCH ? Schema\Operation\Gitignore\GetAllTemplates\Response\Applicationjson\H200 : ($call is Operation\Markdown\RenderRaw::OPERATION_MATCH ? Schema\Operation\Gitignore\GetAllTemplates\Response\Applicationjson\H200 : ($call is Operation\Meta\Get::OPERATION_MATCH ? Schema\ApiOverview : ($call is Operation\Activity\ListPublicEventsForRepoNetwork::OPERATION_MATCH ? Schema\Event|Schema\BasicError : ($call is Operation\Activity\ListNotificationsForAuthenticatedUser::OPERATION_MATCH ? Schema\Thread|Schema\BasicError|Schema\ValidationError : ($call is Operation\Activity\MarkNotificationsAsRead::OPERATION_MATCH ? Schema\Operation\Activity\MarkNotificationsAsRead\Response\Applicationjson\H202|Schema\BasicError : ($call is Operation\Activity\GetThread::OPERATION_MATCH ? Schema\Thread|Schema\BasicError : ($call is Operation\Activity\MarkThreadAsRead::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Activity\GetThreadSubscriptionForAuthenticatedUser::OPERATION_MATCH ? Schema\ThreadSubscription|Schema\BasicError : ($call is Operation\Activity\SetThreadSubscription::OPERATION_MATCH ? Schema\ThreadSubscription|Schema\BasicError : ($call is Operation\Activity\DeleteThreadSubscription::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Meta\GetOctocat::OPERATION_MATCH ? Schema\Operation\Gitignore\GetAllTemplates\Response\Applicationjson\H200 : ($call is Operation\Orgs\List_::OPERATION_MATCH ? Schema\OrganizationSimple : ($call is Operation\Orgs\ListCustomRoles::OPERATION_MATCH ? Schema\Operation\Orgs\ListCustomRoles\Response\Applicationjson\H200 : ($call is Operation\Orgs\Get::OPERATION_MATCH ? Schema\OrganizationFull|Schema\BasicError : ($call is Operation\Orgs\Update::OPERATION_MATCH ? Schema\OrganizationFull|Schema\Operation\Orgs\Update\Response\Applicationjson\H422|Schema\BasicError : ($call is Operation\Actions\GetActionsCacheUsageForOrg::OPERATION_MATCH ? Schema\ActionsCacheUsageOrgEnterprise : ($call is Operation\Actions\GetActionsCacheUsageByRepoForOrg::OPERATION_MATCH ? Schema\Operation\Actions\GetActionsCacheUsageByRepoForOrg\Response\Applicationjson\H200 : ($call is Operation\Actions\GetGithubActionsPermissionsOrganization::OPERATION_MATCH ? Schema\ActionsOrganizationPermissions : ($call is Operation\Actions\SetGithubActionsPermissionsOrganization::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\ListSelectedRepositoriesEnabledGithubActionsOrganization::OPERATION_MATCH ? Schema\Operation\Actions\ListSelectedRepositoriesEnabledGithubActionsOrganization\Response\Applicationjson\H200 : ($call is Operation\Actions\SetSelectedRepositoriesEnabledGithubActionsOrganization::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\EnableSelectedRepositoryGithubActionsOrganization::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\DisableSelectedRepositoryGithubActionsOrganization::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\GetAllowedActionsOrganization::OPERATION_MATCH ? Schema\SelectedActions : ($call is Operation\Actions\SetAllowedActionsOrganization::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\GetGithubActionsDefaultWorkflowPermissionsOrganization::OPERATION_MATCH ? Schema\ActionsGetDefaultWorkflowPermissions : ($call is Operation\Actions\SetGithubActionsDefaultWorkflowPermissionsOrganization::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\ListSelfHostedRunnerGroupsForOrg::OPERATION_MATCH ? Schema\Operation\Actions\ListSelfHostedRunnerGroupsForOrg\Response\Applicationjson\H200 : ($call is Operation\Actions\CreateSelfHostedRunnerGroupForOrg::OPERATION_MATCH ? Schema\RunnerGroupsOrg : ($call is Operation\Actions\GetSelfHostedRunnerGroupForOrg::OPERATION_MATCH ? Schema\RunnerGroupsOrg : ($call is Operation\Actions\DeleteSelfHostedRunnerGroupFromOrg::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\UpdateSelfHostedRunnerGroupForOrg::OPERATION_MATCH ? Schema\RunnerGroupsOrg : ($call is Operation\Actions\ListRepoAccessToSelfHostedRunnerGroupInOrg::OPERATION_MATCH ? Schema\Operation\Actions\ListRepoAccessToSelfHostedRunnerGroupInOrg\Response\Applicationjson\H200 : ($call is Operation\Actions\SetRepoAccessToSelfHostedRunnerGroupInOrg::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\AddRepoAccessToSelfHostedRunnerGroupInOrg::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\RemoveRepoAccessToSelfHostedRunnerGroupInOrg::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\ListSelfHostedRunnersInGroupForOrg::OPERATION_MATCH ? Schema\Operation\EnterpriseAdmin\ListSelfHostedRunnersInGroupForEnterprise\Response\Applicationjson\H200 : ($call is Operation\Actions\SetSelfHostedRunnersInGroupForOrg::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\AddSelfHostedRunnerToGroupForOrg::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\RemoveSelfHostedRunnerFromGroupForOrg::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\ListSelfHostedRunnersForOrg::OPERATION_MATCH ? Schema\Operation\Actions\ListSelfHostedRunnersForOrg\Response\Applicationjson\H200 : ($call is Operation\Actions\ListRunnerApplicationsForOrg::OPERATION_MATCH ? Schema\RunnerApplication : ($call is Operation\Actions\CreateRegistrationTokenForOrg::OPERATION_MATCH ? Schema\AuthenticationToken : ($call is Operation\Actions\CreateRemoveTokenForOrg::OPERATION_MATCH ? Schema\AuthenticationToken : ($call is Operation\Actions\GetSelfHostedRunnerForOrg::OPERATION_MATCH ? Schema\Runner : ($call is Operation\Actions\DeleteSelfHostedRunnerFromOrg::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\ListLabelsForSelfHostedRunnerForOrg::OPERATION_MATCH ? Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError : ($call is Operation\Actions\SetCustomLabelsForSelfHostedRunnerForOrg::OPERATION_MATCH ? Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationErrorSimple : ($call is Operation\Actions\AddCustomLabelsToSelfHostedRunnerForOrg::OPERATION_MATCH ? Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationErrorSimple : ($call is Operation\Actions\RemoveAllCustomLabelsFromSelfHostedRunnerForOrg::OPERATION_MATCH ? Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError : ($call is Operation\Actions\RemoveCustomLabelFromSelfHostedRunnerForOrg::OPERATION_MATCH ? Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationErrorSimple : ($call is Operation\Actions\ListOrgSecrets::OPERATION_MATCH ? Schema\Operation\Actions\ListOrgSecrets\Response\Applicationjson\H200 : ($call is Operation\Actions\GetOrgPublicKey::OPERATION_MATCH ? Schema\ActionsPublicKey : ($call is Operation\Actions\GetOrgSecret::OPERATION_MATCH ? Schema\OrganizationActionsSecret : ($call is Operation\Actions\CreateOrUpdateOrgSecret::OPERATION_MATCH ? Schema\EmptyObject : ($call is Operation\Actions\DeleteOrgSecret::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\ListSelectedReposForOrgSecret::OPERATION_MATCH ? Schema\Operation\Actions\ListSelectedReposForOrgSecret\Response\Applicationjson\H200 : ($call is Operation\Actions\SetSelectedReposForOrgSecret::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\AddSelectedRepoToOrgSecret::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\RemoveSelectedRepoFromOrgSecret::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Orgs\GetAuditLog::OPERATION_MATCH ? Schema\AuditLogEvent : ($call is Operation\CodeScanning\ListAlertsForOrg::OPERATION_MATCH ? Schema\CodeScanningOrganizationAlertItems|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 : ($call is Operation\Dependabot\ListOrgSecrets::OPERATION_MATCH ? Schema\Operation\Dependabot\ListOrgSecrets\Response\Applicationjson\H200 : ($call is Operation\Dependabot\GetOrgPublicKey::OPERATION_MATCH ? Schema\DependabotPublicKey : ($call is Operation\Dependabot\GetOrgSecret::OPERATION_MATCH ? Schema\OrganizationDependabotSecret : ($call is Operation\Dependabot\CreateOrUpdateOrgSecret::OPERATION_MATCH ? Schema\EmptyObject : ($call is Operation\Dependabot\DeleteOrgSecret::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Dependabot\ListSelectedReposForOrgSecret::OPERATION_MATCH ? Schema\Operation\Actions\ListSelectedReposForOrgSecret\Response\Applicationjson\H200 : ($call is Operation\Dependabot\SetSelectedReposForOrgSecret::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Dependabot\AddSelectedRepoToOrgSecret::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Dependabot\RemoveSelectedRepoFromOrgSecret::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Activity\ListPublicOrgEvents::OPERATION_MATCH ? Schema\Event : ($call is Operation\Teams\ExternalIdpGroupInfoForOrg::OPERATION_MATCH ? Schema\ExternalGroup : ($call is Operation\Teams\ListExternalIdpGroupsForOrg::OPERATION_MATCH ? Schema\ExternalGroups : ($call is Operation\Orgs\ListWebhooks::OPERATION_MATCH ? Schema\OrgHook|Schema\BasicError : ($call is Operation\Orgs\CreateWebhook::OPERATION_MATCH ? Schema\OrgHook|Schema\ValidationError|Schema\BasicError : ($call is Operation\Orgs\GetWebhook::OPERATION_MATCH ? Schema\OrgHook|Schema\BasicError : ($call is Operation\Orgs\DeleteWebhook::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Orgs\UpdateWebhook::OPERATION_MATCH ? Schema\OrgHook|Schema\ValidationError|Schema\BasicError : ($call is Operation\Orgs\GetWebhookConfigForOrg::OPERATION_MATCH ? Schema\WebhookConfig : ($call is Operation\Orgs\UpdateWebhookConfigForOrg::OPERATION_MATCH ? Schema\WebhookConfig : ($call is Operation\Orgs\ListWebhookDeliveries::OPERATION_MATCH ? Schema\HookDeliveryItem|Schema\BasicError|Schema\ScimError|Schema\ValidationError : ($call is Operation\Orgs\GetWebhookDelivery::OPERATION_MATCH ? Schema\HookDelivery|Schema\BasicError|Schema\ScimError|Schema\ValidationError : ($call is Operation\Orgs\RedeliverWebhookDelivery::OPERATION_MATCH ? Schema\AuditLogEvent\Config|Schema\BasicError|Schema\ScimError|Schema\ValidationError : ($call is Operation\Orgs\PingWebhook::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Apps\GetOrgInstallation::OPERATION_MATCH ? Schema\Installation : ($call is Operation\Orgs\ListAppInstallations::OPERATION_MATCH ? Schema\Operation\Orgs\ListAppInstallations\Response\Applicationjson\H200 : ($call is Operation\Issues\ListForOrg::OPERATION_MATCH ? Schema\Issue|Schema\BasicError : ($call is Operation\Orgs\ListMembers::OPERATION_MATCH ? Schema\SimpleUser|Schema\ValidationError : ($call is Operation\Orgs\CheckMembershipForUser::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Orgs\RemoveMember::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Orgs\GetMembershipForUser::OPERATION_MATCH ? Schema\OrgMembership|Schema\BasicError : ($call is Operation\Orgs\SetMembershipForUser::OPERATION_MATCH ? Schema\OrgMembership|Schema\ValidationError|Schema\BasicError : ($call is Operation\Orgs\RemoveMembershipForUser::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Migrations\ListForOrg::OPERATION_MATCH ? Schema\Migration : ($call is Operation\Migrations\StartForOrg::OPERATION_MATCH ? Schema\Migration|Schema\BasicError|Schema\ValidationError : ($call is Operation\Migrations\GetStatusForOrg::OPERATION_MATCH ? Schema\Migration|Schema\BasicError : ($call is Operation\Migrations\DownloadArchiveForOrg::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Migrations\DeleteArchiveForOrg::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Migrations\UnlockRepoForOrg::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Migrations\ListReposForOrg::OPERATION_MATCH ? Schema\MinimalRepository|Schema\BasicError : ($call is Operation\Orgs\ListOutsideCollaborators::OPERATION_MATCH ? Schema\SimpleUser : ($call is Operation\Orgs\ConvertMemberToOutsideCollaborator::OPERATION_MATCH ? Schema\Operation\Gists\CheckIsStarred\Response\Applicationjson\H404|Schema\BasicError : ($call is Operation\Orgs\RemoveOutsideCollaborator::OPERATION_MATCH ? Schema\Operation\Orgs\RemoveOutsideCollaborator\Response\Applicationjson\H422 : ($call is Operation\EnterpriseAdmin\ListPreReceiveHooksForOrg::OPERATION_MATCH ? Schema\OrgPreReceiveHook : ($call is Operation\EnterpriseAdmin\GetPreReceiveHookForOrg::OPERATION_MATCH ? Schema\OrgPreReceiveHook : ($call is Operation\EnterpriseAdmin\RemovePreReceiveHookEnforcementForOrg::OPERATION_MATCH ? Schema\OrgPreReceiveHook : ($call is Operation\EnterpriseAdmin\UpdatePreReceiveHookEnforcementForOrg::OPERATION_MATCH ? Schema\OrgPreReceiveHook : ($call is Operation\Projects\ListForOrg::OPERATION_MATCH ? Schema\Project|Schema\ValidationErrorSimple : ($call is Operation\Projects\CreateForOrg::OPERATION_MATCH ? Schema\Project|Schema\BasicError|Schema\ValidationErrorSimple : ($call is Operation\Orgs\ListPublicMembers::OPERATION_MATCH ? Schema\SimpleUser : ($call is Operation\Orgs\CheckPublicMembershipForUser::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Orgs\SetPublicMembershipForAuthenticatedUser::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Orgs\RemovePublicMembershipForAuthenticatedUser::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Repos\ListForOrg::OPERATION_MATCH ? Schema\MinimalRepository : ($call is Operation\Repos\CreateInOrg::OPERATION_MATCH ? Schema\Repository|Schema\BasicError|Schema\ValidationError : ($call is Operation\SecretScanning\ListAlertsForOrg::OPERATION_MATCH ? Schema\OrganizationSecretScanningAlert|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 : ($call is Operation\Billing\GetGithubAdvancedSecurityBillingOrg::OPERATION_MATCH ? Schema\AdvancedSecurityActiveCommitters|Schema\BasicError : ($call is Operation\Teams\List_::OPERATION_MATCH ? Schema\Team|Schema\BasicError : ($call is Operation\Teams\Create::OPERATION_MATCH ? Schema\TeamFull|Schema\ValidationError|Schema\BasicError : ($call is Operation\Teams\GetByName::OPERATION_MATCH ? Schema\TeamFull|Schema\BasicError : ($call is Operation\Teams\DeleteInOrg::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Teams\UpdateInOrg::OPERATION_MATCH ? Schema\TeamFull|Schema\BasicError|Schema\ValidationError : ($call is Operation\Teams\ListDiscussionsInOrg::OPERATION_MATCH ? Schema\TeamDiscussion : ($call is Operation\Teams\CreateDiscussionInOrg::OPERATION_MATCH ? Schema\TeamDiscussion : ($call is Operation\Teams\GetDiscussionInOrg::OPERATION_MATCH ? Schema\TeamDiscussion : ($call is Operation\Teams\DeleteDiscussionInOrg::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Teams\UpdateDiscussionInOrg::OPERATION_MATCH ? Schema\TeamDiscussion : ($call is Operation\Teams\ListDiscussionCommentsInOrg::OPERATION_MATCH ? Schema\TeamDiscussionComment : ($call is Operation\Teams\CreateDiscussionCommentInOrg::OPERATION_MATCH ? Schema\TeamDiscussionComment : ($call is Operation\Teams\GetDiscussionCommentInOrg::OPERATION_MATCH ? Schema\TeamDiscussionComment : ($call is Operation\Teams\DeleteDiscussionCommentInOrg::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Teams\UpdateDiscussionCommentInOrg::OPERATION_MATCH ? Schema\TeamDiscussionComment : ($call is Operation\Reactions\ListForTeamDiscussionCommentInOrg::OPERATION_MATCH ? Schema\Reaction : ($call is Operation\Reactions\CreateForTeamDiscussionCommentInOrg::OPERATION_MATCH ? Schema\Reaction : ($call is Operation\Reactions\DeleteForTeamDiscussionComment::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Reactions\ListForTeamDiscussionInOrg::OPERATION_MATCH ? Schema\Reaction : ($call is Operation\Reactions\CreateForTeamDiscussionInOrg::OPERATION_MATCH ? Schema\Reaction : ($call is Operation\Reactions\DeleteForTeamDiscussion::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Teams\ListLinkedExternalIdpGroupsToTeamForOrg::OPERATION_MATCH ? Schema\ExternalGroups : ($call is Operation\Teams\UnlinkExternalIdpGroupFromTeamForOrg::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Teams\LinkExternalIdpGroupToTeamForOrg::OPERATION_MATCH ? Schema\ExternalGroup : ($call is Operation\Teams\ListMembersInOrg::OPERATION_MATCH ? Schema\SimpleUser : ($call is Operation\Teams\GetMembershipForUserInOrg::OPERATION_MATCH ? Schema\TeamMembership : ($call is Operation\Teams\AddOrUpdateMembershipForUserInOrg::OPERATION_MATCH ? Schema\TeamMembership : ($call is Operation\Teams\RemoveMembershipForUserInOrg::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Teams\ListProjectsInOrg::OPERATION_MATCH ? Schema\TeamProject : ($call is Operation\Teams\CheckPermissionsForProjectInOrg::OPERATION_MATCH ? Schema\TeamProject : ($call is Operation\Teams\AddOrUpdateProjectPermissionsInOrg::OPERATION_MATCH ? Schema\Operation\Orgs\RemoveOutsideCollaborator\Response\Applicationjson\H422 : ($call is Operation\Teams\RemoveProjectInOrg::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Teams\ListReposInOrg::OPERATION_MATCH ? Schema\MinimalRepository : ($call is Operation\Teams\CheckPermissionsForRepoInOrg::OPERATION_MATCH ? Schema\TeamRepository : ($call is Operation\Teams\AddOrUpdateRepoPermissionsInOrg::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Teams\RemoveRepoInOrg::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Teams\ListChildInOrg::OPERATION_MATCH ? Schema\Team : ($call is Operation\Projects\GetCard::OPERATION_MATCH ? Schema\ProjectCard|Schema\BasicError : ($call is Operation\Projects\DeleteCard::OPERATION_MATCH ? Schema\Operation\Projects\DeleteCard\Response\Applicationjson\H403|Schema\BasicError : ($call is Operation\Projects\UpdateCard::OPERATION_MATCH ? Schema\ProjectCard|Schema\BasicError|Schema\ValidationErrorSimple : ($call is Operation\Projects\MoveCard::OPERATION_MATCH ? Schema\Operation\Gists\CheckIsStarred\Response\Applicationjson\H404|Schema\Operation\Projects\MoveCard\Response\Applicationjson\H403|Schema\BasicError|Schema\Operation\Projects\MoveCard\Response\Applicationjson\H503|Schema\ValidationError : ($call is Operation\Projects\GetColumn::OPERATION_MATCH ? Schema\ProjectColumn|Schema\BasicError : ($call is Operation\Projects\DeleteColumn::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Projects\UpdateColumn::OPERATION_MATCH ? Schema\ProjectColumn|Schema\BasicError : ($call is Operation\Projects\ListCards::OPERATION_MATCH ? Schema\ProjectCard|Schema\BasicError : ($call is Operation\Projects\CreateCard::OPERATION_MATCH ? Schema\ProjectCard|Schema\BasicError|Schema\Operation\Orgs\Update\Response\Applicationjson\H422|Schema\Operation\Projects\MoveCard\Response\Applicationjson\H503 : ($call is Operation\Projects\MoveColumn::OPERATION_MATCH ? Schema\Operation\Gists\CheckIsStarred\Response\Applicationjson\H404|Schema\BasicError|Schema\ValidationErrorSimple : ($call is Operation\Projects\Get::OPERATION_MATCH ? Schema\Project|Schema\BasicError : ($call is Operation\Projects\Delete::OPERATION_MATCH ? Schema\Operation\Projects\DeleteCard\Response\Applicationjson\H403|Schema\BasicError : ($call is Operation\Projects\Update::OPERATION_MATCH ? Schema\Project|Schema\Operation\Projects\DeleteCard\Response\Applicationjson\H403|Schema\BasicError|Schema\ValidationErrorSimple : ($call is Operation\Projects\ListCollaborators::OPERATION_MATCH ? Schema\SimpleUser|Schema\BasicError|Schema\ValidationError : ($call is Operation\Projects\AddCollaborator::OPERATION_MATCH ? Schema\BasicError|Schema\ValidationError : ($call is Operation\Projects\RemoveCollaborator::OPERATION_MATCH ? Schema\BasicError|Schema\ValidationError : ($call is Operation\Projects\GetPermissionForUser::OPERATION_MATCH ? Schema\ProjectCollaboratorPermission|Schema\BasicError|Schema\ValidationError : ($call is Operation\Projects\ListColumns::OPERATION_MATCH ? Schema\ProjectColumn|Schema\BasicError : ($call is Operation\Projects\CreateColumn::OPERATION_MATCH ? Schema\ProjectColumn|Schema\BasicError|Schema\ValidationErrorSimple : ($call is Operation\RateLimit\Get::OPERATION_MATCH ? Schema\RateLimitOverview|Schema\BasicError : ($call is Operation\Repos\Get::OPERATION_MATCH ? Schema\FullRepository|Schema\BasicError : ($call is Operation\Repos\Delete::OPERATION_MATCH ? Schema\Operation\Orgs\RemoveOutsideCollaborator\Response\Applicationjson\H422|Schema\BasicError : ($call is Operation\Repos\Update::OPERATION_MATCH ? Schema\FullRepository|Schema\BasicError|Schema\ValidationError : ($call is Operation\Actions\ListArtifactsForRepo::OPERATION_MATCH ? Schema\Operation\Actions\ListArtifactsForRepo\Response\Applicationjson\H200 : ($call is Operation\Actions\GetArtifact::OPERATION_MATCH ? Schema\Artifact : ($call is Operation\Actions\DeleteArtifact::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\DownloadArtifact::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Actions\GetActionsCacheUsage::OPERATION_MATCH ? Schema\ActionsCacheUsageByRepository : ($call is Operation\Actions\GetActionsCacheUsagePolicy::OPERATION_MATCH ? Schema\ActionsCacheUsagePolicyForRepository : ($call is Operation\Actions\SetActionsCacheUsagePolicy::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\GetJobForWorkflowRun::OPERATION_MATCH ? Schema\Job : ($call is Operation\Actions\DownloadJobLogsForWorkflowRun::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\ReRunJobForWorkflowRun::OPERATION_MATCH ? Schema\EmptyObject|Schema\BasicError : ($call is Operation\Actions\GetGithubActionsPermissionsRepository::OPERATION_MATCH ? Schema\ActionsRepositoryPermissions : ($call is Operation\Actions\SetGithubActionsPermissionsRepository::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\GetWorkflowAccessToRepository::OPERATION_MATCH ? Schema\ActionsWorkflowAccessToRepository : ($call is Operation\Actions\SetWorkflowAccessToRepository::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\GetAllowedActionsRepository::OPERATION_MATCH ? Schema\SelectedActions : ($call is Operation\Actions\SetAllowedActionsRepository::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\GetGithubActionsDefaultWorkflowPermissionsRepository::OPERATION_MATCH ? Schema\ActionsGetDefaultWorkflowPermissions : ($call is Operation\Actions\SetGithubActionsDefaultWorkflowPermissionsRepository::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\ListSelfHostedRunnersForRepo::OPERATION_MATCH ? Schema\Operation\Actions\ListSelfHostedRunnersForOrg\Response\Applicationjson\H200 : ($call is Operation\Actions\ListRunnerApplicationsForRepo::OPERATION_MATCH ? Schema\RunnerApplication : ($call is Operation\Actions\CreateRegistrationTokenForRepo::OPERATION_MATCH ? Schema\AuthenticationToken : ($call is Operation\Actions\CreateRemoveTokenForRepo::OPERATION_MATCH ? Schema\AuthenticationToken : ($call is Operation\Actions\GetSelfHostedRunnerForRepo::OPERATION_MATCH ? Schema\Runner : ($call is Operation\Actions\DeleteSelfHostedRunnerFromRepo::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\ListLabelsForSelfHostedRunnerForRepo::OPERATION_MATCH ? Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError : ($call is Operation\Actions\SetCustomLabelsForSelfHostedRunnerForRepo::OPERATION_MATCH ? Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationErrorSimple : ($call is Operation\Actions\AddCustomLabelsToSelfHostedRunnerForRepo::OPERATION_MATCH ? Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationErrorSimple : ($call is Operation\Actions\RemoveAllCustomLabelsFromSelfHostedRunnerForRepo::OPERATION_MATCH ? Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError : ($call is Operation\Actions\RemoveCustomLabelFromSelfHostedRunnerForRepo::OPERATION_MATCH ? Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationErrorSimple : ($call is Operation\Actions\ListWorkflowRunsForRepo::OPERATION_MATCH ? Schema\Operation\Actions\ListWorkflowRunsForRepo\Response\Applicationjson\H200 : ($call is Operation\Actions\GetWorkflowRun::OPERATION_MATCH ? Schema\WorkflowRun : ($call is Operation\Actions\DeleteWorkflowRun::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\GetReviewsForRun::OPERATION_MATCH ? Schema\EnvironmentApprovals : ($call is Operation\Actions\ListWorkflowRunArtifacts::OPERATION_MATCH ? Schema\Operation\Actions\ListArtifactsForRepo\Response\Applicationjson\H200 : ($call is Operation\Actions\GetWorkflowRunAttempt::OPERATION_MATCH ? Schema\WorkflowRun : ($call is Operation\Actions\ListJobsForWorkflowRunAttempt::OPERATION_MATCH ? Schema\Operation\Actions\ListJobsForWorkflowRunAttempt\Response\Applicationjson\H200|Schema\BasicError : ($call is Operation\Actions\DownloadWorkflowRunAttemptLogs::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\CancelWorkflowRun::OPERATION_MATCH ? Schema\EmptyObject|Schema\BasicError : ($call is Operation\Actions\ListJobsForWorkflowRun::OPERATION_MATCH ? Schema\Operation\Actions\ListJobsForWorkflowRunAttempt\Response\Applicationjson\H200 : ($call is Operation\Actions\DownloadWorkflowRunLogs::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\DeleteWorkflowRunLogs::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Actions\GetPendingDeploymentsForRun::OPERATION_MATCH ? Schema\PendingDeployment : ($call is Operation\Actions\ReviewPendingDeploymentsForRun::OPERATION_MATCH ? Schema\Deployment : ($call is Operation\Actions\ReRunWorkflow::OPERATION_MATCH ? Schema\EmptyObject : ($call is Operation\Actions\ReRunWorkflowFailedJobs::OPERATION_MATCH ? Schema\EmptyObject : ($call is Operation\Actions\ListRepoSecrets::OPERATION_MATCH ? Schema\Operation\Actions\ListRepoSecrets\Response\Applicationjson\H200 : ($call is Operation\Actions\GetRepoPublicKey::OPERATION_MATCH ? Schema\ActionsPublicKey : ($call is Operation\Actions\GetRepoSecret::OPERATION_MATCH ? Schema\ActionsSecret : ($call is Operation\Actions\CreateOrUpdateRepoSecret::OPERATION_MATCH ? Schema\EmptyObject : ($call is Operation\Actions\DeleteRepoSecret::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\ListRepoWorkflows::OPERATION_MATCH ? Schema\Operation\Actions\ListRepoWorkflows\Response\Applicationjson\H200 : ($call is Operation\Actions\GetWorkflow::OPERATION_MATCH ? Schema\Workflow : ($call is Operation\Actions\DisableWorkflow::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\CreateWorkflowDispatch::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\EnableWorkflow::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Actions\ListWorkflowRuns::OPERATION_MATCH ? Schema\Operation\Actions\ListWorkflowRunsForRepo\Response\Applicationjson\H200 : ($call is Operation\Issues\ListAssignees::OPERATION_MATCH ? Schema\SimpleUser|Schema\BasicError : ($call is Operation\Issues\CheckUserCanBeAssigned::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Repos\ListAutolinks::OPERATION_MATCH ? Schema\Autolink : ($call is Operation\Repos\CreateAutolink::OPERATION_MATCH ? Schema\Autolink|Schema\ValidationError : ($call is Operation\Repos\GetAutolink::OPERATION_MATCH ? Schema\Autolink|Schema\BasicError : ($call is Operation\Repos\DeleteAutolink::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Repos\ListBranches::OPERATION_MATCH ? Schema\ShortBranch|Schema\BasicError : ($call is Operation\Repos\GetBranch::OPERATION_MATCH ? Schema\BranchWithProtection|Schema\BasicError : ($call is Operation\Repos\GetBranchProtection::OPERATION_MATCH ? Schema\BranchProtection|Schema\BasicError : ($call is Operation\Repos\UpdateBranchProtection::OPERATION_MATCH ? Schema\ProtectedBranch|Schema\BasicError|Schema\ValidationErrorSimple : ($call is Operation\Repos\DeleteBranchProtection::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Repos\GetAdminBranchProtection::OPERATION_MATCH ? Schema\ProtectedBranchAdminEnforced : ($call is Operation\Repos\SetAdminBranchProtection::OPERATION_MATCH ? Schema\ProtectedBranchAdminEnforced : ($call is Operation\Repos\DeleteAdminBranchProtection::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Repos\GetPullRequestReviewProtection::OPERATION_MATCH ? Schema\ProtectedBranchPullRequestReview : ($call is Operation\Repos\DeletePullRequestReviewProtection::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Repos\UpdatePullRequestReviewProtection::OPERATION_MATCH ? Schema\ProtectedBranchPullRequestReview|Schema\ValidationError : ($call is Operation\Repos\GetCommitSignatureProtection::OPERATION_MATCH ? Schema\ProtectedBranchAdminEnforced|Schema\BasicError : ($call is Operation\Repos\CreateCommitSignatureProtection::OPERATION_MATCH ? Schema\ProtectedBranchAdminEnforced|Schema\BasicError : ($call is Operation\Repos\DeleteCommitSignatureProtection::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Repos\GetStatusChecksProtection::OPERATION_MATCH ? Schema\StatusCheckPolicy|Schema\BasicError : ($call is Operation\Repos\RemoveStatusCheckProtection::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Repos\UpdateStatusCheckProtection::OPERATION_MATCH ? Schema\StatusCheckPolicy|Schema\BasicError|Schema\ValidationError : ($call is Operation\Repos\GetAllStatusCheckContexts::OPERATION_MATCH ? Schema\Operation\Gitignore\GetAllTemplates\Response\Applicationjson\H200|Schema\BasicError : ($call is Operation\Repos\SetStatusCheckContexts::OPERATION_MATCH ? Schema\Operation\Gitignore\GetAllTemplates\Response\Applicationjson\H200|Schema\ValidationError|Schema\BasicError : ($call is Operation\Repos\AddStatusCheckContexts::OPERATION_MATCH ? Schema\Operation\Gitignore\GetAllTemplates\Response\Applicationjson\H200|Schema\ValidationError|Schema\BasicError : ($call is Operation\Repos\RemoveStatusCheckContexts::OPERATION_MATCH ? Schema\Operation\Gitignore\GetAllTemplates\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationError : ($call is Operation\Repos\GetAccessRestrictions::OPERATION_MATCH ? Schema\BranchRestrictionPolicy|Schema\BasicError : ($call is Operation\Repos\DeleteAccessRestrictions::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Repos\GetAppsWithAccessToProtectedBranch::OPERATION_MATCH ? Schema\Integration|Schema\BasicError : ($call is Operation\Repos\SetAppAccessRestrictions::OPERATION_MATCH ? Schema\Integration|Schema\ValidationError : ($call is Operation\Repos\AddAppAccessRestrictions::OPERATION_MATCH ? Schema\Integration|Schema\ValidationError : ($call is Operation\Repos\RemoveAppAccessRestrictions::OPERATION_MATCH ? Schema\Integration|Schema\ValidationError : ($call is Operation\Repos\GetTeamsWithAccessToProtectedBranch::OPERATION_MATCH ? Schema\Team|Schema\BasicError : ($call is Operation\Repos\SetTeamAccessRestrictions::OPERATION_MATCH ? Schema\Team|Schema\ValidationError : ($call is Operation\Repos\AddTeamAccessRestrictions::OPERATION_MATCH ? Schema\Team|Schema\ValidationError : ($call is Operation\Repos\RemoveTeamAccessRestrictions::OPERATION_MATCH ? Schema\Team|Schema\ValidationError : ($call is Operation\Repos\GetUsersWithAccessToProtectedBranch::OPERATION_MATCH ? Schema\SimpleUser|Schema\BasicError : ($call is Operation\Repos\SetUserAccessRestrictions::OPERATION_MATCH ? Schema\SimpleUser|Schema\ValidationError : ($call is Operation\Repos\AddUserAccessRestrictions::OPERATION_MATCH ? Schema\SimpleUser|Schema\ValidationError : ($call is Operation\Repos\RemoveUserAccessRestrictions::OPERATION_MATCH ? Schema\SimpleUser|Schema\ValidationError : ($call is Operation\Repos\RenameBranch::OPERATION_MATCH ? Schema\BranchWithProtection|Schema\BasicError|Schema\ValidationError : ($call is Operation\Checks\Create::OPERATION_MATCH ? Schema\CheckRun : ($call is Operation\Checks\Get::OPERATION_MATCH ? Schema\CheckRun : ($call is Operation\Checks\Update::OPERATION_MATCH ? Schema\CheckRun : ($call is Operation\Checks\ListAnnotations::OPERATION_MATCH ? Schema\CheckAnnotation : ($call is Operation\Checks\RerequestRun::OPERATION_MATCH ? Schema\EmptyObject|Schema\BasicError : ($call is Operation\Checks\CreateSuite::OPERATION_MATCH ? Schema\CheckSuite : ($call is Operation\Checks\SetSuitesPreferences::OPERATION_MATCH ? Schema\CheckSuitePreference : ($call is Operation\Checks\GetSuite::OPERATION_MATCH ? Schema\CheckSuite : ($call is Operation\Checks\ListForSuite::OPERATION_MATCH ? Schema\Operation\Checks\ListForSuite\Response\Applicationjson\H200 : ($call is Operation\Checks\RerequestSuite::OPERATION_MATCH ? Schema\EmptyObject : ($call is Operation\CodeScanning\ListAlertsForRepo::OPERATION_MATCH ? Schema\CodeScanningAlertItems|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 : ($call is Operation\CodeScanning\GetAlert::OPERATION_MATCH ? Schema\CodeScanningAlert|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 : ($call is Operation\CodeScanning\UpdateAlert::OPERATION_MATCH ? Schema\CodeScanningAlert|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 : ($call is Operation\CodeScanning\ListAlertInstances::OPERATION_MATCH ? Schema\CodeScanningAlertInstance|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 : ($call is Operation\CodeScanning\ListRecentAnalyses::OPERATION_MATCH ? Schema\CodeScanningAnalysis|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 : ($call is Operation\CodeScanning\GetAnalysis::OPERATION_MATCH ? Schema\CodeScanningAnalysis|Schema\AuditLogEvent\Data|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 : ($call is Operation\CodeScanning\DeleteAnalysis::OPERATION_MATCH ? Schema\CodeScanningAnalysisDeletion|Schema\BasicError|Schema\ScimError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 : ($call is Operation\CodeScanning\UploadSarif::OPERATION_MATCH ? Schema\CodeScanningSarifsReceipt|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 : ($call is Operation\CodeScanning\GetSarif::OPERATION_MATCH ? Schema\CodeScanningSarifsStatus|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 : ($call is Operation\Repos\CodeownersErrors::OPERATION_MATCH ? Schema\CodeownersErrors : ($call is Operation\Repos\ListCollaborators::OPERATION_MATCH ? Schema\Collaborator|Schema\BasicError : ($call is Operation\Repos\CheckCollaborator::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Repos\AddCollaborator::OPERATION_MATCH ? Schema\RepositoryInvitation|Schema\ValidationError|Schema\BasicError : ($call is Operation\Repos\RemoveCollaborator::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Repos\GetCollaboratorPermissionLevel::OPERATION_MATCH ? Schema\RepositoryCollaboratorPermission|Schema\BasicError : ($call is Operation\Repos\ListCommitCommentsForRepo::OPERATION_MATCH ? Schema\CommitComment : ($call is Operation\Repos\GetCommitComment::OPERATION_MATCH ? Schema\CommitComment|Schema\BasicError : ($call is Operation\Repos\DeleteCommitComment::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Repos\UpdateCommitComment::OPERATION_MATCH ? Schema\CommitComment|Schema\BasicError : ($call is Operation\Reactions\ListForCommitComment::OPERATION_MATCH ? Schema\Reaction|Schema\BasicError : ($call is Operation\Reactions\CreateForCommitComment::OPERATION_MATCH ? Schema\Reaction|Schema\ValidationError : ($call is Operation\Reactions\DeleteForCommitComment::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Repos\ListCommits::OPERATION_MATCH ? Schema\Commit|Schema\BasicError|Schema\ScimError : ($call is Operation\Repos\ListBranchesForHeadCommit::OPERATION_MATCH ? Schema\BranchShort|Schema\ValidationError : ($call is Operation\Repos\ListCommentsForCommit::OPERATION_MATCH ? Schema\CommitComment : ($call is Operation\Repos\CreateCommitComment::OPERATION_MATCH ? Schema\CommitComment|Schema\BasicError|Schema\ValidationError : ($call is Operation\Repos\ListPullRequestsAssociatedWithCommit::OPERATION_MATCH ? Schema\PullRequestSimple : ($call is Operation\Repos\GetCommit::OPERATION_MATCH ? Schema\Commit|Schema\ValidationError|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 : ($call is Operation\Checks\ListForRef::OPERATION_MATCH ? Schema\Operation\Checks\ListForSuite\Response\Applicationjson\H200 : ($call is Operation\Checks\ListSuitesForRef::OPERATION_MATCH ? Schema\Operation\Checks\ListSuitesForRef\Response\Applicationjson\H200 : ($call is Operation\Repos\GetCombinedStatusForRef::OPERATION_MATCH ? Schema\CombinedCommitStatus|Schema\BasicError : ($call is Operation\Repos\ListCommitStatusesForRef::OPERATION_MATCH ? Schema\Status|Schema\BasicError : ($call is Operation\Repos\CompareCommits::OPERATION_MATCH ? Schema\CommitComparison|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 : ($call is Operation\Repos\GetContent::OPERATION_MATCH ? Schema\ContentTree|Schema\Operation\Repos\GetContent\Response\Applicationjson\H200|Schema\BasicError : ($call is Operation\Repos\CreateOrUpdateFileContents::OPERATION_MATCH ? Schema\FileCommit|Schema\BasicError|Schema\ValidationError : ($call is Operation\Repos\DeleteFile::OPERATION_MATCH ? Schema\FileCommit|Schema\ValidationError|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 : ($call is Operation\Repos\ListContributors::OPERATION_MATCH ? Schema\Contributor|Schema\BasicError : ($call is Operation\Dependabot\ListRepoSecrets::OPERATION_MATCH ? Schema\Operation\Dependabot\ListRepoSecrets\Response\Applicationjson\H200 : ($call is Operation\Dependabot\GetRepoPublicKey::OPERATION_MATCH ? Schema\DependabotPublicKey : ($call is Operation\Dependabot\GetRepoSecret::OPERATION_MATCH ? Schema\DependabotSecret : ($call is Operation\Dependabot\CreateOrUpdateRepoSecret::OPERATION_MATCH ? Schema\EmptyObject : ($call is Operation\Dependabot\DeleteRepoSecret::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\DependencyGraph\DiffRange::OPERATION_MATCH ? Schema\DependencyGraphDiff|Schema\BasicError : ($call is Operation\Repos\ListDeployments::OPERATION_MATCH ? Schema\Deployment : ($call is Operation\Repos\CreateDeployment::OPERATION_MATCH ? Schema\Deployment|Schema\Operation\Activity\MarkNotificationsAsRead\Response\Applicationjson\H202|Schema\ValidationError : ($call is Operation\Repos\GetDeployment::OPERATION_MATCH ? Schema\Deployment|Schema\BasicError : ($call is Operation\Repos\DeleteDeployment::OPERATION_MATCH ? Schema\BasicError|Schema\ValidationErrorSimple : ($call is Operation\Repos\ListDeploymentStatuses::OPERATION_MATCH ? Schema\DeploymentStatus|Schema\BasicError : ($call is Operation\Repos\CreateDeploymentStatus::OPERATION_MATCH ? Schema\DeploymentStatus|Schema\ValidationError : ($call is Operation\Repos\GetDeploymentStatus::OPERATION_MATCH ? Schema\DeploymentStatus|Schema\BasicError : ($call is Operation\Repos\CreateDispatchEvent::OPERATION_MATCH ? Schema\ValidationError : ($call is Operation\Repos\GetAllEnvironments::OPERATION_MATCH ? Schema\Operation\Repos\GetAllEnvironments\Response\Applicationjson\H200 : ($call is Operation\Repos\GetEnvironment::OPERATION_MATCH ? Schema\Environment : ($call is Operation\Repos\CreateOrUpdateEnvironment::OPERATION_MATCH ? Schema\Environment|Schema\BasicError : ($call is Operation\Repos\DeleteAnEnvironment::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Repos\ListDeploymentBranchPolicies::OPERATION_MATCH ? Schema\Operation\Repos\ListDeploymentBranchPolicies\Response\Applicationjson\H200 : ($call is Operation\Repos\CreateDeploymentBranchPolicy::OPERATION_MATCH ? Schema\DeploymentBranchPolicy : ($call is Operation\Repos\GetDeploymentBranchPolicy::OPERATION_MATCH ? Schema\DeploymentBranchPolicy : ($call is Operation\Repos\UpdateDeploymentBranchPolicy::OPERATION_MATCH ? Schema\DeploymentBranchPolicy : ($call is Operation\Repos\DeleteDeploymentBranchPolicy::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Activity\ListRepoEvents::OPERATION_MATCH ? Schema\Event : ($call is Operation\Repos\ListForks::OPERATION_MATCH ? Schema\MinimalRepository|Schema\BasicError|Schema\ScimError : ($call is Operation\Repos\CreateFork::OPERATION_MATCH ? Schema\FullRepository|Schema\BasicError|Schema\ScimError|Schema\ValidationError : ($call is Operation\Git\CreateBlob::OPERATION_MATCH ? Schema\ShortBlob|Schema\BasicError|Schema\ValidationError : ($call is Operation\Git\GetBlob::OPERATION_MATCH ? Schema\Blob|Schema\BasicError|Schema\ValidationError : ($call is Operation\Git\CreateCommit::OPERATION_MATCH ? Schema\GitCommit|Schema\ValidationError|Schema\BasicError : ($call is Operation\Git\GetCommit::OPERATION_MATCH ? Schema\GitCommit|Schema\BasicError : ($call is Operation\Git\ListMatchingRefs::OPERATION_MATCH ? Schema\GitRef : ($call is Operation\Git\GetRef::OPERATION_MATCH ? Schema\GitRef|Schema\BasicError : ($call is Operation\Git\CreateRef::OPERATION_MATCH ? Schema\GitRef|Schema\ValidationError : ($call is Operation\Git\DeleteRef::OPERATION_MATCH ? Schema\ValidationError : ($call is Operation\Git\UpdateRef::OPERATION_MATCH ? Schema\GitRef|Schema\ValidationError : ($call is Operation\Git\CreateTag::OPERATION_MATCH ? Schema\GitTag|Schema\ValidationError : ($call is Operation\Git\GetTag::OPERATION_MATCH ? Schema\GitTag|Schema\BasicError : ($call is Operation\Git\CreateTree::OPERATION_MATCH ? Schema\GitTree|Schema\ValidationError|Schema\BasicError : ($call is Operation\Git\GetTree::OPERATION_MATCH ? Schema\GitTree|Schema\ValidationError|Schema\BasicError : ($call is Operation\Repos\ListWebhooks::OPERATION_MATCH ? Schema\Hook|Schema\BasicError : ($call is Operation\Repos\CreateWebhook::OPERATION_MATCH ? Schema\Hook|Schema\BasicError|Schema\ValidationError : ($call is Operation\Repos\GetWebhook::OPERATION_MATCH ? Schema\Hook|Schema\BasicError : ($call is Operation\Repos\DeleteWebhook::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Repos\UpdateWebhook::OPERATION_MATCH ? Schema\Hook|Schema\ValidationError|Schema\BasicError : ($call is Operation\Repos\GetWebhookConfigForRepo::OPERATION_MATCH ? Schema\WebhookConfig : ($call is Operation\Repos\UpdateWebhookConfigForRepo::OPERATION_MATCH ? Schema\WebhookConfig : ($call is Operation\Repos\ListWebhookDeliveries::OPERATION_MATCH ? Schema\HookDeliveryItem|Schema\BasicError|Schema\ScimError|Schema\ValidationError : ($call is Operation\Repos\GetWebhookDelivery::OPERATION_MATCH ? Schema\HookDelivery|Schema\BasicError|Schema\ScimError|Schema\ValidationError : ($call is Operation\Repos\RedeliverWebhookDelivery::OPERATION_MATCH ? Schema\AuditLogEvent\Config|Schema\BasicError|Schema\ScimError|Schema\ValidationError : ($call is Operation\Repos\PingWebhook::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Repos\TestPushWebhook::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Apps\GetRepoInstallation::OPERATION_MATCH ? Schema\Installation|Schema\BasicError : ($call is Operation\Repos\ListInvitations::OPERATION_MATCH ? Schema\RepositoryInvitation : ($call is Operation\Repos\DeleteInvitation::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Repos\UpdateInvitation::OPERATION_MATCH ? Schema\RepositoryInvitation : ($call is Operation\Issues\ListForRepo::OPERATION_MATCH ? Schema\Issue|Schema\BasicError|Schema\ValidationError : ($call is Operation\Issues\Create::OPERATION_MATCH ? Schema\Issue|Schema\BasicError|Schema\ValidationError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 : ($call is Operation\Issues\ListCommentsForRepo::OPERATION_MATCH ? Schema\IssueComment|Schema\ValidationError|Schema\BasicError : ($call is Operation\Issues\GetComment::OPERATION_MATCH ? Schema\IssueComment|Schema\BasicError : ($call is Operation\Issues\DeleteComment::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Issues\UpdateComment::OPERATION_MATCH ? Schema\IssueComment|Schema\ValidationError : ($call is Operation\Reactions\ListForIssueComment::OPERATION_MATCH ? Schema\Reaction|Schema\BasicError : ($call is Operation\Reactions\CreateForIssueComment::OPERATION_MATCH ? Schema\Reaction|Schema\ValidationError : ($call is Operation\Reactions\DeleteForIssueComment::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Issues\ListEventsForRepo::OPERATION_MATCH ? Schema\IssueEvent|Schema\ValidationError : ($call is Operation\Issues\GetEvent::OPERATION_MATCH ? Schema\IssueEvent|Schema\BasicError : ($call is Operation\Issues\Get::OPERATION_MATCH ? Schema\Issue|Schema\BasicError : ($call is Operation\Issues\Update::OPERATION_MATCH ? Schema\Issue|Schema\ValidationError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503|Schema\BasicError : ($call is Operation\Issues\AddAssignees::OPERATION_MATCH ? Schema\Issue : ($call is Operation\Issues\RemoveAssignees::OPERATION_MATCH ? Schema\Issue : ($call is Operation\Issues\CheckUserCanBeAssignedToIssue::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Issues\ListComments::OPERATION_MATCH ? Schema\IssueComment|Schema\BasicError : ($call is Operation\Issues\CreateComment::OPERATION_MATCH ? Schema\IssueComment|Schema\BasicError|Schema\ValidationError : ($call is Operation\Issues\ListEvents::OPERATION_MATCH ? Schema\IssueEventForIssue|Schema\BasicError : ($call is Operation\Issues\ListLabelsOnIssue::OPERATION_MATCH ? Schema\Label|Schema\BasicError : ($call is Operation\Issues\SetLabels::OPERATION_MATCH ? Schema\Label|Schema\BasicError|Schema\ValidationError : ($call is Operation\Issues\AddLabels::OPERATION_MATCH ? Schema\Label|Schema\BasicError|Schema\ValidationError : ($call is Operation\Issues\RemoveAllLabels::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Issues\RemoveLabel::OPERATION_MATCH ? Schema\Label|Schema\BasicError : ($call is Operation\Issues\Lock::OPERATION_MATCH ? Schema\BasicError|Schema\ValidationError : ($call is Operation\Issues\Unlock::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Reactions\ListForIssue::OPERATION_MATCH ? Schema\Reaction|Schema\BasicError : ($call is Operation\Reactions\CreateForIssue::OPERATION_MATCH ? Schema\Reaction|Schema\ValidationError : ($call is Operation\Reactions\DeleteForIssue::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Issues\ListEventsForTimeline::OPERATION_MATCH ? Schema\TimelineIssueEvents|Schema\BasicError : ($call is Operation\Repos\ListDeployKeys::OPERATION_MATCH ? Schema\DeployKey : ($call is Operation\Repos\CreateDeployKey::OPERATION_MATCH ? Schema\DeployKey|Schema\ValidationError : ($call is Operation\Repos\GetDeployKey::OPERATION_MATCH ? Schema\DeployKey|Schema\BasicError : ($call is Operation\Repos\DeleteDeployKey::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Issues\ListLabelsForRepo::OPERATION_MATCH ? Schema\Label|Schema\BasicError : ($call is Operation\Issues\CreateLabel::OPERATION_MATCH ? Schema\Label|Schema\ValidationError|Schema\BasicError : ($call is Operation\Issues\GetLabel::OPERATION_MATCH ? Schema\Label|Schema\BasicError : ($call is Operation\Issues\DeleteLabel::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Issues\UpdateLabel::OPERATION_MATCH ? Schema\Label : ($call is Operation\Repos\ListLanguages::OPERATION_MATCH ? Schema\Language : ($call is Operation\Repos\EnableLfsForRepo::OPERATION_MATCH ? Schema\AuditLogEvent\Config : ($call is Operation\Repos\DisableLfsForRepo::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Licenses\GetForRepo::OPERATION_MATCH ? Schema\LicenseContent : ($call is Operation\Repos\MergeUpstream::OPERATION_MATCH ? Schema\MergedUpstream : ($call is Operation\Repos\Merge::OPERATION_MATCH ? Schema\Commit|Schema\BasicError|Schema\ValidationError : ($call is Operation\Issues\ListMilestones::OPERATION_MATCH ? Schema\Milestone|Schema\BasicError : ($call is Operation\Issues\CreateMilestone::OPERATION_MATCH ? Schema\Milestone|Schema\BasicError|Schema\ValidationError : ($call is Operation\Issues\GetMilestone::OPERATION_MATCH ? Schema\Milestone|Schema\BasicError : ($call is Operation\Issues\DeleteMilestone::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Issues\UpdateMilestone::OPERATION_MATCH ? Schema\Milestone : ($call is Operation\Issues\ListLabelsForMilestone::OPERATION_MATCH ? Schema\Label : ($call is Operation\Activity\ListRepoNotificationsForAuthenticatedUser::OPERATION_MATCH ? Schema\Thread : ($call is Operation\Activity\MarkRepoNotificationsAsRead::OPERATION_MATCH ? Schema\Operation\EnterpriseAdmin\UpdateOrgName\Response\Applicationjson\H202 : ($call is Operation\Repos\GetPages::OPERATION_MATCH ? Schema\Page|Schema\BasicError : ($call is Operation\Repos\UpdateInformationAboutPagesSite::OPERATION_MATCH ? Schema\ValidationError|Schema\BasicError|Schema\ScimError : ($call is Operation\Repos\CreatePagesSite::OPERATION_MATCH ? Schema\Page|Schema\ValidationError|Schema\BasicError : ($call is Operation\Repos\DeletePagesSite::OPERATION_MATCH ? Schema\ValidationError|Schema\BasicError : ($call is Operation\Repos\ListPagesBuilds::OPERATION_MATCH ? Schema\PageBuild : ($call is Operation\Repos\RequestPagesBuild::OPERATION_MATCH ? Schema\PageBuildStatus : ($call is Operation\Repos\GetLatestPagesBuild::OPERATION_MATCH ? Schema\PageBuild : ($call is Operation\Repos\GetPagesBuild::OPERATION_MATCH ? Schema\PageBuild : ($call is Operation\EnterpriseAdmin\ListPreReceiveHooksForRepo::OPERATION_MATCH ? Schema\RepositoryPreReceiveHook : ($call is Operation\EnterpriseAdmin\GetPreReceiveHookForRepo::OPERATION_MATCH ? Schema\RepositoryPreReceiveHook : ($call is Operation\EnterpriseAdmin\RemovePreReceiveHookEnforcementForRepo::OPERATION_MATCH ? Schema\RepositoryPreReceiveHook : ($call is Operation\EnterpriseAdmin\UpdatePreReceiveHookEnforcementForRepo::OPERATION_MATCH ? Schema\RepositoryPreReceiveHook : ($call is Operation\Projects\ListForRepo::OPERATION_MATCH ? Schema\Project|Schema\BasicError|Schema\ValidationErrorSimple : ($call is Operation\Projects\CreateForRepo::OPERATION_MATCH ? Schema\Project|Schema\BasicError|Schema\ValidationErrorSimple : ($call is Operation\Pulls\List_::OPERATION_MATCH ? Schema\PullRequestSimple|Schema\ValidationError : ($call is Operation\Pulls\Create::OPERATION_MATCH ? Schema\PullRequest|Schema\BasicError|Schema\ValidationError : ($call is Operation\Pulls\ListReviewCommentsForRepo::OPERATION_MATCH ? Schema\PullRequestReviewComment : ($call is Operation\Pulls\GetReviewComment::OPERATION_MATCH ? Schema\PullRequestReviewComment|Schema\BasicError : ($call is Operation\Pulls\DeleteReviewComment::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Pulls\UpdateReviewComment::OPERATION_MATCH ? Schema\PullRequestReviewComment : ($call is Operation\Reactions\ListForPullRequestReviewComment::OPERATION_MATCH ? Schema\Reaction|Schema\BasicError : ($call is Operation\Reactions\CreateForPullRequestReviewComment::OPERATION_MATCH ? Schema\Reaction|Schema\ValidationError : ($call is Operation\Reactions\DeleteForPullRequestComment::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Pulls\Get::OPERATION_MATCH ? Schema\PullRequest|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 : ($call is Operation\Pulls\Update::OPERATION_MATCH ? Schema\PullRequest|Schema\ValidationError|Schema\BasicError : ($call is Operation\Pulls\ListReviewComments::OPERATION_MATCH ? Schema\PullRequestReviewComment : ($call is Operation\Pulls\CreateReviewComment::OPERATION_MATCH ? Schema\PullRequestReviewComment|Schema\ValidationError|Schema\BasicError : ($call is Operation\Pulls\CreateReplyForReviewComment::OPERATION_MATCH ? Schema\PullRequestReviewComment|Schema\BasicError : ($call is Operation\Pulls\ListCommits::OPERATION_MATCH ? Schema\Commit : ($call is Operation\Pulls\ListFiles::OPERATION_MATCH ? Schema\DiffEntry|Schema\ValidationError|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 : ($call is Operation\Pulls\CheckIfMerged::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Pulls\Merge::OPERATION_MATCH ? Schema\PullRequestMergeResult|Schema\Operation\Orgs\RemoveOutsideCollaborator\Response\Applicationjson\H422|Schema\ValidationError|Schema\BasicError : ($call is Operation\Pulls\ListRequestedReviewers::OPERATION_MATCH ? Schema\PullRequestReviewRequest : ($call is Operation\Pulls\RequestReviewers::OPERATION_MATCH ? Schema\PullRequestSimple|Schema\BasicError : ($call is Operation\Pulls\RemoveRequestedReviewers::OPERATION_MATCH ? Schema\PullRequestSimple|Schema\ValidationError : ($call is Operation\Pulls\ListReviews::OPERATION_MATCH ? Schema\PullRequestReview : ($call is Operation\Pulls\CreateReview::OPERATION_MATCH ? Schema\PullRequestReview|Schema\ValidationErrorSimple|Schema\BasicError : ($call is Operation\Pulls\GetReview::OPERATION_MATCH ? Schema\PullRequestReview|Schema\BasicError : ($call is Operation\Pulls\UpdateReview::OPERATION_MATCH ? Schema\PullRequestReview|Schema\ValidationErrorSimple : ($call is Operation\Pulls\DeletePendingReview::OPERATION_MATCH ? Schema\PullRequestReview|Schema\ValidationErrorSimple|Schema\BasicError : ($call is Operation\Pulls\ListCommentsForReview::OPERATION_MATCH ? Schema\ReviewComment|Schema\BasicError : ($call is Operation\Pulls\DismissReview::OPERATION_MATCH ? Schema\PullRequestReview|Schema\BasicError|Schema\ValidationErrorSimple : ($call is Operation\Pulls\SubmitReview::OPERATION_MATCH ? Schema\PullRequestReview|Schema\BasicError|Schema\ValidationErrorSimple : ($call is Operation\Pulls\UpdateBranch::OPERATION_MATCH ? Schema\Operation\EnterpriseAdmin\UpdateOrgName\Response\Applicationjson\H202|Schema\ValidationError|Schema\BasicError : ($call is Operation\Repos\GetReadme::OPERATION_MATCH ? Schema\ContentFile|Schema\BasicError|Schema\ValidationError : ($call is Operation\Repos\GetReadmeInDirectory::OPERATION_MATCH ? Schema\ContentFile|Schema\BasicError|Schema\ValidationError : ($call is Operation\Repos\ListReleases::OPERATION_MATCH ? Schema\Release|Schema\BasicError : ($call is Operation\Repos\CreateRelease::OPERATION_MATCH ? Schema\Release|Schema\ValidationError : ($call is Operation\Repos\GetReleaseAsset::OPERATION_MATCH ? Schema\ReleaseAsset|Schema\BasicError : ($call is Operation\Repos\DeleteReleaseAsset::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Repos\UpdateReleaseAsset::OPERATION_MATCH ? Schema\ReleaseAsset : ($call is Operation\Repos\GenerateReleaseNotes::OPERATION_MATCH ? Schema\ReleaseNotesContent|Schema\BasicError : ($call is Operation\Repos\GetLatestRelease::OPERATION_MATCH ? Schema\Release : ($call is Operation\Repos\GetReleaseByTag::OPERATION_MATCH ? Schema\Release|Schema\BasicError : ($call is Operation\Repos\GetRelease::OPERATION_MATCH ? Schema\Release|Schema\BasicError : ($call is Operation\Repos\DeleteRelease::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Repos\UpdateRelease::OPERATION_MATCH ? Schema\Release : ($call is Operation\Repos\ListReleaseAssets::OPERATION_MATCH ? Schema\ReleaseAsset : ($call is Operation\Repos\UploadReleaseAsset::OPERATION_MATCH ? Schema\ReleaseAsset : ($call is Operation\Reactions\ListForRelease::OPERATION_MATCH ? Schema\Reaction|Schema\BasicError : ($call is Operation\Reactions\CreateForRelease::OPERATION_MATCH ? Schema\Reaction|Schema\ValidationError : ($call is Operation\Reactions\DeleteForRelease::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Repos\ListCacheInfo::OPERATION_MATCH ? Schema\Operation\Repos\ListCacheInfo\Response\Applicationjson\H200|Schema\BasicError : ($call is Operation\SecretScanning\ListAlertsForRepo::OPERATION_MATCH ? Schema\SecretScanningAlert|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 : ($call is Operation\SecretScanning\GetAlert::OPERATION_MATCH ? Schema\SecretScanningAlert|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 : ($call is Operation\SecretScanning\UpdateAlert::OPERATION_MATCH ? Schema\SecretScanningAlert|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 : ($call is Operation\SecretScanning\ListLocationsForAlert::OPERATION_MATCH ? Schema\SecretScanningLocation|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 : ($call is Operation\Activity\ListStargazersForRepo::OPERATION_MATCH ? Schema\Operation\Activity\ListStargazersForRepo\Response\Applicationjson\H200|Schema\ValidationError : ($call is Operation\Repos\GetCodeFrequencyStats::OPERATION_MATCH ? Schema\Operation\Repos\GetCodeFrequencyStats\Response\Applicationjson\H200|Schema\AuditLogEvent\Config : ($call is Operation\Repos\GetCommitActivityStats::OPERATION_MATCH ? Schema\CommitActivity|Schema\AuditLogEvent\Config : ($call is Operation\Repos\GetContributorsStats::OPERATION_MATCH ? Schema\ContributorActivity|Schema\AuditLogEvent\Config : ($call is Operation\Repos\GetParticipationStats::OPERATION_MATCH ? Schema\ParticipationStats|Schema\BasicError : ($call is Operation\Repos\GetPunchCardStats::OPERATION_MATCH ? Schema\Operation\Repos\GetCodeFrequencyStats\Response\Applicationjson\H200 : ($call is Operation\Repos\CreateCommitStatus::OPERATION_MATCH ? Schema\Status : ($call is Operation\Activity\ListWatchersForRepo::OPERATION_MATCH ? Schema\SimpleUser : ($call is Operation\Activity\GetRepoSubscription::OPERATION_MATCH ? Schema\RepositorySubscription|Schema\BasicError : ($call is Operation\Activity\SetRepoSubscription::OPERATION_MATCH ? Schema\RepositorySubscription : ($call is Operation\Activity\DeleteRepoSubscription::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Repos\ListTags::OPERATION_MATCH ? Schema\Tag : ($call is Operation\Repos\ListTagProtection::OPERATION_MATCH ? Schema\TagProtection|Schema\BasicError : ($call is Operation\Repos\CreateTagProtection::OPERATION_MATCH ? Schema\TagProtection|Schema\BasicError : ($call is Operation\Repos\DeleteTagProtection::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Repos\DownloadTarballArchive::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Repos\ListTeams::OPERATION_MATCH ? Schema\Team : ($call is Operation\Repos\GetAllTopics::OPERATION_MATCH ? Schema\Topic|Schema\BasicError : ($call is Operation\Repos\ReplaceAllTopics::OPERATION_MATCH ? Schema\Topic|Schema\BasicError|Schema\ValidationErrorSimple : ($call is Operation\Repos\Transfer::OPERATION_MATCH ? Schema\MinimalRepository : ($call is Operation\Repos\DownloadZipballArchive::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Repos\CreateUsingTemplate::OPERATION_MATCH ? Schema\Repository : ($call is Operation\Repos\ListPublic::OPERATION_MATCH ? Schema\MinimalRepository|Schema\ValidationError : ($call is Operation\Actions\ListEnvironmentSecrets::OPERATION_MATCH ? Schema\Operation\Actions\ListRepoSecrets\Response\Applicationjson\H200 : ($call is Operation\Actions\GetEnvironmentPublicKey::OPERATION_MATCH ? Schema\ActionsPublicKey : ($call is Operation\Actions\GetEnvironmentSecret::OPERATION_MATCH ? Schema\ActionsSecret : ($call is Operation\Actions\CreateOrUpdateEnvironmentSecret::OPERATION_MATCH ? Schema\EmptyObject : ($call is Operation\Actions\DeleteEnvironmentSecret::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\EnterpriseAdmin\ListProvisionedGroupsEnterprise::OPERATION_MATCH ? Schema\ScimEnterpriseGroupList|Schema\ScimError : ($call is Operation\EnterpriseAdmin\ProvisionEnterpriseGroup::OPERATION_MATCH ? Schema\ScimEnterpriseGroupResponse|Schema\ScimError : ($call is Operation\EnterpriseAdmin\GetProvisioningInformationForEnterpriseGroup::OPERATION_MATCH ? Schema\ScimEnterpriseGroupResponse|Schema\ScimError|Schema\BasicError : ($call is Operation\EnterpriseAdmin\SetInformationForProvisionedEnterpriseGroup::OPERATION_MATCH ? Schema\ScimEnterpriseGroupResponse|Schema\ScimError|Schema\BasicError : ($call is Operation\EnterpriseAdmin\DeleteScimGroupFromEnterprise::OPERATION_MATCH ? Schema\ScimError|Schema\BasicError : ($call is Operation\EnterpriseAdmin\UpdateAttributeForEnterpriseGroup::OPERATION_MATCH ? Schema\ScimEnterpriseGroupResponse|Schema\ScimError|Schema\BasicError : ($call is Operation\EnterpriseAdmin\ListProvisionedIdentitiesEnterprise::OPERATION_MATCH ? Schema\ScimEnterpriseUserList|Schema\ScimError : ($call is Operation\EnterpriseAdmin\ProvisionEnterpriseUser::OPERATION_MATCH ? Schema\ScimEnterpriseUserResponse|Schema\ScimError : ($call is Operation\EnterpriseAdmin\GetProvisioningInformationForEnterpriseUser::OPERATION_MATCH ? Schema\ScimEnterpriseUserResponse|Schema\ScimError|Schema\BasicError : ($call is Operation\EnterpriseAdmin\SetInformationForProvisionedEnterpriseUser::OPERATION_MATCH ? Schema\ScimEnterpriseUserResponse|Schema\ScimError|Schema\BasicError : ($call is Operation\EnterpriseAdmin\DeleteUserFromEnterprise::OPERATION_MATCH ? Schema\ScimError|Schema\BasicError : ($call is Operation\EnterpriseAdmin\UpdateAttributeForEnterpriseUser::OPERATION_MATCH ? Schema\ScimEnterpriseUserResponse|Schema\ScimError|Schema\BasicError : ($call is Operation\Search\Code::OPERATION_MATCH ? Schema\Operation\Search\Code\Response\Applicationjson\H200|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503|Schema\ValidationError|Schema\BasicError : ($call is Operation\Search\Commits::OPERATION_MATCH ? Schema\Operation\Search\Commits\Response\Applicationjson\H200 : ($call is Operation\Search\IssuesAndPullRequests::OPERATION_MATCH ? Schema\Operation\Search\IssuesAndPullRequests\Response\Applicationjson\H200|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503|Schema\ValidationError|Schema\BasicError : ($call is Operation\Search\Labels::OPERATION_MATCH ? Schema\Operation\Search\Labels\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationError : ($call is Operation\Search\Repos::OPERATION_MATCH ? Schema\Operation\Search\Repos\Response\Applicationjson\H200|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503|Schema\ValidationError : ($call is Operation\Search\Topics::OPERATION_MATCH ? Schema\Operation\Search\Topics\Response\Applicationjson\H200 : ($call is Operation\Search\Users::OPERATION_MATCH ? Schema\Operation\Search\Users\Response\Applicationjson\H200|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503|Schema\ValidationError : ($call is Operation\EnterpriseAdmin\GetConfigurationStatus::OPERATION_MATCH ? Schema\ConfigurationStatus : ($call is Operation\EnterpriseAdmin\StartConfigurationProcess::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\EnterpriseAdmin\GetMaintenanceStatus::OPERATION_MATCH ? Schema\MaintenanceStatus : ($call is Operation\EnterpriseAdmin\EnableOrDisableMaintenanceMode::OPERATION_MATCH ? Schema\MaintenanceStatus : ($call is Operation\EnterpriseAdmin\GetSettings::OPERATION_MATCH ? Schema\EnterpriseSettings : ($call is Operation\EnterpriseAdmin\SetSettings::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\EnterpriseAdmin\GetAllAuthorizedSshKeys::OPERATION_MATCH ? Schema\SshKey : ($call is Operation\EnterpriseAdmin\AddAuthorizedSshKey::OPERATION_MATCH ? Schema\SshKey : ($call is Operation\EnterpriseAdmin\RemoveAuthorizedSshKey::OPERATION_MATCH ? Schema\SshKey : ($call is Operation\EnterpriseAdmin\CreateEnterpriseServerLicense::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\EnterpriseAdmin\UpgradeLicense::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Teams\GetLegacy::OPERATION_MATCH ? Schema\TeamFull|Schema\BasicError : ($call is Operation\Teams\DeleteLegacy::OPERATION_MATCH ? Schema\BasicError|Schema\ValidationError : ($call is Operation\Teams\UpdateLegacy::OPERATION_MATCH ? Schema\TeamFull|Schema\BasicError|Schema\ValidationError : ($call is Operation\Teams\ListDiscussionsLegacy::OPERATION_MATCH ? Schema\TeamDiscussion : ($call is Operation\Teams\CreateDiscussionLegacy::OPERATION_MATCH ? Schema\TeamDiscussion : ($call is Operation\Teams\GetDiscussionLegacy::OPERATION_MATCH ? Schema\TeamDiscussion : ($call is Operation\Teams\DeleteDiscussionLegacy::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Teams\UpdateDiscussionLegacy::OPERATION_MATCH ? Schema\TeamDiscussion : ($call is Operation\Teams\ListDiscussionCommentsLegacy::OPERATION_MATCH ? Schema\TeamDiscussionComment : ($call is Operation\Teams\CreateDiscussionCommentLegacy::OPERATION_MATCH ? Schema\TeamDiscussionComment : ($call is Operation\Teams\GetDiscussionCommentLegacy::OPERATION_MATCH ? Schema\TeamDiscussionComment : ($call is Operation\Teams\DeleteDiscussionCommentLegacy::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Teams\UpdateDiscussionCommentLegacy::OPERATION_MATCH ? Schema\TeamDiscussionComment : ($call is Operation\Reactions\ListForTeamDiscussionCommentLegacy::OPERATION_MATCH ? Schema\Reaction : ($call is Operation\Reactions\CreateForTeamDiscussionCommentLegacy::OPERATION_MATCH ? Schema\Reaction : ($call is Operation\Reactions\ListForTeamDiscussionLegacy::OPERATION_MATCH ? Schema\Reaction : ($call is Operation\Reactions\CreateForTeamDiscussionLegacy::OPERATION_MATCH ? Schema\Reaction : ($call is Operation\Teams\ListMembersLegacy::OPERATION_MATCH ? Schema\SimpleUser|Schema\BasicError : ($call is Operation\Teams\GetMemberLegacy::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Teams\AddMemberLegacy::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Teams\RemoveMemberLegacy::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Teams\GetMembershipForUserLegacy::OPERATION_MATCH ? Schema\TeamMembership|Schema\BasicError : ($call is Operation\Teams\AddOrUpdateMembershipForUserLegacy::OPERATION_MATCH ? Schema\TeamMembership|Schema\BasicError : ($call is Operation\Teams\RemoveMembershipForUserLegacy::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Teams\ListProjectsLegacy::OPERATION_MATCH ? Schema\TeamProject|Schema\BasicError : ($call is Operation\Teams\CheckPermissionsForProjectLegacy::OPERATION_MATCH ? Schema\TeamProject : ($call is Operation\Teams\AddOrUpdateProjectPermissionsLegacy::OPERATION_MATCH ? Schema\Operation\Orgs\RemoveOutsideCollaborator\Response\Applicationjson\H422|Schema\BasicError|Schema\ValidationError : ($call is Operation\Teams\RemoveProjectLegacy::OPERATION_MATCH ? Schema\BasicError|Schema\ValidationError : ($call is Operation\Teams\ListReposLegacy::OPERATION_MATCH ? Schema\MinimalRepository|Schema\BasicError : ($call is Operation\Teams\CheckPermissionsForRepoLegacy::OPERATION_MATCH ? Schema\TeamRepository : ($call is Operation\Teams\AddOrUpdateRepoPermissionsLegacy::OPERATION_MATCH ? Schema\BasicError|Schema\ValidationError : ($call is Operation\Teams\RemoveRepoLegacy::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Teams\ListChildLegacy::OPERATION_MATCH ? Schema\Team|Schema\BasicError|Schema\ValidationError : ($call is Operation\Users\GetAuthenticated::OPERATION_MATCH ? Schema\Operation\Users\GetAuthenticated\Response\Applicationjson\H200|Schema\BasicError : ($call is Operation\Users\UpdateAuthenticated::OPERATION_MATCH ? Schema\PrivateUser|Schema\BasicError|Schema\ValidationError : ($call is Operation\Users\ListEmailsForAuthenticatedUser::OPERATION_MATCH ? Schema\Email|Schema\BasicError : ($call is Operation\Users\AddEmailForAuthenticatedUser::OPERATION_MATCH ? Schema\Email|Schema\ValidationError|Schema\BasicError : ($call is Operation\Users\DeleteEmailForAuthenticatedUser::OPERATION_MATCH ? Schema\BasicError|Schema\ValidationError : ($call is Operation\Users\ListFollowersForAuthenticatedUser::OPERATION_MATCH ? Schema\SimpleUser|Schema\BasicError : ($call is Operation\Users\ListFollowedByAuthenticatedUser::OPERATION_MATCH ? Schema\SimpleUser|Schema\BasicError : ($call is Operation\Users\CheckPersonIsFollowedByAuthenticated::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Users\Follow::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Users\Unfollow::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Users\ListGpgKeysForAuthenticatedUser::OPERATION_MATCH ? Schema\GpgKey|Schema\BasicError : ($call is Operation\Users\CreateGpgKeyForAuthenticatedUser::OPERATION_MATCH ? Schema\GpgKey|Schema\ValidationError|Schema\BasicError : ($call is Operation\Users\GetGpgKeyForAuthenticatedUser::OPERATION_MATCH ? Schema\GpgKey|Schema\BasicError : ($call is Operation\Users\DeleteGpgKeyForAuthenticatedUser::OPERATION_MATCH ? Schema\BasicError|Schema\ValidationError : ($call is Operation\Apps\ListInstallationsForAuthenticatedUser::OPERATION_MATCH ? Schema\Operation\Orgs\ListAppInstallations\Response\Applicationjson\H200|Schema\BasicError : ($call is Operation\Apps\ListInstallationReposForAuthenticatedUser::OPERATION_MATCH ? Schema\Operation\Apps\ListInstallationReposForAuthenticatedUser\Response\Applicationjson\H200|Schema\BasicError : ($call is Operation\Apps\AddRepoToInstallationForAuthenticatedUser::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Apps\RemoveRepoFromInstallationForAuthenticatedUser::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Issues\ListForAuthenticatedUser::OPERATION_MATCH ? Schema\Issue|Schema\BasicError : ($call is Operation\Users\ListPublicSshKeysForAuthenticatedUser::OPERATION_MATCH ? Schema\Key|Schema\BasicError : ($call is Operation\Users\CreatePublicSshKeyForAuthenticatedUser::OPERATION_MATCH ? Schema\Key|Schema\ValidationError|Schema\BasicError : ($call is Operation\Users\GetPublicSshKeyForAuthenticatedUser::OPERATION_MATCH ? Schema\Key|Schema\BasicError : ($call is Operation\Users\DeletePublicSshKeyForAuthenticatedUser::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Orgs\ListMembershipsForAuthenticatedUser::OPERATION_MATCH ? Schema\OrgMembership|Schema\BasicError|Schema\ValidationError : ($call is Operation\Orgs\GetMembershipForAuthenticatedUser::OPERATION_MATCH ? Schema\OrgMembership|Schema\BasicError : ($call is Operation\Orgs\UpdateMembershipForAuthenticatedUser::OPERATION_MATCH ? Schema\OrgMembership|Schema\BasicError|Schema\ValidationError : ($call is Operation\Migrations\ListForAuthenticatedUser::OPERATION_MATCH ? Schema\Migration|Schema\BasicError : ($call is Operation\Migrations\StartForAuthenticatedUser::OPERATION_MATCH ? Schema\Migration|Schema\ValidationError|Schema\BasicError : ($call is Operation\Migrations\GetArchiveForAuthenticatedUser::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Migrations\ListReposForAuthenticatedUser::OPERATION_MATCH ? Schema\MinimalRepository|Schema\BasicError : ($call is Operation\Orgs\ListForAuthenticatedUser::OPERATION_MATCH ? Schema\OrganizationSimple|Schema\BasicError : ($call is Operation\Projects\CreateForAuthenticatedUser::OPERATION_MATCH ? Schema\Project|Schema\BasicError|Schema\ValidationErrorSimple : ($call is Operation\Users\ListPublicEmailsForAuthenticatedUser::OPERATION_MATCH ? Schema\Email|Schema\BasicError : ($call is Operation\Repos\ListForAuthenticatedUser::OPERATION_MATCH ? Schema\Repository|Schema\ValidationError|Schema\BasicError : ($call is Operation\Repos\CreateForAuthenticatedUser::OPERATION_MATCH ? Schema\Repository|Schema\BasicError|Schema\ValidationError|Schema\ScimError : ($call is Operation\Repos\ListInvitationsForAuthenticatedUser::OPERATION_MATCH ? Schema\RepositoryInvitation|Schema\BasicError : ($call is Operation\Repos\DeclineInvitationForAuthenticatedUser::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Repos\AcceptInvitationForAuthenticatedUser::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Activity\ListReposStarredByAuthenticatedUser::OPERATION_MATCH ? Schema\Repository|Schema\StarredRepository|Schema\BasicError : ($call is Operation\Activity\CheckRepoIsStarredByAuthenticatedUser::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Activity\StarRepoForAuthenticatedUser::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Activity\UnstarRepoForAuthenticatedUser::OPERATION_MATCH ? Schema\BasicError : ($call is Operation\Activity\ListWatchedReposForAuthenticatedUser::OPERATION_MATCH ? Schema\MinimalRepository|Schema\BasicError : ($call is Operation\Teams\ListForAuthenticatedUser::OPERATION_MATCH ? Schema\TeamFull|Schema\BasicError : ($call is Operation\Users\List_::OPERATION_MATCH ? Schema\SimpleUser : ($call is Operation\Users\GetByUsername::OPERATION_MATCH ? Schema\Operation\Users\GetAuthenticated\Response\Applicationjson\H200|Schema\BasicError : ($call is Operation\Activity\ListEventsForAuthenticatedUser::OPERATION_MATCH ? Schema\Event : ($call is Operation\Activity\ListOrgEventsForAuthenticatedUser::OPERATION_MATCH ? Schema\Event : ($call is Operation\Activity\ListPublicEventsForUser::OPERATION_MATCH ? Schema\Event : ($call is Operation\Users\ListFollowersForUser::OPERATION_MATCH ? Schema\SimpleUser : ($call is Operation\Users\ListFollowingForUser::OPERATION_MATCH ? Schema\SimpleUser : ($call is Operation\Users\CheckFollowingForUser::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Gists\ListForUser::OPERATION_MATCH ? Schema\BaseGist|Schema\ValidationError : ($call is Operation\Users\ListGpgKeysForUser::OPERATION_MATCH ? Schema\GpgKey : ($call is Operation\Users\GetContextForUser::OPERATION_MATCH ? Schema\Hovercard|Schema\BasicError|Schema\ValidationError : ($call is Operation\Apps\GetUserInstallation::OPERATION_MATCH ? Schema\Installation : ($call is Operation\Users\ListPublicKeysForUser::OPERATION_MATCH ? Schema\KeySimple : ($call is Operation\Orgs\ListForUser::OPERATION_MATCH ? Schema\OrganizationSimple : ($call is Operation\Projects\ListForUser::OPERATION_MATCH ? Schema\Project|Schema\ValidationError : ($call is Operation\Activity\ListReceivedEventsForUser::OPERATION_MATCH ? Schema\Event : ($call is Operation\Activity\ListReceivedPublicEventsForUser::OPERATION_MATCH ? Schema\Event : ($call is Operation\Repos\ListForUser::OPERATION_MATCH ? Schema\MinimalRepository : ($call is Operation\EnterpriseAdmin\PromoteUserToBeSiteAdministrator::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\EnterpriseAdmin\DemoteSiteAdministrator::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\Activity\ListReposStarredByUser::OPERATION_MATCH ? Schema\Operation\Activity\ListReposStarredByUser\Response\Applicationjson\H200 : ($call is Operation\Activity\ListReposWatchedByUser::OPERATION_MATCH ? Schema\MinimalRepository : ($call is Operation\EnterpriseAdmin\SuspendUser::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : ($call is Operation\EnterpriseAdmin\UnsuspendUser::OPERATION_MATCH ? \Psr\Http\Message\ResponseInterface : Schema\Operation\Gitignore\GetAllTemplates\Response\Applicationjson\H200)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
     */
    public function call(string $call, array $params = array())
    {
        return \React\Async\await($this->callAsync($call, $params));
    }
    /**
     * @return ($call is Operation\Meta\Root::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Root> : ($call is Operation\EnterpriseAdmin\ListGlobalWebhooks::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\GlobalHook> : ($call is Operation\EnterpriseAdmin\CreateGlobalWebhook::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\GlobalHook> : ($call is Operation\EnterpriseAdmin\GetGlobalWebhook::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\GlobalHook> : ($call is Operation\EnterpriseAdmin\DeleteGlobalWebhook::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\EnterpriseAdmin\UpdateGlobalWebhook::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\GlobalHook2> : ($call is Operation\EnterpriseAdmin\PingGlobalWebhook::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\EnterpriseAdmin\ListPublicKeys::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PublicKeyFull> : ($call is Operation\EnterpriseAdmin\DeletePublicKey::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\EnterpriseAdmin\UpdateLdapMappingForTeam::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\LdapMappingTeam> : ($call is Operation\EnterpriseAdmin\SyncLdapMappingForTeam::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\EnterpriseAdmin\SyncLdapMappingForTeam\Response\Applicationjson\H201> : ($call is Operation\EnterpriseAdmin\UpdateLdapMappingForUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\LdapMappingUser> : ($call is Operation\EnterpriseAdmin\SyncLdapMappingForUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\EnterpriseAdmin\SyncLdapMappingForTeam\Response\Applicationjson\H201> : ($call is Operation\EnterpriseAdmin\CreateOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\OrganizationSimple> : ($call is Operation\EnterpriseAdmin\UpdateOrgName::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\EnterpriseAdmin\UpdateOrgName\Response\Applicationjson\H202> : ($call is Operation\EnterpriseAdmin\ListPreReceiveEnvironments::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PreReceiveEnvironment> : ($call is Operation\EnterpriseAdmin\CreatePreReceiveEnvironment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PreReceiveEnvironment> : ($call is Operation\EnterpriseAdmin\GetPreReceiveEnvironment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PreReceiveEnvironment> : ($call is Operation\EnterpriseAdmin\DeletePreReceiveEnvironment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\EnterpriseAdmin\DeletePreReceiveEnvironment\Response\Applicationjson\H422> : ($call is Operation\EnterpriseAdmin\UpdatePreReceiveEnvironment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PreReceiveEnvironment|Schema\Operation\EnterpriseAdmin\DeletePreReceiveEnvironment\Response\Applicationjson\H422> : ($call is Operation\EnterpriseAdmin\StartPreReceiveEnvironmentDownload::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PreReceiveEnvironmentDownloadStatus|Schema\Operation\EnterpriseAdmin\DeletePreReceiveEnvironment\Response\Applicationjson\H422> : ($call is Operation\EnterpriseAdmin\GetDownloadStatusForPreReceiveEnvironment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PreReceiveEnvironmentDownloadStatus> : ($call is Operation\EnterpriseAdmin\ListPreReceiveHooks::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PreReceiveHook> : ($call is Operation\EnterpriseAdmin\CreatePreReceiveHook::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PreReceiveHook> : ($call is Operation\EnterpriseAdmin\GetPreReceiveHook::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PreReceiveHook> : ($call is Operation\EnterpriseAdmin\DeletePreReceiveHook::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\EnterpriseAdmin\UpdatePreReceiveHook::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PreReceiveHook> : ($call is Operation\EnterpriseAdmin\ListPersonalAccessTokens::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Authorization> : ($call is Operation\EnterpriseAdmin\DeletePersonalAccessToken::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\EnterpriseAdmin\CreateUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\SimpleUser> : ($call is Operation\EnterpriseAdmin\DeleteUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\EnterpriseAdmin\UpdateUsernameForUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\EnterpriseAdmin\UpdateOrgName\Response\Applicationjson\H202> : ($call is Operation\EnterpriseAdmin\CreateImpersonationOAuthToken::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Authorization> : ($call is Operation\EnterpriseAdmin\DeleteImpersonationOAuthToken::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Apps\GetAuthenticated::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Integration> : ($call is Operation\Apps\CreateFromManifest::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Apps\CreateFromManifest\Response\Applicationjson\H201|Schema\BasicError|Schema\ValidationErrorSimple> : ($call is Operation\Apps\GetWebhookConfigForApp::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\WebhookConfig> : ($call is Operation\Apps\UpdateWebhookConfigForApp::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\WebhookConfig> : ($call is Operation\Apps\ListWebhookDeliveries::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\HookDeliveryItem|Schema\BasicError|Schema\ScimError|Schema\ValidationError> : ($call is Operation\Apps\GetWebhookDelivery::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\HookDelivery|Schema\BasicError|Schema\ScimError|Schema\ValidationError> : ($call is Operation\Apps\RedeliverWebhookDelivery::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\AuditLogEvent\Config|Schema\BasicError|Schema\ScimError|Schema\ValidationError> : ($call is Operation\Apps\ListInstallationRequestsForAuthenticatedApp::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\IntegrationInstallationRequest|Schema\BasicError> : ($call is Operation\Apps\ListInstallations::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Installation> : ($call is Operation\Apps\GetInstallation::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Installation|Schema\BasicError> : ($call is Operation\Apps\DeleteInstallation::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Apps\CreateInstallationAccessToken::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\InstallationToken|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Apps\SuspendInstallation::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Apps\UnsuspendInstallation::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\OauthAuthorizations\ListGrants::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ApplicationGrant|Schema\BasicError> : ($call is Operation\OauthAuthorizations\GetGrant::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ApplicationGrant|Schema\BasicError> : ($call is Operation\OauthAuthorizations\DeleteGrant::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Apps\DeleteAuthorization::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ValidationError> : ($call is Operation\Apps\CheckToken::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Authorization|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Apps\DeleteToken::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ValidationError> : ($call is Operation\Apps\ResetToken::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Authorization|Schema\ValidationError> : ($call is Operation\Apps\ScopeToken::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Authorization|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Apps\GetBySlug::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Integration|Schema\BasicError> : ($call is Operation\OauthAuthorizations\ListAuthorizations::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Authorization|Schema\BasicError> : ($call is Operation\OauthAuthorizations\CreateAuthorization::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Authorization|Schema\ValidationError|Schema\BasicError> : ($call is Operation\OauthAuthorizations\GetOrCreateAuthorizationForApp::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Authorization|Schema\ValidationError|Schema\BasicError> : ($call is Operation\OauthAuthorizations\GetOrCreateAuthorizationForAppAndFingerprint::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Authorization|Schema\ValidationError> : ($call is Operation\OauthAuthorizations\GetAuthorization::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Authorization|Schema\BasicError> : ($call is Operation\OauthAuthorizations\DeleteAuthorization::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\OauthAuthorizations\UpdateAuthorization::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Authorization|Schema\ValidationError> : ($call is Operation\CodesOfConduct\GetAllCodesOfConduct::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\CodeOfConduct> : ($call is Operation\CodesOfConduct\GetConductCode::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\CodeOfConduct|Schema\BasicError> : ($call is Operation\Emojis\Get::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Emojis\Get\Response\Applicationjson\H200> : ($call is Operation\EnterpriseAdmin\GetAnnouncement::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Announcement> : ($call is Operation\EnterpriseAdmin\RemoveAnnouncement::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\EnterpriseAdmin\SetAnnouncement::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Announcement> : ($call is Operation\EnterpriseAdmin\GetLicenseInformation::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\LicenseInfo> : ($call is Operation\EnterpriseAdmin\GetAllStats::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\EnterpriseOverview> : ($call is Operation\EnterpriseAdmin\GetCommentStats::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\EnterpriseCommentOverview> : ($call is Operation\EnterpriseAdmin\GetGistStats::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\EnterpriseGistOverview> : ($call is Operation\EnterpriseAdmin\GetHooksStats::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\EnterpriseHookOverview> : ($call is Operation\EnterpriseAdmin\GetIssueStats::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\EnterpriseIssueOverview> : ($call is Operation\EnterpriseAdmin\GetMilestoneStats::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\EnterpriseMilestoneOverview> : ($call is Operation\EnterpriseAdmin\GetOrgStats::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\EnterpriseOrganizationOverview> : ($call is Operation\EnterpriseAdmin\GetPagesStats::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\EnterprisePageOverview> : ($call is Operation\EnterpriseAdmin\GetPullRequestStats::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\EnterprisePullRequestOverview> : ($call is Operation\EnterpriseAdmin\GetRepoStats::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\EnterpriseRepositoryOverview> : ($call is Operation\EnterpriseAdmin\GetUserStats::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\EnterpriseUserOverview> : ($call is Operation\Actions\GetActionsCacheUsageForEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ActionsCacheUsageOrgEnterprise> : ($call is Operation\Actions\GetActionsCacheUsagePolicyForEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ActionsCacheUsagePolicyEnterprise> : ($call is Operation\Actions\SetActionsCacheUsagePolicyForEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\EnterpriseAdmin\GetGithubActionsPermissionsEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ActionsEnterprisePermissions> : ($call is Operation\EnterpriseAdmin\SetGithubActionsPermissionsEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\EnterpriseAdmin\ListSelectedOrganizationsEnabledGithubActionsEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\EnterpriseAdmin\ListSelectedOrganizationsEnabledGithubActionsEnterprise\Response\Applicationjson\H200> : ($call is Operation\EnterpriseAdmin\SetSelectedOrganizationsEnabledGithubActionsEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\EnterpriseAdmin\EnableSelectedOrganizationGithubActionsEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\EnterpriseAdmin\DisableSelectedOrganizationGithubActionsEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\EnterpriseAdmin\GetAllowedActionsEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\SelectedActions> : ($call is Operation\EnterpriseAdmin\SetAllowedActionsEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\GetGithubActionsDefaultWorkflowPermissionsEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ActionsGetDefaultWorkflowPermissions> : ($call is Operation\Actions\SetGithubActionsDefaultWorkflowPermissionsEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\EnterpriseAdmin\ListSelfHostedRunnerGroupsForEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\EnterpriseAdmin\ListSelfHostedRunnerGroupsForEnterprise\Response\Applicationjson\H200> : ($call is Operation\EnterpriseAdmin\CreateSelfHostedRunnerGroupForEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\RunnerGroupsEnterprise> : ($call is Operation\EnterpriseAdmin\GetSelfHostedRunnerGroupForEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\RunnerGroupsEnterprise> : ($call is Operation\EnterpriseAdmin\DeleteSelfHostedRunnerGroupFromEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\EnterpriseAdmin\UpdateSelfHostedRunnerGroupForEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\RunnerGroupsEnterprise> : ($call is Operation\EnterpriseAdmin\ListOrgAccessToSelfHostedRunnerGroupInEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\EnterpriseAdmin\ListSelectedOrganizationsEnabledGithubActionsEnterprise\Response\Applicationjson\H200> : ($call is Operation\EnterpriseAdmin\SetOrgAccessToSelfHostedRunnerGroupInEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\EnterpriseAdmin\AddOrgAccessToSelfHostedRunnerGroupInEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\EnterpriseAdmin\RemoveOrgAccessToSelfHostedRunnerGroupInEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\EnterpriseAdmin\ListSelfHostedRunnersInGroupForEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\EnterpriseAdmin\ListSelfHostedRunnersInGroupForEnterprise\Response\Applicationjson\H200> : ($call is Operation\EnterpriseAdmin\SetSelfHostedRunnersInGroupForEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\EnterpriseAdmin\AddSelfHostedRunnerToGroupForEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\EnterpriseAdmin\RemoveSelfHostedRunnerFromGroupForEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\EnterpriseAdmin\ListSelfHostedRunnersForEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\EnterpriseAdmin\ListSelfHostedRunnersForEnterprise\Response\Applicationjson\H200> : ($call is Operation\EnterpriseAdmin\ListRunnerApplicationsForEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\RunnerApplication> : ($call is Operation\EnterpriseAdmin\CreateRegistrationTokenForEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\AuthenticationToken> : ($call is Operation\EnterpriseAdmin\CreateRemoveTokenForEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\AuthenticationToken> : ($call is Operation\EnterpriseAdmin\GetSelfHostedRunnerForEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Runner> : ($call is Operation\EnterpriseAdmin\DeleteSelfHostedRunnerFromEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError> : ($call is Operation\EnterpriseAdmin\SetCustomLabelsForSelfHostedRunnerForEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationErrorSimple> : ($call is Operation\EnterpriseAdmin\AddCustomLabelsToSelfHostedRunnerForEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationErrorSimple> : ($call is Operation\EnterpriseAdmin\RemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationErrorSimple> : ($call is Operation\EnterpriseAdmin\RemoveCustomLabelFromSelfHostedRunnerForEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationErrorSimple> : ($call is Operation\EnterpriseAdmin\GetAuditLog::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\AuditLogEvent> : ($call is Operation\SecretScanning\ListAlertsForEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\OrganizationSecretScanningAlert|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503> : ($call is Operation\Billing\GetGithubAdvancedSecurityBillingGhe::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\AdvancedSecurityActiveCommitters|Schema\BasicError> : ($call is Operation\Activity\ListPublicEvents::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Event|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503> : ($call is Operation\Activity\GetFeeds::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Feed> : ($call is Operation\Gists\List_::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BaseGist|Schema\BasicError> : ($call is Operation\Gists\Create::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\GistSimple|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Gists\ListPublic::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BaseGist|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Gists\ListStarred::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BaseGist|Schema\BasicError> : ($call is Operation\Gists\Get::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\GistSimple|Schema\Operation\Gists\Get\Response\Applicationjson\H403|Schema\BasicError> : ($call is Operation\Gists\Delete::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Gists\Update::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\GistSimple|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Gists\ListComments::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\GistComment|Schema\BasicError> : ($call is Operation\Gists\CreateComment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\GistComment|Schema\BasicError> : ($call is Operation\Gists\GetComment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\GistComment|Schema\BasicError|Schema\Operation\Gists\Get\Response\Applicationjson\H403> : ($call is Operation\Gists\DeleteComment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Gists\UpdateComment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\GistComment|Schema\BasicError> : ($call is Operation\Gists\ListCommits::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\GistCommit|Schema\BasicError> : ($call is Operation\Gists\ListForks::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\GistSimple|Schema\BasicError> : ($call is Operation\Gists\Fork::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BaseGist|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Gists\CheckIsStarred::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Gists\CheckIsStarred\Response\Applicationjson\H404|Schema\BasicError> : ($call is Operation\Gists\Star::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Gists\Unstar::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Gists\GetRevision::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\GistSimple|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Gitignore\GetAllTemplates::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Gitignore\GetAllTemplates\Response\Applicationjson\H200> : ($call is Operation\Gitignore\GetTemplate::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\GitignoreTemplate> : ($call is Operation\Apps\ListReposAccessibleToInstallation::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Apps\ListReposAccessibleToInstallation\Response\Applicationjson\H200|Schema\BasicError> : ($call is Operation\Apps\RevokeInstallationAccessToken::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Issues\List_::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Issue|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Licenses\GetAllCommonlyUsed::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\LicenseSimple> : ($call is Operation\Licenses\Get::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\License|Schema\BasicError> : ($call is Operation\Markdown\Render::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Gitignore\GetAllTemplates\Response\Applicationjson\H200> : ($call is Operation\Markdown\RenderRaw::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Gitignore\GetAllTemplates\Response\Applicationjson\H200> : ($call is Operation\Meta\Get::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ApiOverview> : ($call is Operation\Activity\ListPublicEventsForRepoNetwork::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Event|Schema\BasicError> : ($call is Operation\Activity\ListNotificationsForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Thread|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Activity\MarkNotificationsAsRead::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Activity\MarkNotificationsAsRead\Response\Applicationjson\H202|Schema\BasicError> : ($call is Operation\Activity\GetThread::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Thread|Schema\BasicError> : ($call is Operation\Activity\MarkThreadAsRead::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Activity\GetThreadSubscriptionForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ThreadSubscription|Schema\BasicError> : ($call is Operation\Activity\SetThreadSubscription::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ThreadSubscription|Schema\BasicError> : ($call is Operation\Activity\DeleteThreadSubscription::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Meta\GetOctocat::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Gitignore\GetAllTemplates\Response\Applicationjson\H200> : ($call is Operation\Orgs\List_::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\OrganizationSimple> : ($call is Operation\Orgs\ListCustomRoles::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Orgs\ListCustomRoles\Response\Applicationjson\H200> : ($call is Operation\Orgs\Get::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\OrganizationFull|Schema\BasicError> : ($call is Operation\Orgs\Update::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\OrganizationFull|Schema\Operation\Orgs\Update\Response\Applicationjson\H422|Schema\BasicError> : ($call is Operation\Actions\GetActionsCacheUsageForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ActionsCacheUsageOrgEnterprise> : ($call is Operation\Actions\GetActionsCacheUsageByRepoForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Actions\GetActionsCacheUsageByRepoForOrg\Response\Applicationjson\H200> : ($call is Operation\Actions\GetGithubActionsPermissionsOrganization::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ActionsOrganizationPermissions> : ($call is Operation\Actions\SetGithubActionsPermissionsOrganization::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\ListSelectedRepositoriesEnabledGithubActionsOrganization::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Actions\ListSelectedRepositoriesEnabledGithubActionsOrganization\Response\Applicationjson\H200> : ($call is Operation\Actions\SetSelectedRepositoriesEnabledGithubActionsOrganization::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\EnableSelectedRepositoryGithubActionsOrganization::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\DisableSelectedRepositoryGithubActionsOrganization::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\GetAllowedActionsOrganization::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\SelectedActions> : ($call is Operation\Actions\SetAllowedActionsOrganization::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\GetGithubActionsDefaultWorkflowPermissionsOrganization::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ActionsGetDefaultWorkflowPermissions> : ($call is Operation\Actions\SetGithubActionsDefaultWorkflowPermissionsOrganization::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\ListSelfHostedRunnerGroupsForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Actions\ListSelfHostedRunnerGroupsForOrg\Response\Applicationjson\H200> : ($call is Operation\Actions\CreateSelfHostedRunnerGroupForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\RunnerGroupsOrg> : ($call is Operation\Actions\GetSelfHostedRunnerGroupForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\RunnerGroupsOrg> : ($call is Operation\Actions\DeleteSelfHostedRunnerGroupFromOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\UpdateSelfHostedRunnerGroupForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\RunnerGroupsOrg> : ($call is Operation\Actions\ListRepoAccessToSelfHostedRunnerGroupInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Actions\ListRepoAccessToSelfHostedRunnerGroupInOrg\Response\Applicationjson\H200> : ($call is Operation\Actions\SetRepoAccessToSelfHostedRunnerGroupInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\AddRepoAccessToSelfHostedRunnerGroupInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\RemoveRepoAccessToSelfHostedRunnerGroupInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\ListSelfHostedRunnersInGroupForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\EnterpriseAdmin\ListSelfHostedRunnersInGroupForEnterprise\Response\Applicationjson\H200> : ($call is Operation\Actions\SetSelfHostedRunnersInGroupForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\AddSelfHostedRunnerToGroupForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\RemoveSelfHostedRunnerFromGroupForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\ListSelfHostedRunnersForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Actions\ListSelfHostedRunnersForOrg\Response\Applicationjson\H200> : ($call is Operation\Actions\ListRunnerApplicationsForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\RunnerApplication> : ($call is Operation\Actions\CreateRegistrationTokenForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\AuthenticationToken> : ($call is Operation\Actions\CreateRemoveTokenForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\AuthenticationToken> : ($call is Operation\Actions\GetSelfHostedRunnerForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Runner> : ($call is Operation\Actions\DeleteSelfHostedRunnerFromOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\ListLabelsForSelfHostedRunnerForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError> : ($call is Operation\Actions\SetCustomLabelsForSelfHostedRunnerForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationErrorSimple> : ($call is Operation\Actions\AddCustomLabelsToSelfHostedRunnerForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationErrorSimple> : ($call is Operation\Actions\RemoveAllCustomLabelsFromSelfHostedRunnerForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError> : ($call is Operation\Actions\RemoveCustomLabelFromSelfHostedRunnerForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationErrorSimple> : ($call is Operation\Actions\ListOrgSecrets::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Actions\ListOrgSecrets\Response\Applicationjson\H200> : ($call is Operation\Actions\GetOrgPublicKey::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ActionsPublicKey> : ($call is Operation\Actions\GetOrgSecret::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\OrganizationActionsSecret> : ($call is Operation\Actions\CreateOrUpdateOrgSecret::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\EmptyObject> : ($call is Operation\Actions\DeleteOrgSecret::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\ListSelectedReposForOrgSecret::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Actions\ListSelectedReposForOrgSecret\Response\Applicationjson\H200> : ($call is Operation\Actions\SetSelectedReposForOrgSecret::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\AddSelectedRepoToOrgSecret::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\RemoveSelectedRepoFromOrgSecret::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Orgs\GetAuditLog::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\AuditLogEvent> : ($call is Operation\CodeScanning\ListAlertsForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\CodeScanningOrganizationAlertItems|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503> : ($call is Operation\Dependabot\ListOrgSecrets::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Dependabot\ListOrgSecrets\Response\Applicationjson\H200> : ($call is Operation\Dependabot\GetOrgPublicKey::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\DependabotPublicKey> : ($call is Operation\Dependabot\GetOrgSecret::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\OrganizationDependabotSecret> : ($call is Operation\Dependabot\CreateOrUpdateOrgSecret::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\EmptyObject> : ($call is Operation\Dependabot\DeleteOrgSecret::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Dependabot\ListSelectedReposForOrgSecret::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Actions\ListSelectedReposForOrgSecret\Response\Applicationjson\H200> : ($call is Operation\Dependabot\SetSelectedReposForOrgSecret::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Dependabot\AddSelectedRepoToOrgSecret::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Dependabot\RemoveSelectedRepoFromOrgSecret::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Activity\ListPublicOrgEvents::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Event> : ($call is Operation\Teams\ExternalIdpGroupInfoForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ExternalGroup> : ($call is Operation\Teams\ListExternalIdpGroupsForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ExternalGroups> : ($call is Operation\Orgs\ListWebhooks::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\OrgHook|Schema\BasicError> : ($call is Operation\Orgs\CreateWebhook::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\OrgHook|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Orgs\GetWebhook::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\OrgHook|Schema\BasicError> : ($call is Operation\Orgs\DeleteWebhook::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Orgs\UpdateWebhook::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\OrgHook|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Orgs\GetWebhookConfigForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\WebhookConfig> : ($call is Operation\Orgs\UpdateWebhookConfigForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\WebhookConfig> : ($call is Operation\Orgs\ListWebhookDeliveries::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\HookDeliveryItem|Schema\BasicError|Schema\ScimError|Schema\ValidationError> : ($call is Operation\Orgs\GetWebhookDelivery::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\HookDelivery|Schema\BasicError|Schema\ScimError|Schema\ValidationError> : ($call is Operation\Orgs\RedeliverWebhookDelivery::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\AuditLogEvent\Config|Schema\BasicError|Schema\ScimError|Schema\ValidationError> : ($call is Operation\Orgs\PingWebhook::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Apps\GetOrgInstallation::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Installation> : ($call is Operation\Orgs\ListAppInstallations::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Orgs\ListAppInstallations\Response\Applicationjson\H200> : ($call is Operation\Issues\ListForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Issue|Schema\BasicError> : ($call is Operation\Orgs\ListMembers::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\SimpleUser|Schema\ValidationError> : ($call is Operation\Orgs\CheckMembershipForUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Orgs\RemoveMember::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Orgs\GetMembershipForUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\OrgMembership|Schema\BasicError> : ($call is Operation\Orgs\SetMembershipForUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\OrgMembership|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Orgs\RemoveMembershipForUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Migrations\ListForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Migration> : ($call is Operation\Migrations\StartForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Migration|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Migrations\GetStatusForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Migration|Schema\BasicError> : ($call is Operation\Migrations\DownloadArchiveForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Migrations\DeleteArchiveForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Migrations\UnlockRepoForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Migrations\ListReposForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\MinimalRepository|Schema\BasicError> : ($call is Operation\Orgs\ListOutsideCollaborators::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\SimpleUser> : ($call is Operation\Orgs\ConvertMemberToOutsideCollaborator::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Gists\CheckIsStarred\Response\Applicationjson\H404|Schema\BasicError> : ($call is Operation\Orgs\RemoveOutsideCollaborator::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Orgs\RemoveOutsideCollaborator\Response\Applicationjson\H422> : ($call is Operation\EnterpriseAdmin\ListPreReceiveHooksForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\OrgPreReceiveHook> : ($call is Operation\EnterpriseAdmin\GetPreReceiveHookForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\OrgPreReceiveHook> : ($call is Operation\EnterpriseAdmin\RemovePreReceiveHookEnforcementForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\OrgPreReceiveHook> : ($call is Operation\EnterpriseAdmin\UpdatePreReceiveHookEnforcementForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\OrgPreReceiveHook> : ($call is Operation\Projects\ListForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Project|Schema\ValidationErrorSimple> : ($call is Operation\Projects\CreateForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Project|Schema\BasicError|Schema\ValidationErrorSimple> : ($call is Operation\Orgs\ListPublicMembers::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\SimpleUser> : ($call is Operation\Orgs\CheckPublicMembershipForUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Orgs\SetPublicMembershipForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Orgs\RemovePublicMembershipForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Repos\ListForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\MinimalRepository> : ($call is Operation\Repos\CreateInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Repository|Schema\BasicError|Schema\ValidationError> : ($call is Operation\SecretScanning\ListAlertsForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\OrganizationSecretScanningAlert|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503> : ($call is Operation\Billing\GetGithubAdvancedSecurityBillingOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\AdvancedSecurityActiveCommitters|Schema\BasicError> : ($call is Operation\Teams\List_::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Team|Schema\BasicError> : ($call is Operation\Teams\Create::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamFull|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Teams\GetByName::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamFull|Schema\BasicError> : ($call is Operation\Teams\DeleteInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Teams\UpdateInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamFull|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Teams\ListDiscussionsInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamDiscussion> : ($call is Operation\Teams\CreateDiscussionInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamDiscussion> : ($call is Operation\Teams\GetDiscussionInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamDiscussion> : ($call is Operation\Teams\DeleteDiscussionInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Teams\UpdateDiscussionInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamDiscussion> : ($call is Operation\Teams\ListDiscussionCommentsInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamDiscussionComment> : ($call is Operation\Teams\CreateDiscussionCommentInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamDiscussionComment> : ($call is Operation\Teams\GetDiscussionCommentInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamDiscussionComment> : ($call is Operation\Teams\DeleteDiscussionCommentInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Teams\UpdateDiscussionCommentInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamDiscussionComment> : ($call is Operation\Reactions\ListForTeamDiscussionCommentInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Reaction> : ($call is Operation\Reactions\CreateForTeamDiscussionCommentInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Reaction> : ($call is Operation\Reactions\DeleteForTeamDiscussionComment::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Reactions\ListForTeamDiscussionInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Reaction> : ($call is Operation\Reactions\CreateForTeamDiscussionInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Reaction> : ($call is Operation\Reactions\DeleteForTeamDiscussion::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Teams\ListLinkedExternalIdpGroupsToTeamForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ExternalGroups> : ($call is Operation\Teams\UnlinkExternalIdpGroupFromTeamForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Teams\LinkExternalIdpGroupToTeamForOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ExternalGroup> : ($call is Operation\Teams\ListMembersInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\SimpleUser> : ($call is Operation\Teams\GetMembershipForUserInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamMembership> : ($call is Operation\Teams\AddOrUpdateMembershipForUserInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamMembership> : ($call is Operation\Teams\RemoveMembershipForUserInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Teams\ListProjectsInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamProject> : ($call is Operation\Teams\CheckPermissionsForProjectInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamProject> : ($call is Operation\Teams\AddOrUpdateProjectPermissionsInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Orgs\RemoveOutsideCollaborator\Response\Applicationjson\H422> : ($call is Operation\Teams\RemoveProjectInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Teams\ListReposInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\MinimalRepository> : ($call is Operation\Teams\CheckPermissionsForRepoInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamRepository> : ($call is Operation\Teams\AddOrUpdateRepoPermissionsInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Teams\RemoveRepoInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Teams\ListChildInOrg::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Team> : ($call is Operation\Projects\GetCard::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ProjectCard|Schema\BasicError> : ($call is Operation\Projects\DeleteCard::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Projects\DeleteCard\Response\Applicationjson\H403|Schema\BasicError> : ($call is Operation\Projects\UpdateCard::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ProjectCard|Schema\BasicError|Schema\ValidationErrorSimple> : ($call is Operation\Projects\MoveCard::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Gists\CheckIsStarred\Response\Applicationjson\H404|Schema\Operation\Projects\MoveCard\Response\Applicationjson\H403|Schema\BasicError|Schema\Operation\Projects\MoveCard\Response\Applicationjson\H503|Schema\ValidationError> : ($call is Operation\Projects\GetColumn::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ProjectColumn|Schema\BasicError> : ($call is Operation\Projects\DeleteColumn::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Projects\UpdateColumn::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ProjectColumn|Schema\BasicError> : ($call is Operation\Projects\ListCards::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ProjectCard|Schema\BasicError> : ($call is Operation\Projects\CreateCard::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ProjectCard|Schema\BasicError|Schema\Operation\Orgs\Update\Response\Applicationjson\H422|Schema\Operation\Projects\MoveCard\Response\Applicationjson\H503> : ($call is Operation\Projects\MoveColumn::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Gists\CheckIsStarred\Response\Applicationjson\H404|Schema\BasicError|Schema\ValidationErrorSimple> : ($call is Operation\Projects\Get::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Project|Schema\BasicError> : ($call is Operation\Projects\Delete::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Projects\DeleteCard\Response\Applicationjson\H403|Schema\BasicError> : ($call is Operation\Projects\Update::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Project|Schema\Operation\Projects\DeleteCard\Response\Applicationjson\H403|Schema\BasicError|Schema\ValidationErrorSimple> : ($call is Operation\Projects\ListCollaborators::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\SimpleUser|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Projects\AddCollaborator::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError|Schema\ValidationError> : ($call is Operation\Projects\RemoveCollaborator::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError|Schema\ValidationError> : ($call is Operation\Projects\GetPermissionForUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ProjectCollaboratorPermission|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Projects\ListColumns::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ProjectColumn|Schema\BasicError> : ($call is Operation\Projects\CreateColumn::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ProjectColumn|Schema\BasicError|Schema\ValidationErrorSimple> : ($call is Operation\RateLimit\Get::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\RateLimitOverview|Schema\BasicError> : ($call is Operation\Repos\Get::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\FullRepository|Schema\BasicError> : ($call is Operation\Repos\Delete::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Orgs\RemoveOutsideCollaborator\Response\Applicationjson\H422|Schema\BasicError> : ($call is Operation\Repos\Update::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\FullRepository|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Actions\ListArtifactsForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Actions\ListArtifactsForRepo\Response\Applicationjson\H200> : ($call is Operation\Actions\GetArtifact::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Artifact> : ($call is Operation\Actions\DeleteArtifact::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\DownloadArtifact::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Actions\GetActionsCacheUsage::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ActionsCacheUsageByRepository> : ($call is Operation\Actions\GetActionsCacheUsagePolicy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ActionsCacheUsagePolicyForRepository> : ($call is Operation\Actions\SetActionsCacheUsagePolicy::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\GetJobForWorkflowRun::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Job> : ($call is Operation\Actions\DownloadJobLogsForWorkflowRun::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\ReRunJobForWorkflowRun::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\EmptyObject|Schema\BasicError> : ($call is Operation\Actions\GetGithubActionsPermissionsRepository::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ActionsRepositoryPermissions> : ($call is Operation\Actions\SetGithubActionsPermissionsRepository::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\GetWorkflowAccessToRepository::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ActionsWorkflowAccessToRepository> : ($call is Operation\Actions\SetWorkflowAccessToRepository::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\GetAllowedActionsRepository::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\SelectedActions> : ($call is Operation\Actions\SetAllowedActionsRepository::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\GetGithubActionsDefaultWorkflowPermissionsRepository::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ActionsGetDefaultWorkflowPermissions> : ($call is Operation\Actions\SetGithubActionsDefaultWorkflowPermissionsRepository::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\ListSelfHostedRunnersForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Actions\ListSelfHostedRunnersForOrg\Response\Applicationjson\H200> : ($call is Operation\Actions\ListRunnerApplicationsForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\RunnerApplication> : ($call is Operation\Actions\CreateRegistrationTokenForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\AuthenticationToken> : ($call is Operation\Actions\CreateRemoveTokenForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\AuthenticationToken> : ($call is Operation\Actions\GetSelfHostedRunnerForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Runner> : ($call is Operation\Actions\DeleteSelfHostedRunnerFromRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\ListLabelsForSelfHostedRunnerForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError> : ($call is Operation\Actions\SetCustomLabelsForSelfHostedRunnerForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationErrorSimple> : ($call is Operation\Actions\AddCustomLabelsToSelfHostedRunnerForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationErrorSimple> : ($call is Operation\Actions\RemoveAllCustomLabelsFromSelfHostedRunnerForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError> : ($call is Operation\Actions\RemoveCustomLabelFromSelfHostedRunnerForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationErrorSimple> : ($call is Operation\Actions\ListWorkflowRunsForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Actions\ListWorkflowRunsForRepo\Response\Applicationjson\H200> : ($call is Operation\Actions\GetWorkflowRun::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\WorkflowRun> : ($call is Operation\Actions\DeleteWorkflowRun::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\GetReviewsForRun::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\EnvironmentApprovals> : ($call is Operation\Actions\ListWorkflowRunArtifacts::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Actions\ListArtifactsForRepo\Response\Applicationjson\H200> : ($call is Operation\Actions\GetWorkflowRunAttempt::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\WorkflowRun> : ($call is Operation\Actions\ListJobsForWorkflowRunAttempt::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Actions\ListJobsForWorkflowRunAttempt\Response\Applicationjson\H200|Schema\BasicError> : ($call is Operation\Actions\DownloadWorkflowRunAttemptLogs::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\CancelWorkflowRun::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\EmptyObject|Schema\BasicError> : ($call is Operation\Actions\ListJobsForWorkflowRun::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Actions\ListJobsForWorkflowRunAttempt\Response\Applicationjson\H200> : ($call is Operation\Actions\DownloadWorkflowRunLogs::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\DeleteWorkflowRunLogs::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Actions\GetPendingDeploymentsForRun::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PendingDeployment> : ($call is Operation\Actions\ReviewPendingDeploymentsForRun::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Deployment> : ($call is Operation\Actions\ReRunWorkflow::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\EmptyObject> : ($call is Operation\Actions\ReRunWorkflowFailedJobs::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\EmptyObject> : ($call is Operation\Actions\ListRepoSecrets::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Actions\ListRepoSecrets\Response\Applicationjson\H200> : ($call is Operation\Actions\GetRepoPublicKey::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ActionsPublicKey> : ($call is Operation\Actions\GetRepoSecret::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ActionsSecret> : ($call is Operation\Actions\CreateOrUpdateRepoSecret::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\EmptyObject> : ($call is Operation\Actions\DeleteRepoSecret::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\ListRepoWorkflows::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Actions\ListRepoWorkflows\Response\Applicationjson\H200> : ($call is Operation\Actions\GetWorkflow::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Workflow> : ($call is Operation\Actions\DisableWorkflow::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\CreateWorkflowDispatch::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\EnableWorkflow::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Actions\ListWorkflowRuns::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Actions\ListWorkflowRunsForRepo\Response\Applicationjson\H200> : ($call is Operation\Issues\ListAssignees::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\SimpleUser|Schema\BasicError> : ($call is Operation\Issues\CheckUserCanBeAssigned::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Repos\ListAutolinks::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Autolink> : ($call is Operation\Repos\CreateAutolink::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Autolink|Schema\ValidationError> : ($call is Operation\Repos\GetAutolink::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Autolink|Schema\BasicError> : ($call is Operation\Repos\DeleteAutolink::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Repos\ListBranches::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ShortBranch|Schema\BasicError> : ($call is Operation\Repos\GetBranch::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BranchWithProtection|Schema\BasicError> : ($call is Operation\Repos\GetBranchProtection::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BranchProtection|Schema\BasicError> : ($call is Operation\Repos\UpdateBranchProtection::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ProtectedBranch|Schema\BasicError|Schema\ValidationErrorSimple> : ($call is Operation\Repos\DeleteBranchProtection::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Repos\GetAdminBranchProtection::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ProtectedBranchAdminEnforced> : ($call is Operation\Repos\SetAdminBranchProtection::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ProtectedBranchAdminEnforced> : ($call is Operation\Repos\DeleteAdminBranchProtection::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Repos\GetPullRequestReviewProtection::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ProtectedBranchPullRequestReview> : ($call is Operation\Repos\DeletePullRequestReviewProtection::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Repos\UpdatePullRequestReviewProtection::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ProtectedBranchPullRequestReview|Schema\ValidationError> : ($call is Operation\Repos\GetCommitSignatureProtection::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ProtectedBranchAdminEnforced|Schema\BasicError> : ($call is Operation\Repos\CreateCommitSignatureProtection::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ProtectedBranchAdminEnforced|Schema\BasicError> : ($call is Operation\Repos\DeleteCommitSignatureProtection::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Repos\GetStatusChecksProtection::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\StatusCheckPolicy|Schema\BasicError> : ($call is Operation\Repos\RemoveStatusCheckProtection::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Repos\UpdateStatusCheckProtection::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\StatusCheckPolicy|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Repos\GetAllStatusCheckContexts::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Gitignore\GetAllTemplates\Response\Applicationjson\H200|Schema\BasicError> : ($call is Operation\Repos\SetStatusCheckContexts::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Gitignore\GetAllTemplates\Response\Applicationjson\H200|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Repos\AddStatusCheckContexts::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Gitignore\GetAllTemplates\Response\Applicationjson\H200|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Repos\RemoveStatusCheckContexts::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Gitignore\GetAllTemplates\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Repos\GetAccessRestrictions::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BranchRestrictionPolicy|Schema\BasicError> : ($call is Operation\Repos\DeleteAccessRestrictions::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Repos\GetAppsWithAccessToProtectedBranch::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Integration|Schema\BasicError> : ($call is Operation\Repos\SetAppAccessRestrictions::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Integration|Schema\ValidationError> : ($call is Operation\Repos\AddAppAccessRestrictions::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Integration|Schema\ValidationError> : ($call is Operation\Repos\RemoveAppAccessRestrictions::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Integration|Schema\ValidationError> : ($call is Operation\Repos\GetTeamsWithAccessToProtectedBranch::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Team|Schema\BasicError> : ($call is Operation\Repos\SetTeamAccessRestrictions::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Team|Schema\ValidationError> : ($call is Operation\Repos\AddTeamAccessRestrictions::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Team|Schema\ValidationError> : ($call is Operation\Repos\RemoveTeamAccessRestrictions::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Team|Schema\ValidationError> : ($call is Operation\Repos\GetUsersWithAccessToProtectedBranch::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\SimpleUser|Schema\BasicError> : ($call is Operation\Repos\SetUserAccessRestrictions::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\SimpleUser|Schema\ValidationError> : ($call is Operation\Repos\AddUserAccessRestrictions::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\SimpleUser|Schema\ValidationError> : ($call is Operation\Repos\RemoveUserAccessRestrictions::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\SimpleUser|Schema\ValidationError> : ($call is Operation\Repos\RenameBranch::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BranchWithProtection|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Checks\Create::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\CheckRun> : ($call is Operation\Checks\Get::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\CheckRun> : ($call is Operation\Checks\Update::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\CheckRun> : ($call is Operation\Checks\ListAnnotations::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\CheckAnnotation> : ($call is Operation\Checks\RerequestRun::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\EmptyObject|Schema\BasicError> : ($call is Operation\Checks\CreateSuite::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\CheckSuite> : ($call is Operation\Checks\SetSuitesPreferences::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\CheckSuitePreference> : ($call is Operation\Checks\GetSuite::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\CheckSuite> : ($call is Operation\Checks\ListForSuite::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Checks\ListForSuite\Response\Applicationjson\H200> : ($call is Operation\Checks\RerequestSuite::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\EmptyObject> : ($call is Operation\CodeScanning\ListAlertsForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\CodeScanningAlertItems|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503> : ($call is Operation\CodeScanning\GetAlert::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\CodeScanningAlert|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503> : ($call is Operation\CodeScanning\UpdateAlert::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\CodeScanningAlert|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503> : ($call is Operation\CodeScanning\ListAlertInstances::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\CodeScanningAlertInstance|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503> : ($call is Operation\CodeScanning\ListRecentAnalyses::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\CodeScanningAnalysis|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503> : ($call is Operation\CodeScanning\GetAnalysis::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\CodeScanningAnalysis|Schema\AuditLogEvent\Data|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503> : ($call is Operation\CodeScanning\DeleteAnalysis::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\CodeScanningAnalysisDeletion|Schema\BasicError|Schema\ScimError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503> : ($call is Operation\CodeScanning\UploadSarif::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\CodeScanningSarifsReceipt|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503> : ($call is Operation\CodeScanning\GetSarif::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\CodeScanningSarifsStatus|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503> : ($call is Operation\Repos\CodeownersErrors::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\CodeownersErrors> : ($call is Operation\Repos\ListCollaborators::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Collaborator|Schema\BasicError> : ($call is Operation\Repos\CheckCollaborator::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Repos\AddCollaborator::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\RepositoryInvitation|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Repos\RemoveCollaborator::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Repos\GetCollaboratorPermissionLevel::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\RepositoryCollaboratorPermission|Schema\BasicError> : ($call is Operation\Repos\ListCommitCommentsForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\CommitComment> : ($call is Operation\Repos\GetCommitComment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\CommitComment|Schema\BasicError> : ($call is Operation\Repos\DeleteCommitComment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Repos\UpdateCommitComment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\CommitComment|Schema\BasicError> : ($call is Operation\Reactions\ListForCommitComment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Reaction|Schema\BasicError> : ($call is Operation\Reactions\CreateForCommitComment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Reaction|Schema\ValidationError> : ($call is Operation\Reactions\DeleteForCommitComment::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Repos\ListCommits::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Commit|Schema\BasicError|Schema\ScimError> : ($call is Operation\Repos\ListBranchesForHeadCommit::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BranchShort|Schema\ValidationError> : ($call is Operation\Repos\ListCommentsForCommit::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\CommitComment> : ($call is Operation\Repos\CreateCommitComment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\CommitComment|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Repos\ListPullRequestsAssociatedWithCommit::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PullRequestSimple> : ($call is Operation\Repos\GetCommit::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Commit|Schema\ValidationError|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503> : ($call is Operation\Checks\ListForRef::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Checks\ListForSuite\Response\Applicationjson\H200> : ($call is Operation\Checks\ListSuitesForRef::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Checks\ListSuitesForRef\Response\Applicationjson\H200> : ($call is Operation\Repos\GetCombinedStatusForRef::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\CombinedCommitStatus|Schema\BasicError> : ($call is Operation\Repos\ListCommitStatusesForRef::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Status|Schema\BasicError> : ($call is Operation\Repos\CompareCommits::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\CommitComparison|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503> : ($call is Operation\Repos\GetContent::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ContentTree|Schema\Operation\Repos\GetContent\Response\Applicationjson\H200|Schema\BasicError> : ($call is Operation\Repos\CreateOrUpdateFileContents::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\FileCommit|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Repos\DeleteFile::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\FileCommit|Schema\ValidationError|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503> : ($call is Operation\Repos\ListContributors::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Contributor|Schema\BasicError> : ($call is Operation\Dependabot\ListRepoSecrets::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Dependabot\ListRepoSecrets\Response\Applicationjson\H200> : ($call is Operation\Dependabot\GetRepoPublicKey::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\DependabotPublicKey> : ($call is Operation\Dependabot\GetRepoSecret::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\DependabotSecret> : ($call is Operation\Dependabot\CreateOrUpdateRepoSecret::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\EmptyObject> : ($call is Operation\Dependabot\DeleteRepoSecret::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\DependencyGraph\DiffRange::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\DependencyGraphDiff|Schema\BasicError> : ($call is Operation\Repos\ListDeployments::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Deployment> : ($call is Operation\Repos\CreateDeployment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Deployment|Schema\Operation\Activity\MarkNotificationsAsRead\Response\Applicationjson\H202|Schema\ValidationError> : ($call is Operation\Repos\GetDeployment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Deployment|Schema\BasicError> : ($call is Operation\Repos\DeleteDeployment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError|Schema\ValidationErrorSimple> : ($call is Operation\Repos\ListDeploymentStatuses::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\DeploymentStatus|Schema\BasicError> : ($call is Operation\Repos\CreateDeploymentStatus::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\DeploymentStatus|Schema\ValidationError> : ($call is Operation\Repos\GetDeploymentStatus::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\DeploymentStatus|Schema\BasicError> : ($call is Operation\Repos\CreateDispatchEvent::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ValidationError> : ($call is Operation\Repos\GetAllEnvironments::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Repos\GetAllEnvironments\Response\Applicationjson\H200> : ($call is Operation\Repos\GetEnvironment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Environment> : ($call is Operation\Repos\CreateOrUpdateEnvironment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Environment|Schema\BasicError> : ($call is Operation\Repos\DeleteAnEnvironment::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Repos\ListDeploymentBranchPolicies::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Repos\ListDeploymentBranchPolicies\Response\Applicationjson\H200> : ($call is Operation\Repos\CreateDeploymentBranchPolicy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\DeploymentBranchPolicy> : ($call is Operation\Repos\GetDeploymentBranchPolicy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\DeploymentBranchPolicy> : ($call is Operation\Repos\UpdateDeploymentBranchPolicy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\DeploymentBranchPolicy> : ($call is Operation\Repos\DeleteDeploymentBranchPolicy::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Activity\ListRepoEvents::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Event> : ($call is Operation\Repos\ListForks::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\MinimalRepository|Schema\BasicError|Schema\ScimError> : ($call is Operation\Repos\CreateFork::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\FullRepository|Schema\BasicError|Schema\ScimError|Schema\ValidationError> : ($call is Operation\Git\CreateBlob::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ShortBlob|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Git\GetBlob::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Blob|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Git\CreateCommit::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\GitCommit|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Git\GetCommit::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\GitCommit|Schema\BasicError> : ($call is Operation\Git\ListMatchingRefs::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\GitRef> : ($call is Operation\Git\GetRef::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\GitRef|Schema\BasicError> : ($call is Operation\Git\CreateRef::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\GitRef|Schema\ValidationError> : ($call is Operation\Git\DeleteRef::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ValidationError> : ($call is Operation\Git\UpdateRef::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\GitRef|Schema\ValidationError> : ($call is Operation\Git\CreateTag::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\GitTag|Schema\ValidationError> : ($call is Operation\Git\GetTag::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\GitTag|Schema\BasicError> : ($call is Operation\Git\CreateTree::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\GitTree|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Git\GetTree::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\GitTree|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Repos\ListWebhooks::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Hook|Schema\BasicError> : ($call is Operation\Repos\CreateWebhook::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Hook|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Repos\GetWebhook::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Hook|Schema\BasicError> : ($call is Operation\Repos\DeleteWebhook::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Repos\UpdateWebhook::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Hook|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Repos\GetWebhookConfigForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\WebhookConfig> : ($call is Operation\Repos\UpdateWebhookConfigForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\WebhookConfig> : ($call is Operation\Repos\ListWebhookDeliveries::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\HookDeliveryItem|Schema\BasicError|Schema\ScimError|Schema\ValidationError> : ($call is Operation\Repos\GetWebhookDelivery::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\HookDelivery|Schema\BasicError|Schema\ScimError|Schema\ValidationError> : ($call is Operation\Repos\RedeliverWebhookDelivery::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\AuditLogEvent\Config|Schema\BasicError|Schema\ScimError|Schema\ValidationError> : ($call is Operation\Repos\PingWebhook::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Repos\TestPushWebhook::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Apps\GetRepoInstallation::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Installation|Schema\BasicError> : ($call is Operation\Repos\ListInvitations::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\RepositoryInvitation> : ($call is Operation\Repos\DeleteInvitation::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Repos\UpdateInvitation::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\RepositoryInvitation> : ($call is Operation\Issues\ListForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Issue|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Issues\Create::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Issue|Schema\BasicError|Schema\ValidationError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503> : ($call is Operation\Issues\ListCommentsForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\IssueComment|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Issues\GetComment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\IssueComment|Schema\BasicError> : ($call is Operation\Issues\DeleteComment::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Issues\UpdateComment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\IssueComment|Schema\ValidationError> : ($call is Operation\Reactions\ListForIssueComment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Reaction|Schema\BasicError> : ($call is Operation\Reactions\CreateForIssueComment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Reaction|Schema\ValidationError> : ($call is Operation\Reactions\DeleteForIssueComment::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Issues\ListEventsForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\IssueEvent|Schema\ValidationError> : ($call is Operation\Issues\GetEvent::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\IssueEvent|Schema\BasicError> : ($call is Operation\Issues\Get::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Issue|Schema\BasicError> : ($call is Operation\Issues\Update::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Issue|Schema\ValidationError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503|Schema\BasicError> : ($call is Operation\Issues\AddAssignees::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Issue> : ($call is Operation\Issues\RemoveAssignees::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Issue> : ($call is Operation\Issues\CheckUserCanBeAssignedToIssue::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Issues\ListComments::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\IssueComment|Schema\BasicError> : ($call is Operation\Issues\CreateComment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\IssueComment|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Issues\ListEvents::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\IssueEventForIssue|Schema\BasicError> : ($call is Operation\Issues\ListLabelsOnIssue::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Label|Schema\BasicError> : ($call is Operation\Issues\SetLabels::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Label|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Issues\AddLabels::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Label|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Issues\RemoveAllLabels::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Issues\RemoveLabel::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Label|Schema\BasicError> : ($call is Operation\Issues\Lock::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError|Schema\ValidationError> : ($call is Operation\Issues\Unlock::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Reactions\ListForIssue::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Reaction|Schema\BasicError> : ($call is Operation\Reactions\CreateForIssue::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Reaction|Schema\ValidationError> : ($call is Operation\Reactions\DeleteForIssue::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Issues\ListEventsForTimeline::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TimelineIssueEvents|Schema\BasicError> : ($call is Operation\Repos\ListDeployKeys::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\DeployKey> : ($call is Operation\Repos\CreateDeployKey::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\DeployKey|Schema\ValidationError> : ($call is Operation\Repos\GetDeployKey::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\DeployKey|Schema\BasicError> : ($call is Operation\Repos\DeleteDeployKey::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Issues\ListLabelsForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Label|Schema\BasicError> : ($call is Operation\Issues\CreateLabel::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Label|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Issues\GetLabel::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Label|Schema\BasicError> : ($call is Operation\Issues\DeleteLabel::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Issues\UpdateLabel::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Label> : ($call is Operation\Repos\ListLanguages::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Language> : ($call is Operation\Repos\EnableLfsForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\AuditLogEvent\Config> : ($call is Operation\Repos\DisableLfsForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Licenses\GetForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\LicenseContent> : ($call is Operation\Repos\MergeUpstream::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\MergedUpstream> : ($call is Operation\Repos\Merge::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Commit|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Issues\ListMilestones::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Milestone|Schema\BasicError> : ($call is Operation\Issues\CreateMilestone::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Milestone|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Issues\GetMilestone::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Milestone|Schema\BasicError> : ($call is Operation\Issues\DeleteMilestone::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Issues\UpdateMilestone::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Milestone> : ($call is Operation\Issues\ListLabelsForMilestone::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Label> : ($call is Operation\Activity\ListRepoNotificationsForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Thread> : ($call is Operation\Activity\MarkRepoNotificationsAsRead::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\EnterpriseAdmin\UpdateOrgName\Response\Applicationjson\H202> : ($call is Operation\Repos\GetPages::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Page|Schema\BasicError> : ($call is Operation\Repos\UpdateInformationAboutPagesSite::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ValidationError|Schema\BasicError|Schema\ScimError> : ($call is Operation\Repos\CreatePagesSite::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Page|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Repos\DeletePagesSite::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ValidationError|Schema\BasicError> : ($call is Operation\Repos\ListPagesBuilds::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PageBuild> : ($call is Operation\Repos\RequestPagesBuild::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PageBuildStatus> : ($call is Operation\Repos\GetLatestPagesBuild::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PageBuild> : ($call is Operation\Repos\GetPagesBuild::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PageBuild> : ($call is Operation\EnterpriseAdmin\ListPreReceiveHooksForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\RepositoryPreReceiveHook> : ($call is Operation\EnterpriseAdmin\GetPreReceiveHookForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\RepositoryPreReceiveHook> : ($call is Operation\EnterpriseAdmin\RemovePreReceiveHookEnforcementForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\RepositoryPreReceiveHook> : ($call is Operation\EnterpriseAdmin\UpdatePreReceiveHookEnforcementForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\RepositoryPreReceiveHook> : ($call is Operation\Projects\ListForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Project|Schema\BasicError|Schema\ValidationErrorSimple> : ($call is Operation\Projects\CreateForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Project|Schema\BasicError|Schema\ValidationErrorSimple> : ($call is Operation\Pulls\List_::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PullRequestSimple|Schema\ValidationError> : ($call is Operation\Pulls\Create::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PullRequest|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Pulls\ListReviewCommentsForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PullRequestReviewComment> : ($call is Operation\Pulls\GetReviewComment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PullRequestReviewComment|Schema\BasicError> : ($call is Operation\Pulls\DeleteReviewComment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Pulls\UpdateReviewComment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PullRequestReviewComment> : ($call is Operation\Reactions\ListForPullRequestReviewComment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Reaction|Schema\BasicError> : ($call is Operation\Reactions\CreateForPullRequestReviewComment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Reaction|Schema\ValidationError> : ($call is Operation\Reactions\DeleteForPullRequestComment::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Pulls\Get::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PullRequest|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503> : ($call is Operation\Pulls\Update::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PullRequest|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Pulls\ListReviewComments::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PullRequestReviewComment> : ($call is Operation\Pulls\CreateReviewComment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PullRequestReviewComment|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Pulls\CreateReplyForReviewComment::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PullRequestReviewComment|Schema\BasicError> : ($call is Operation\Pulls\ListCommits::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Commit> : ($call is Operation\Pulls\ListFiles::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\DiffEntry|Schema\ValidationError|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503> : ($call is Operation\Pulls\CheckIfMerged::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Pulls\Merge::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PullRequestMergeResult|Schema\Operation\Orgs\RemoveOutsideCollaborator\Response\Applicationjson\H422|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Pulls\ListRequestedReviewers::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PullRequestReviewRequest> : ($call is Operation\Pulls\RequestReviewers::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PullRequestSimple|Schema\BasicError> : ($call is Operation\Pulls\RemoveRequestedReviewers::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PullRequestSimple|Schema\ValidationError> : ($call is Operation\Pulls\ListReviews::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PullRequestReview> : ($call is Operation\Pulls\CreateReview::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PullRequestReview|Schema\ValidationErrorSimple|Schema\BasicError> : ($call is Operation\Pulls\GetReview::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PullRequestReview|Schema\BasicError> : ($call is Operation\Pulls\UpdateReview::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PullRequestReview|Schema\ValidationErrorSimple> : ($call is Operation\Pulls\DeletePendingReview::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PullRequestReview|Schema\ValidationErrorSimple|Schema\BasicError> : ($call is Operation\Pulls\ListCommentsForReview::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ReviewComment|Schema\BasicError> : ($call is Operation\Pulls\DismissReview::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PullRequestReview|Schema\BasicError|Schema\ValidationErrorSimple> : ($call is Operation\Pulls\SubmitReview::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PullRequestReview|Schema\BasicError|Schema\ValidationErrorSimple> : ($call is Operation\Pulls\UpdateBranch::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\EnterpriseAdmin\UpdateOrgName\Response\Applicationjson\H202|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Repos\GetReadme::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ContentFile|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Repos\GetReadmeInDirectory::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ContentFile|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Repos\ListReleases::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Release|Schema\BasicError> : ($call is Operation\Repos\CreateRelease::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Release|Schema\ValidationError> : ($call is Operation\Repos\GetReleaseAsset::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ReleaseAsset|Schema\BasicError> : ($call is Operation\Repos\DeleteReleaseAsset::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Repos\UpdateReleaseAsset::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ReleaseAsset> : ($call is Operation\Repos\GenerateReleaseNotes::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ReleaseNotesContent|Schema\BasicError> : ($call is Operation\Repos\GetLatestRelease::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Release> : ($call is Operation\Repos\GetReleaseByTag::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Release|Schema\BasicError> : ($call is Operation\Repos\GetRelease::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Release|Schema\BasicError> : ($call is Operation\Repos\DeleteRelease::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Repos\UpdateRelease::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Release> : ($call is Operation\Repos\ListReleaseAssets::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ReleaseAsset> : ($call is Operation\Repos\UploadReleaseAsset::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ReleaseAsset> : ($call is Operation\Reactions\ListForRelease::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Reaction|Schema\BasicError> : ($call is Operation\Reactions\CreateForRelease::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Reaction|Schema\ValidationError> : ($call is Operation\Reactions\DeleteForRelease::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Repos\ListCacheInfo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Repos\ListCacheInfo\Response\Applicationjson\H200|Schema\BasicError> : ($call is Operation\SecretScanning\ListAlertsForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\SecretScanningAlert|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503> : ($call is Operation\SecretScanning\GetAlert::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\SecretScanningAlert|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503> : ($call is Operation\SecretScanning\UpdateAlert::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\SecretScanningAlert|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503> : ($call is Operation\SecretScanning\ListLocationsForAlert::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\SecretScanningLocation|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503> : ($call is Operation\Activity\ListStargazersForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Activity\ListStargazersForRepo\Response\Applicationjson\H200|Schema\ValidationError> : ($call is Operation\Repos\GetCodeFrequencyStats::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Repos\GetCodeFrequencyStats\Response\Applicationjson\H200|Schema\AuditLogEvent\Config> : ($call is Operation\Repos\GetCommitActivityStats::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\CommitActivity|Schema\AuditLogEvent\Config> : ($call is Operation\Repos\GetContributorsStats::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ContributorActivity|Schema\AuditLogEvent\Config> : ($call is Operation\Repos\GetParticipationStats::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ParticipationStats|Schema\BasicError> : ($call is Operation\Repos\GetPunchCardStats::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Repos\GetCodeFrequencyStats\Response\Applicationjson\H200> : ($call is Operation\Repos\CreateCommitStatus::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Status> : ($call is Operation\Activity\ListWatchersForRepo::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\SimpleUser> : ($call is Operation\Activity\GetRepoSubscription::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\RepositorySubscription|Schema\BasicError> : ($call is Operation\Activity\SetRepoSubscription::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\RepositorySubscription> : ($call is Operation\Activity\DeleteRepoSubscription::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Repos\ListTags::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Tag> : ($call is Operation\Repos\ListTagProtection::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TagProtection|Schema\BasicError> : ($call is Operation\Repos\CreateTagProtection::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TagProtection|Schema\BasicError> : ($call is Operation\Repos\DeleteTagProtection::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Repos\DownloadTarballArchive::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Repos\ListTeams::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Team> : ($call is Operation\Repos\GetAllTopics::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Topic|Schema\BasicError> : ($call is Operation\Repos\ReplaceAllTopics::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Topic|Schema\BasicError|Schema\ValidationErrorSimple> : ($call is Operation\Repos\Transfer::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\MinimalRepository> : ($call is Operation\Repos\DownloadZipballArchive::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Repos\CreateUsingTemplate::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Repository> : ($call is Operation\Repos\ListPublic::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\MinimalRepository|Schema\ValidationError> : ($call is Operation\Actions\ListEnvironmentSecrets::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Actions\ListRepoSecrets\Response\Applicationjson\H200> : ($call is Operation\Actions\GetEnvironmentPublicKey::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ActionsPublicKey> : ($call is Operation\Actions\GetEnvironmentSecret::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ActionsSecret> : ($call is Operation\Actions\CreateOrUpdateEnvironmentSecret::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\EmptyObject> : ($call is Operation\Actions\DeleteEnvironmentSecret::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\EnterpriseAdmin\ListProvisionedGroupsEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ScimEnterpriseGroupList|Schema\ScimError> : ($call is Operation\EnterpriseAdmin\ProvisionEnterpriseGroup::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ScimEnterpriseGroupResponse|Schema\ScimError> : ($call is Operation\EnterpriseAdmin\GetProvisioningInformationForEnterpriseGroup::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ScimEnterpriseGroupResponse|Schema\ScimError|Schema\BasicError> : ($call is Operation\EnterpriseAdmin\SetInformationForProvisionedEnterpriseGroup::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ScimEnterpriseGroupResponse|Schema\ScimError|Schema\BasicError> : ($call is Operation\EnterpriseAdmin\DeleteScimGroupFromEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ScimError|Schema\BasicError> : ($call is Operation\EnterpriseAdmin\UpdateAttributeForEnterpriseGroup::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ScimEnterpriseGroupResponse|Schema\ScimError|Schema\BasicError> : ($call is Operation\EnterpriseAdmin\ListProvisionedIdentitiesEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ScimEnterpriseUserList|Schema\ScimError> : ($call is Operation\EnterpriseAdmin\ProvisionEnterpriseUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ScimEnterpriseUserResponse|Schema\ScimError> : ($call is Operation\EnterpriseAdmin\GetProvisioningInformationForEnterpriseUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ScimEnterpriseUserResponse|Schema\ScimError|Schema\BasicError> : ($call is Operation\EnterpriseAdmin\SetInformationForProvisionedEnterpriseUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ScimEnterpriseUserResponse|Schema\ScimError|Schema\BasicError> : ($call is Operation\EnterpriseAdmin\DeleteUserFromEnterprise::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ScimError|Schema\BasicError> : ($call is Operation\EnterpriseAdmin\UpdateAttributeForEnterpriseUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ScimEnterpriseUserResponse|Schema\ScimError|Schema\BasicError> : ($call is Operation\Search\Code::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Search\Code\Response\Applicationjson\H200|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Search\Commits::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Search\Commits\Response\Applicationjson\H200> : ($call is Operation\Search\IssuesAndPullRequests::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Search\IssuesAndPullRequests\Response\Applicationjson\H200|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Search\Labels::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Search\Labels\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Search\Repos::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Search\Repos\Response\Applicationjson\H200|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503|Schema\ValidationError> : ($call is Operation\Search\Topics::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Search\Topics\Response\Applicationjson\H200> : ($call is Operation\Search\Users::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Search\Users\Response\Applicationjson\H200|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503|Schema\ValidationError> : ($call is Operation\EnterpriseAdmin\GetConfigurationStatus::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\ConfigurationStatus> : ($call is Operation\EnterpriseAdmin\StartConfigurationProcess::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\EnterpriseAdmin\GetMaintenanceStatus::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\MaintenanceStatus> : ($call is Operation\EnterpriseAdmin\EnableOrDisableMaintenanceMode::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\MaintenanceStatus> : ($call is Operation\EnterpriseAdmin\GetSettings::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\EnterpriseSettings> : ($call is Operation\EnterpriseAdmin\SetSettings::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\EnterpriseAdmin\GetAllAuthorizedSshKeys::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\SshKey> : ($call is Operation\EnterpriseAdmin\AddAuthorizedSshKey::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\SshKey> : ($call is Operation\EnterpriseAdmin\RemoveAuthorizedSshKey::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\SshKey> : ($call is Operation\EnterpriseAdmin\CreateEnterpriseServerLicense::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\EnterpriseAdmin\UpgradeLicense::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Teams\GetLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamFull|Schema\BasicError> : ($call is Operation\Teams\DeleteLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError|Schema\ValidationError> : ($call is Operation\Teams\UpdateLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamFull|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Teams\ListDiscussionsLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamDiscussion> : ($call is Operation\Teams\CreateDiscussionLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamDiscussion> : ($call is Operation\Teams\GetDiscussionLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamDiscussion> : ($call is Operation\Teams\DeleteDiscussionLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Teams\UpdateDiscussionLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamDiscussion> : ($call is Operation\Teams\ListDiscussionCommentsLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamDiscussionComment> : ($call is Operation\Teams\CreateDiscussionCommentLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamDiscussionComment> : ($call is Operation\Teams\GetDiscussionCommentLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamDiscussionComment> : ($call is Operation\Teams\DeleteDiscussionCommentLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Teams\UpdateDiscussionCommentLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamDiscussionComment> : ($call is Operation\Reactions\ListForTeamDiscussionCommentLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Reaction> : ($call is Operation\Reactions\CreateForTeamDiscussionCommentLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Reaction> : ($call is Operation\Reactions\ListForTeamDiscussionLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Reaction> : ($call is Operation\Reactions\CreateForTeamDiscussionLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Reaction> : ($call is Operation\Teams\ListMembersLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\SimpleUser|Schema\BasicError> : ($call is Operation\Teams\GetMemberLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Teams\AddMemberLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Teams\RemoveMemberLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Teams\GetMembershipForUserLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamMembership|Schema\BasicError> : ($call is Operation\Teams\AddOrUpdateMembershipForUserLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamMembership|Schema\BasicError> : ($call is Operation\Teams\RemoveMembershipForUserLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Teams\ListProjectsLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamProject|Schema\BasicError> : ($call is Operation\Teams\CheckPermissionsForProjectLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamProject> : ($call is Operation\Teams\AddOrUpdateProjectPermissionsLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Orgs\RemoveOutsideCollaborator\Response\Applicationjson\H422|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Teams\RemoveProjectLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError|Schema\ValidationError> : ($call is Operation\Teams\ListReposLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\MinimalRepository|Schema\BasicError> : ($call is Operation\Teams\CheckPermissionsForRepoLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamRepository> : ($call is Operation\Teams\AddOrUpdateRepoPermissionsLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError|Schema\ValidationError> : ($call is Operation\Teams\RemoveRepoLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Teams\ListChildLegacy::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Team|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Users\GetAuthenticated::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Users\GetAuthenticated\Response\Applicationjson\H200|Schema\BasicError> : ($call is Operation\Users\UpdateAuthenticated::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\PrivateUser|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Users\ListEmailsForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Email|Schema\BasicError> : ($call is Operation\Users\AddEmailForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Email|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Users\DeleteEmailForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError|Schema\ValidationError> : ($call is Operation\Users\ListFollowersForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\SimpleUser|Schema\BasicError> : ($call is Operation\Users\ListFollowedByAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\SimpleUser|Schema\BasicError> : ($call is Operation\Users\CheckPersonIsFollowedByAuthenticated::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Users\Follow::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Users\Unfollow::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Users\ListGpgKeysForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\GpgKey|Schema\BasicError> : ($call is Operation\Users\CreateGpgKeyForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\GpgKey|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Users\GetGpgKeyForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\GpgKey|Schema\BasicError> : ($call is Operation\Users\DeleteGpgKeyForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError|Schema\ValidationError> : ($call is Operation\Apps\ListInstallationsForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Orgs\ListAppInstallations\Response\Applicationjson\H200|Schema\BasicError> : ($call is Operation\Apps\ListInstallationReposForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Apps\ListInstallationReposForAuthenticatedUser\Response\Applicationjson\H200|Schema\BasicError> : ($call is Operation\Apps\AddRepoToInstallationForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Apps\RemoveRepoFromInstallationForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Issues\ListForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Issue|Schema\BasicError> : ($call is Operation\Users\ListPublicSshKeysForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Key|Schema\BasicError> : ($call is Operation\Users\CreatePublicSshKeyForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Key|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Users\GetPublicSshKeyForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Key|Schema\BasicError> : ($call is Operation\Users\DeletePublicSshKeyForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Orgs\ListMembershipsForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\OrgMembership|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Orgs\GetMembershipForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\OrgMembership|Schema\BasicError> : ($call is Operation\Orgs\UpdateMembershipForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\OrgMembership|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Migrations\ListForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Migration|Schema\BasicError> : ($call is Operation\Migrations\StartForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Migration|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Migrations\GetArchiveForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Migrations\ListReposForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\MinimalRepository|Schema\BasicError> : ($call is Operation\Orgs\ListForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\OrganizationSimple|Schema\BasicError> : ($call is Operation\Projects\CreateForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Project|Schema\BasicError|Schema\ValidationErrorSimple> : ($call is Operation\Users\ListPublicEmailsForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Email|Schema\BasicError> : ($call is Operation\Repos\ListForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Repository|Schema\ValidationError|Schema\BasicError> : ($call is Operation\Repos\CreateForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Repository|Schema\BasicError|Schema\ValidationError|Schema\ScimError> : ($call is Operation\Repos\ListInvitationsForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\RepositoryInvitation|Schema\BasicError> : ($call is Operation\Repos\DeclineInvitationForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Repos\AcceptInvitationForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Activity\ListReposStarredByAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Repository|Schema\StarredRepository|Schema\BasicError> : ($call is Operation\Activity\CheckRepoIsStarredByAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Activity\StarRepoForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Activity\UnstarRepoForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BasicError> : ($call is Operation\Activity\ListWatchedReposForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\MinimalRepository|Schema\BasicError> : ($call is Operation\Teams\ListForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\TeamFull|Schema\BasicError> : ($call is Operation\Users\List_::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\SimpleUser> : ($call is Operation\Users\GetByUsername::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Users\GetAuthenticated\Response\Applicationjson\H200|Schema\BasicError> : ($call is Operation\Activity\ListEventsForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Event> : ($call is Operation\Activity\ListOrgEventsForAuthenticatedUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Event> : ($call is Operation\Activity\ListPublicEventsForUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Event> : ($call is Operation\Users\ListFollowersForUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\SimpleUser> : ($call is Operation\Users\ListFollowingForUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\SimpleUser> : ($call is Operation\Users\CheckFollowingForUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Gists\ListForUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\BaseGist|Schema\ValidationError> : ($call is Operation\Users\ListGpgKeysForUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\GpgKey> : ($call is Operation\Users\GetContextForUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Hovercard|Schema\BasicError|Schema\ValidationError> : ($call is Operation\Apps\GetUserInstallation::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Installation> : ($call is Operation\Users\ListPublicKeysForUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\KeySimple> : ($call is Operation\Orgs\ListForUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\OrganizationSimple> : ($call is Operation\Projects\ListForUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Project|Schema\ValidationError> : ($call is Operation\Activity\ListReceivedEventsForUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Event> : ($call is Operation\Activity\ListReceivedPublicEventsForUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Event> : ($call is Operation\Repos\ListForUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\MinimalRepository> : ($call is Operation\EnterpriseAdmin\PromoteUserToBeSiteAdministrator::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\EnterpriseAdmin\DemoteSiteAdministrator::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\Activity\ListReposStarredByUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\Operation\Activity\ListReposStarredByUser\Response\Applicationjson\H200> : ($call is Operation\Activity\ListReposWatchedByUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<Schema\MinimalRepository> : ($call is Operation\EnterpriseAdmin\SuspendUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : ($call is Operation\EnterpriseAdmin\UnsuspendUser::OPERATION_MATCH ? \React\Promise\PromiseInterface<\Psr\Http\Message\ResponseInterface> : \React\Promise\PromiseInterface<Schema\Operation\Gitignore\GetAllTemplates\Response\Applicationjson\H200>)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
     */
    public function callAsync(string $call, array $params = array())
    {
        switch ($call) {
            case Operation\Meta\Root::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Root::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Root::class] = $this->hydrators->getObjectMapperOperationRoot();
                }
                $operation = new Operation\Meta\Root($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Root::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Root {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\ListGlobalWebhooks::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Admin\Hooks::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Admin\Hooks::class] = $this->hydrators->getObjectMapperOperationAdminHooks();
                }
                $operation = new Operation\EnterpriseAdmin\ListGlobalWebhooks($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Admin\Hooks::class], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\GlobalHook {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\CreateGlobalWebhook::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Admin\Hooks::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Admin\Hooks::class] = $this->hydrators->getObjectMapperOperationAdminHooks();
                }
                $operation = new Operation\EnterpriseAdmin\CreateGlobalWebhook($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Admin\Hooks::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\GlobalHook {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\GetGlobalWebhook::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('hook_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Admin\Hooks\CbHookIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Admin\Hooks\CbHookIdRcb::class] = $this->hydrators->getObjectMapperOperationAdminHooksCbHookIdRcb();
                }
                $operation = new Operation\EnterpriseAdmin\GetGlobalWebhook($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Admin\Hooks\CbHookIdRcb::class], $params['hook_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\GlobalHook {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\DeleteGlobalWebhook::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('hook_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\EnterpriseAdmin\DeleteGlobalWebhook($params['hook_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\UpdateGlobalWebhook::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('hook_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Admin\Hooks\CbHookIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Admin\Hooks\CbHookIdRcb::class] = $this->hydrators->getObjectMapperOperationAdminHooksCbHookIdRcb();
                }
                $operation = new Operation\EnterpriseAdmin\UpdateGlobalWebhook($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Admin\Hooks\CbHookIdRcb::class], $params['hook_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\GlobalHook2 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\PingGlobalWebhook::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('hook_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\EnterpriseAdmin\PingGlobalWebhook($params['hook_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\ListPublicKeys::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('since', 'per_page', 'page', 'direction', 'sort')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Admin\Keys::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Admin\Keys::class] = $this->hydrators->getObjectMapperOperationAdminKeys();
                }
                $operation = new Operation\EnterpriseAdmin\ListPublicKeys($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Admin\Keys::class], $params['since'], $params['per_page'], $params['page'], $params['direction'], $params['sort']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PublicKeyFull {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\DeletePublicKey::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('key_ids')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\EnterpriseAdmin\DeletePublicKey($params['key_ids']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\UpdateLdapMappingForTeam::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Admin\Ldap\Teams\CbTeamIdRcb\Mapping::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Admin\Ldap\Teams\CbTeamIdRcb\Mapping::class] = $this->hydrators->getObjectMapperOperationAdminLdapTeamsCbTeamIdRcbMapping();
                }
                $operation = new Operation\EnterpriseAdmin\UpdateLdapMappingForTeam($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Admin\Ldap\Teams\CbTeamIdRcb\Mapping::class], $params['team_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\LdapMappingTeam {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\SyncLdapMappingForTeam::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Admin\Ldap\Teams\CbTeamIdRcb\Sync::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Admin\Ldap\Teams\CbTeamIdRcb\Sync::class] = $this->hydrators->getObjectMapperOperationAdminLdapTeamsCbTeamIdRcbSync();
                }
                $operation = new Operation\EnterpriseAdmin\SyncLdapMappingForTeam($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Admin\Ldap\Teams\CbTeamIdRcb\Sync::class], $params['team_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\EnterpriseAdmin\SyncLdapMappingForTeam\Response\Applicationjson\H201 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\UpdateLdapMappingForUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Admin\Ldap\Users\CbUsernameRcb\Mapping::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Admin\Ldap\Users\CbUsernameRcb\Mapping::class] = $this->hydrators->getObjectMapperOperationAdminLdapUsersCbUsernameRcbMapping();
                }
                $operation = new Operation\EnterpriseAdmin\UpdateLdapMappingForUser($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Admin\Ldap\Users\CbUsernameRcb\Mapping::class], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\LdapMappingUser {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\SyncLdapMappingForUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Admin\Ldap\Users\CbUsernameRcb\Sync::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Admin\Ldap\Users\CbUsernameRcb\Sync::class] = $this->hydrators->getObjectMapperOperationAdminLdapUsersCbUsernameRcbSync();
                }
                $operation = new Operation\EnterpriseAdmin\SyncLdapMappingForUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Admin\Ldap\Users\CbUsernameRcb\Sync::class], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\EnterpriseAdmin\SyncLdapMappingForTeam\Response\Applicationjson\H201 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\CreateOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Admin\Organizations::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Admin\Organizations::class] = $this->hydrators->getObjectMapperOperationAdminOrganizations();
                }
                $operation = new Operation\EnterpriseAdmin\CreateOrg($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Admin\Organizations::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\OrganizationSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\UpdateOrgName::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Admin\Organizations\CbOrgRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Admin\Organizations\CbOrgRcb::class] = $this->hydrators->getObjectMapperOperationAdminOrganizationsCbOrgRcb();
                }
                $operation = new Operation\EnterpriseAdmin\UpdateOrgName($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Admin\Organizations\CbOrgRcb::class], $params['org']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\EnterpriseAdmin\UpdateOrgName\Response\Applicationjson\H202 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\ListPreReceiveEnvironments::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('per_page', 'page', 'direction', 'sort')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Admin\PreReceiveEnvironments::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Admin\PreReceiveEnvironments::class] = $this->hydrators->getObjectMapperOperationAdminPreReceiveEnvironments();
                }
                $operation = new Operation\EnterpriseAdmin\ListPreReceiveEnvironments($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Admin\PreReceiveEnvironments::class], $params['per_page'], $params['page'], $params['direction'], $params['sort']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PreReceiveEnvironment {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\CreatePreReceiveEnvironment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Admin\PreReceiveEnvironments::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Admin\PreReceiveEnvironments::class] = $this->hydrators->getObjectMapperOperationAdminPreReceiveEnvironments();
                }
                $operation = new Operation\EnterpriseAdmin\CreatePreReceiveEnvironment($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Admin\PreReceiveEnvironments::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PreReceiveEnvironment {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\GetPreReceiveEnvironment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('pre_receive_environment_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Admin\PreDashReceiveDashEnvironments\CbPreReceiveEnvironmentIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Admin\PreDashReceiveDashEnvironments\CbPreReceiveEnvironmentIdRcb::class] = $this->hydrators->getObjectMapperOperationAdminPreDashReceiveDashEnvironmentsCbPreReceiveEnvironmentIdRcb();
                }
                $operation = new Operation\EnterpriseAdmin\GetPreReceiveEnvironment($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Admin\PreDashReceiveDashEnvironments\CbPreReceiveEnvironmentIdRcb::class], $params['pre_receive_environment_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PreReceiveEnvironment {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\DeletePreReceiveEnvironment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('pre_receive_environment_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Admin\PreDashReceiveDashEnvironments\CbPreReceiveEnvironmentIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Admin\PreDashReceiveDashEnvironments\CbPreReceiveEnvironmentIdRcb::class] = $this->hydrators->getObjectMapperOperationAdminPreDashReceiveDashEnvironmentsCbPreReceiveEnvironmentIdRcb();
                }
                $operation = new Operation\EnterpriseAdmin\DeletePreReceiveEnvironment($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Admin\PreDashReceiveDashEnvironments\CbPreReceiveEnvironmentIdRcb::class], $params['pre_receive_environment_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\EnterpriseAdmin\DeletePreReceiveEnvironment\Response\Applicationjson\H422 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\UpdatePreReceiveEnvironment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('pre_receive_environment_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Admin\PreDashReceiveDashEnvironments\CbPreReceiveEnvironmentIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Admin\PreDashReceiveDashEnvironments\CbPreReceiveEnvironmentIdRcb::class] = $this->hydrators->getObjectMapperOperationAdminPreDashReceiveDashEnvironmentsCbPreReceiveEnvironmentIdRcb();
                }
                $operation = new Operation\EnterpriseAdmin\UpdatePreReceiveEnvironment($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Admin\PreDashReceiveDashEnvironments\CbPreReceiveEnvironmentIdRcb::class], $params['pre_receive_environment_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PreReceiveEnvironment|Schema\Operation\EnterpriseAdmin\DeletePreReceiveEnvironment\Response\Applicationjson\H422 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\StartPreReceiveEnvironmentDownload::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('pre_receive_environment_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Admin\PreDashReceiveDashEnvironments\CbPreReceiveEnvironmentIdRcb\Downloads::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Admin\PreDashReceiveDashEnvironments\CbPreReceiveEnvironmentIdRcb\Downloads::class] = $this->hydrators->getObjectMapperOperationAdminPreDashReceiveDashEnvironmentsCbPreReceiveEnvironmentIdRcbDownloads();
                }
                $operation = new Operation\EnterpriseAdmin\StartPreReceiveEnvironmentDownload($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Admin\PreDashReceiveDashEnvironments\CbPreReceiveEnvironmentIdRcb\Downloads::class], $params['pre_receive_environment_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PreReceiveEnvironmentDownloadStatus|Schema\Operation\EnterpriseAdmin\DeletePreReceiveEnvironment\Response\Applicationjson\H422 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\GetDownloadStatusForPreReceiveEnvironment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('pre_receive_environment_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Admin\PreDashReceiveDashEnvironments\CbPreReceiveEnvironmentIdRcb\Downloads\Latest::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Admin\PreDashReceiveDashEnvironments\CbPreReceiveEnvironmentIdRcb\Downloads\Latest::class] = $this->hydrators->getObjectMapperOperationAdminPreDashReceiveDashEnvironmentsCbPreReceiveEnvironmentIdRcbDownloadsLatest();
                }
                $operation = new Operation\EnterpriseAdmin\GetDownloadStatusForPreReceiveEnvironment($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Admin\PreDashReceiveDashEnvironments\CbPreReceiveEnvironmentIdRcb\Downloads\Latest::class], $params['pre_receive_environment_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PreReceiveEnvironmentDownloadStatus {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\ListPreReceiveHooks::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('per_page', 'page', 'direction', 'sort')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Admin\PreReceiveHooks::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Admin\PreReceiveHooks::class] = $this->hydrators->getObjectMapperOperationAdminPreReceiveHooks();
                }
                $operation = new Operation\EnterpriseAdmin\ListPreReceiveHooks($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Admin\PreReceiveHooks::class], $params['per_page'], $params['page'], $params['direction'], $params['sort']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PreReceiveHook {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\CreatePreReceiveHook::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Admin\PreReceiveHooks::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Admin\PreReceiveHooks::class] = $this->hydrators->getObjectMapperOperationAdminPreReceiveHooks();
                }
                $operation = new Operation\EnterpriseAdmin\CreatePreReceiveHook($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Admin\PreReceiveHooks::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PreReceiveHook {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\GetPreReceiveHook::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('pre_receive_hook_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Admin\PreDashReceiveDashHooks\CbPreReceiveHookIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Admin\PreDashReceiveDashHooks\CbPreReceiveHookIdRcb::class] = $this->hydrators->getObjectMapperOperationAdminPreDashReceiveDashHooksCbPreReceiveHookIdRcb();
                }
                $operation = new Operation\EnterpriseAdmin\GetPreReceiveHook($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Admin\PreDashReceiveDashHooks\CbPreReceiveHookIdRcb::class], $params['pre_receive_hook_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PreReceiveHook {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\DeletePreReceiveHook::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('pre_receive_hook_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\EnterpriseAdmin\DeletePreReceiveHook($params['pre_receive_hook_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\UpdatePreReceiveHook::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('pre_receive_hook_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Admin\PreDashReceiveDashHooks\CbPreReceiveHookIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Admin\PreDashReceiveDashHooks\CbPreReceiveHookIdRcb::class] = $this->hydrators->getObjectMapperOperationAdminPreDashReceiveDashHooksCbPreReceiveHookIdRcb();
                }
                $operation = new Operation\EnterpriseAdmin\UpdatePreReceiveHook($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Admin\PreDashReceiveDashHooks\CbPreReceiveHookIdRcb::class], $params['pre_receive_hook_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PreReceiveHook {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\ListPersonalAccessTokens::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Admin\Tokens::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Admin\Tokens::class] = $this->hydrators->getObjectMapperOperationAdminTokens();
                }
                $operation = new Operation\EnterpriseAdmin\ListPersonalAccessTokens($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Admin\Tokens::class], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Authorization {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\DeletePersonalAccessToken::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('token_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\EnterpriseAdmin\DeletePersonalAccessToken($params['token_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\CreateUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Admin\Users::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Admin\Users::class] = $this->hydrators->getObjectMapperOperationAdminUsers();
                }
                $operation = new Operation\EnterpriseAdmin\CreateUser($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Admin\Users::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\SimpleUser {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\DeleteUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\EnterpriseAdmin\DeleteUser($params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\UpdateUsernameForUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Admin\Users\CbUsernameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Admin\Users\CbUsernameRcb::class] = $this->hydrators->getObjectMapperOperationAdminUsersCbUsernameRcb();
                }
                $operation = new Operation\EnterpriseAdmin\UpdateUsernameForUser($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Admin\Users\CbUsernameRcb::class], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\EnterpriseAdmin\UpdateOrgName\Response\Applicationjson\H202 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\CreateImpersonationOAuthToken::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Admin\Users\CbUsernameRcb\Authorizations::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Admin\Users\CbUsernameRcb\Authorizations::class] = $this->hydrators->getObjectMapperOperationAdminUsersCbUsernameRcbAuthorizations();
                }
                $operation = new Operation\EnterpriseAdmin\CreateImpersonationOAuthToken($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Admin\Users\CbUsernameRcb\Authorizations::class], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Authorization {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\DeleteImpersonationOAuthToken::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\EnterpriseAdmin\DeleteImpersonationOAuthToken($params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Apps\GetAuthenticated::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\App::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\App::class] = $this->hydrators->getObjectMapperOperationApp();
                }
                $operation = new Operation\Apps\GetAuthenticated($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\App::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Integration {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Apps\CreateFromManifest::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('code')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\AppManifests\CbCodeRcb\Conversions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\AppManifests\CbCodeRcb\Conversions::class] = $this->hydrators->getObjectMapperOperationAppManifestsCbCodeRcbConversions();
                }
                $operation = new Operation\Apps\CreateFromManifest($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\AppManifests\CbCodeRcb\Conversions::class], $params['code']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Apps\CreateFromManifest\Response\Applicationjson\H201|Schema\BasicError|Schema\ValidationErrorSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Apps\GetWebhookConfigForApp::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\App\Hook\Config::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\App\Hook\Config::class] = $this->hydrators->getObjectMapperOperationAppHookConfig();
                }
                $operation = new Operation\Apps\GetWebhookConfigForApp($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\App\Hook\Config::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\WebhookConfig {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Apps\UpdateWebhookConfigForApp::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\App\Hook\Config::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\App\Hook\Config::class] = $this->hydrators->getObjectMapperOperationAppHookConfig();
                }
                $operation = new Operation\Apps\UpdateWebhookConfigForApp($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\App\Hook\Config::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\WebhookConfig {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Apps\ListWebhookDeliveries::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('cursor', 'redelivery', 'per_page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\App\Hook\Deliveries::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\App\Hook\Deliveries::class] = $this->hydrators->getObjectMapperOperationAppHookDeliveries();
                }
                $operation = new Operation\Apps\ListWebhookDeliveries($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\App\Hook\Deliveries::class], $params['cursor'], $params['redelivery'], $params['per_page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\HookDeliveryItem|Schema\BasicError|Schema\ScimError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Apps\GetWebhookDelivery::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('delivery_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\App\Hook\Deliveries\CbDeliveryIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\App\Hook\Deliveries\CbDeliveryIdRcb::class] = $this->hydrators->getObjectMapperOperationAppHookDeliveriesCbDeliveryIdRcb();
                }
                $operation = new Operation\Apps\GetWebhookDelivery($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\App\Hook\Deliveries\CbDeliveryIdRcb::class], $params['delivery_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\HookDelivery|Schema\BasicError|Schema\ScimError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Apps\RedeliverWebhookDelivery::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('delivery_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\App\Hook\Deliveries\CbDeliveryIdRcb\Attempts::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\App\Hook\Deliveries\CbDeliveryIdRcb\Attempts::class] = $this->hydrators->getObjectMapperOperationAppHookDeliveriesCbDeliveryIdRcbAttempts();
                }
                $operation = new Operation\Apps\RedeliverWebhookDelivery($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\App\Hook\Deliveries\CbDeliveryIdRcb\Attempts::class], $params['delivery_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\AuditLogEvent\Config|Schema\BasicError|Schema\ScimError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Apps\ListInstallationRequestsForAuthenticatedApp::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\App\InstallationRequests::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\App\InstallationRequests::class] = $this->hydrators->getObjectMapperOperationAppInstallationRequests();
                }
                $operation = new Operation\Apps\ListInstallationRequestsForAuthenticatedApp($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\App\InstallationRequests::class], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\IntegrationInstallationRequest|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Apps\ListInstallations::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('since', 'outdated', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\App\Installations::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\App\Installations::class] = $this->hydrators->getObjectMapperOperationAppInstallations();
                }
                $operation = new Operation\Apps\ListInstallations($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\App\Installations::class], $params['since'], $params['outdated'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Installation {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Apps\GetInstallation::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('installation_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\App\Installations\CbInstallationIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\App\Installations\CbInstallationIdRcb::class] = $this->hydrators->getObjectMapperOperationAppInstallationsCbInstallationIdRcb();
                }
                $operation = new Operation\Apps\GetInstallation($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\App\Installations\CbInstallationIdRcb::class], $params['installation_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Installation|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Apps\DeleteInstallation::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('installation_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\App\Installations\CbInstallationIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\App\Installations\CbInstallationIdRcb::class] = $this->hydrators->getObjectMapperOperationAppInstallationsCbInstallationIdRcb();
                }
                $operation = new Operation\Apps\DeleteInstallation($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\App\Installations\CbInstallationIdRcb::class], $params['installation_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Apps\CreateInstallationAccessToken::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('installation_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\App\Installations\CbInstallationIdRcb\AccessTokens::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\App\Installations\CbInstallationIdRcb\AccessTokens::class] = $this->hydrators->getObjectMapperOperationAppInstallationsCbInstallationIdRcbAccessTokens();
                }
                $operation = new Operation\Apps\CreateInstallationAccessToken($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\App\Installations\CbInstallationIdRcb\AccessTokens::class], $params['installation_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\InstallationToken|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Apps\SuspendInstallation::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('installation_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\App\Installations\CbInstallationIdRcb\Suspended::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\App\Installations\CbInstallationIdRcb\Suspended::class] = $this->hydrators->getObjectMapperOperationAppInstallationsCbInstallationIdRcbSuspended();
                }
                $operation = new Operation\Apps\SuspendInstallation($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\App\Installations\CbInstallationIdRcb\Suspended::class], $params['installation_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Apps\UnsuspendInstallation::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('installation_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\App\Installations\CbInstallationIdRcb\Suspended::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\App\Installations\CbInstallationIdRcb\Suspended::class] = $this->hydrators->getObjectMapperOperationAppInstallationsCbInstallationIdRcbSuspended();
                }
                $operation = new Operation\Apps\UnsuspendInstallation($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\App\Installations\CbInstallationIdRcb\Suspended::class], $params['installation_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\OauthAuthorizations\ListGrants::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('client_id', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Applications\Grants::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Applications\Grants::class] = $this->hydrators->getObjectMapperOperationApplicationsGrants();
                }
                $operation = new Operation\OauthAuthorizations\ListGrants($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Applications\Grants::class], $params['client_id'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ApplicationGrant|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\OauthAuthorizations\GetGrant::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('grant_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Applications\Grants\CbGrantIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Applications\Grants\CbGrantIdRcb::class] = $this->hydrators->getObjectMapperOperationApplicationsGrantsCbGrantIdRcb();
                }
                $operation = new Operation\OauthAuthorizations\GetGrant($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Applications\Grants\CbGrantIdRcb::class], $params['grant_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ApplicationGrant|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\OauthAuthorizations\DeleteGrant::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('grant_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Applications\Grants\CbGrantIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Applications\Grants\CbGrantIdRcb::class] = $this->hydrators->getObjectMapperOperationApplicationsGrantsCbGrantIdRcb();
                }
                $operation = new Operation\OauthAuthorizations\DeleteGrant($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Applications\Grants\CbGrantIdRcb::class], $params['grant_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Apps\DeleteAuthorization::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('client_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Applications\CbClientIdRcb\Grant::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Applications\CbClientIdRcb\Grant::class] = $this->hydrators->getObjectMapperOperationApplicationsCbClientIdRcbGrant();
                }
                $operation = new Operation\Apps\DeleteAuthorization($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Applications\CbClientIdRcb\Grant::class], $params['client_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Apps\CheckToken::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('client_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Applications\CbClientIdRcb\Token::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Applications\CbClientIdRcb\Token::class] = $this->hydrators->getObjectMapperOperationApplicationsCbClientIdRcbToken();
                }
                $operation = new Operation\Apps\CheckToken($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Applications\CbClientIdRcb\Token::class], $params['client_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Authorization|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Apps\DeleteToken::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('client_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Applications\CbClientIdRcb\Token::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Applications\CbClientIdRcb\Token::class] = $this->hydrators->getObjectMapperOperationApplicationsCbClientIdRcbToken();
                }
                $operation = new Operation\Apps\DeleteToken($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Applications\CbClientIdRcb\Token::class], $params['client_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Apps\ResetToken::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('client_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Applications\CbClientIdRcb\Token::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Applications\CbClientIdRcb\Token::class] = $this->hydrators->getObjectMapperOperationApplicationsCbClientIdRcbToken();
                }
                $operation = new Operation\Apps\ResetToken($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Applications\CbClientIdRcb\Token::class], $params['client_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Authorization|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Apps\ScopeToken::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('client_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Applications\CbClientIdRcb\Token\Scoped::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Applications\CbClientIdRcb\Token\Scoped::class] = $this->hydrators->getObjectMapperOperationApplicationsCbClientIdRcbTokenScoped();
                }
                $operation = new Operation\Apps\ScopeToken($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Applications\CbClientIdRcb\Token\Scoped::class], $params['client_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Authorization|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Apps\GetBySlug::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('app_slug')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Apps\CbAppSlugRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Apps\CbAppSlugRcb::class] = $this->hydrators->getObjectMapperOperationAppsCbAppSlugRcb();
                }
                $operation = new Operation\Apps\GetBySlug($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Apps\CbAppSlugRcb::class], $params['app_slug']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Integration|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\OauthAuthorizations\ListAuthorizations::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('client_id', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Authorizations::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Authorizations::class] = $this->hydrators->getObjectMapperOperationAuthorizations();
                }
                $operation = new Operation\OauthAuthorizations\ListAuthorizations($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Authorizations::class], $params['client_id'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Authorization|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\OauthAuthorizations\CreateAuthorization::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Authorizations::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Authorizations::class] = $this->hydrators->getObjectMapperOperationAuthorizations();
                }
                $operation = new Operation\OauthAuthorizations\CreateAuthorization($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Authorizations::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Authorization|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\OauthAuthorizations\GetOrCreateAuthorizationForApp::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('client_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Authorizations\Clients\CbClientIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Authorizations\Clients\CbClientIdRcb::class] = $this->hydrators->getObjectMapperOperationAuthorizationsClientsCbClientIdRcb();
                }
                $operation = new Operation\OauthAuthorizations\GetOrCreateAuthorizationForApp($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Authorizations\Clients\CbClientIdRcb::class], $params['client_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Authorization|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\OauthAuthorizations\GetOrCreateAuthorizationForAppAndFingerprint::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('client_id', 'fingerprint')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Authorizations\Clients\CbClientIdRcb\CbFingerprintRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Authorizations\Clients\CbClientIdRcb\CbFingerprintRcb::class] = $this->hydrators->getObjectMapperOperationAuthorizationsClientsCbClientIdRcbCbFingerprintRcb();
                }
                $operation = new Operation\OauthAuthorizations\GetOrCreateAuthorizationForAppAndFingerprint($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Authorizations\Clients\CbClientIdRcb\CbFingerprintRcb::class], $params['client_id'], $params['fingerprint']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Authorization|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\OauthAuthorizations\GetAuthorization::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('authorization_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Authorizations\CbAuthorizationIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Authorizations\CbAuthorizationIdRcb::class] = $this->hydrators->getObjectMapperOperationAuthorizationsCbAuthorizationIdRcb();
                }
                $operation = new Operation\OauthAuthorizations\GetAuthorization($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Authorizations\CbAuthorizationIdRcb::class], $params['authorization_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Authorization|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\OauthAuthorizations\DeleteAuthorization::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('authorization_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Authorizations\CbAuthorizationIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Authorizations\CbAuthorizationIdRcb::class] = $this->hydrators->getObjectMapperOperationAuthorizationsCbAuthorizationIdRcb();
                }
                $operation = new Operation\OauthAuthorizations\DeleteAuthorization($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Authorizations\CbAuthorizationIdRcb::class], $params['authorization_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\OauthAuthorizations\UpdateAuthorization::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('authorization_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Authorizations\CbAuthorizationIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Authorizations\CbAuthorizationIdRcb::class] = $this->hydrators->getObjectMapperOperationAuthorizationsCbAuthorizationIdRcb();
                }
                $operation = new Operation\OauthAuthorizations\UpdateAuthorization($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Authorizations\CbAuthorizationIdRcb::class], $params['authorization_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Authorization|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\CodesOfConduct\GetAllCodesOfConduct::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\CodesOfConduct::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\CodesOfConduct::class] = $this->hydrators->getObjectMapperOperationCodesOfConduct();
                }
                $operation = new Operation\CodesOfConduct\GetAllCodesOfConduct($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\CodesOfConduct::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\CodeOfConduct {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\CodesOfConduct\GetConductCode::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('key')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\CodesOfConduct\CbKeyRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\CodesOfConduct\CbKeyRcb::class] = $this->hydrators->getObjectMapperOperationCodesOfConductCbKeyRcb();
                }
                $operation = new Operation\CodesOfConduct\GetConductCode($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\CodesOfConduct\CbKeyRcb::class], $params['key']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\CodeOfConduct|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Emojis\Get::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Emojis::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Emojis::class] = $this->hydrators->getObjectMapperOperationEmojis();
                }
                $operation = new Operation\Emojis\Get($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Emojis::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Emojis\Get\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\GetAnnouncement::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprise\Announcement::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprise\Announcement::class] = $this->hydrators->getObjectMapperOperationEnterpriseAnnouncement();
                }
                $operation = new Operation\EnterpriseAdmin\GetAnnouncement($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprise\Announcement::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Announcement {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\RemoveAnnouncement::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\EnterpriseAdmin\RemoveAnnouncement();
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\SetAnnouncement::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprise\Announcement::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprise\Announcement::class] = $this->hydrators->getObjectMapperOperationEnterpriseAnnouncement();
                }
                $operation = new Operation\EnterpriseAdmin\SetAnnouncement($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprise\Announcement::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Announcement {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\GetLicenseInformation::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprise\Settings\License::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprise\Settings\License::class] = $this->hydrators->getObjectMapperOperationEnterpriseSettingsLicense();
                }
                $operation = new Operation\EnterpriseAdmin\GetLicenseInformation($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprise\Settings\License::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\LicenseInfo {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\GetAllStats::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprise\Stats\All::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprise\Stats\All::class] = $this->hydrators->getObjectMapperOperationEnterpriseStatsAll();
                }
                $operation = new Operation\EnterpriseAdmin\GetAllStats($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprise\Stats\All::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\EnterpriseOverview {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\GetCommentStats::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprise\Stats\Comments::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprise\Stats\Comments::class] = $this->hydrators->getObjectMapperOperationEnterpriseStatsComments();
                }
                $operation = new Operation\EnterpriseAdmin\GetCommentStats($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprise\Stats\Comments::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\EnterpriseCommentOverview {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\GetGistStats::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprise\Stats\Gists::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprise\Stats\Gists::class] = $this->hydrators->getObjectMapperOperationEnterpriseStatsGists();
                }
                $operation = new Operation\EnterpriseAdmin\GetGistStats($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprise\Stats\Gists::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\EnterpriseGistOverview {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\GetHooksStats::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprise\Stats\Hooks::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprise\Stats\Hooks::class] = $this->hydrators->getObjectMapperOperationEnterpriseStatsHooks();
                }
                $operation = new Operation\EnterpriseAdmin\GetHooksStats($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprise\Stats\Hooks::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\EnterpriseHookOverview {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\GetIssueStats::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprise\Stats\Issues::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprise\Stats\Issues::class] = $this->hydrators->getObjectMapperOperationEnterpriseStatsIssues();
                }
                $operation = new Operation\EnterpriseAdmin\GetIssueStats($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprise\Stats\Issues::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\EnterpriseIssueOverview {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\GetMilestoneStats::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprise\Stats\Milestones::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprise\Stats\Milestones::class] = $this->hydrators->getObjectMapperOperationEnterpriseStatsMilestones();
                }
                $operation = new Operation\EnterpriseAdmin\GetMilestoneStats($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprise\Stats\Milestones::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\EnterpriseMilestoneOverview {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\GetOrgStats::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprise\Stats\Orgs::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprise\Stats\Orgs::class] = $this->hydrators->getObjectMapperOperationEnterpriseStatsOrgs();
                }
                $operation = new Operation\EnterpriseAdmin\GetOrgStats($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprise\Stats\Orgs::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\EnterpriseOrganizationOverview {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\GetPagesStats::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprise\Stats\Pages::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprise\Stats\Pages::class] = $this->hydrators->getObjectMapperOperationEnterpriseStatsPages();
                }
                $operation = new Operation\EnterpriseAdmin\GetPagesStats($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprise\Stats\Pages::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\EnterprisePageOverview {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\GetPullRequestStats::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprise\Stats\Pulls::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprise\Stats\Pulls::class] = $this->hydrators->getObjectMapperOperationEnterpriseStatsPulls();
                }
                $operation = new Operation\EnterpriseAdmin\GetPullRequestStats($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprise\Stats\Pulls::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\EnterprisePullRequestOverview {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\GetRepoStats::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprise\Stats\Repos::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprise\Stats\Repos::class] = $this->hydrators->getObjectMapperOperationEnterpriseStatsRepos();
                }
                $operation = new Operation\EnterpriseAdmin\GetRepoStats($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprise\Stats\Repos::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\EnterpriseRepositoryOverview {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\GetUserStats::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprise\Stats\Users::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprise\Stats\Users::class] = $this->hydrators->getObjectMapperOperationEnterpriseStatsUsers();
                }
                $operation = new Operation\EnterpriseAdmin\GetUserStats($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprise\Stats\Users::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\EnterpriseUserOverview {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\GetActionsCacheUsageForEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Cache\Usage::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Cache\Usage::class] = $this->hydrators->getObjectMapperOperationEnterprisesCbEnterpriseRcbActionsCacheUsage();
                }
                $operation = new Operation\Actions\GetActionsCacheUsageForEnterprise($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Cache\Usage::class], $params['enterprise']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ActionsCacheUsageOrgEnterprise {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\GetActionsCacheUsagePolicyForEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Cache\UsagePolicy::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Cache\UsagePolicy::class] = $this->hydrators->getObjectMapperOperationEnterprisesCbEnterpriseRcbActionsCacheUsagePolicy();
                }
                $operation = new Operation\Actions\GetActionsCacheUsagePolicyForEnterprise($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Cache\UsagePolicy::class], $params['enterprise']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ActionsCacheUsagePolicyEnterprise {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\SetActionsCacheUsagePolicyForEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\SetActionsCacheUsagePolicyForEnterprise($this->requestSchemaValidator, $params['enterprise']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\GetGithubActionsPermissionsEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Permissions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Permissions::class] = $this->hydrators->getObjectMapperOperationEnterprisesCbEnterpriseRcbActionsPermissions();
                }
                $operation = new Operation\EnterpriseAdmin\GetGithubActionsPermissionsEnterprise($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Permissions::class], $params['enterprise']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ActionsEnterprisePermissions {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\SetGithubActionsPermissionsEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\EnterpriseAdmin\SetGithubActionsPermissionsEnterprise($this->requestSchemaValidator, $params['enterprise']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\ListSelectedOrganizationsEnabledGithubActionsEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Permissions\Organizations::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Permissions\Organizations::class] = $this->hydrators->getObjectMapperOperationEnterprisesCbEnterpriseRcbActionsPermissionsOrganizations();
                }
                $operation = new Operation\EnterpriseAdmin\ListSelectedOrganizationsEnabledGithubActionsEnterprise($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Permissions\Organizations::class], $params['enterprise'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\EnterpriseAdmin\ListSelectedOrganizationsEnabledGithubActionsEnterprise\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\SetSelectedOrganizationsEnabledGithubActionsEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\EnterpriseAdmin\SetSelectedOrganizationsEnabledGithubActionsEnterprise($this->requestSchemaValidator, $params['enterprise']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\EnableSelectedOrganizationGithubActionsEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise', 'org_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\EnterpriseAdmin\EnableSelectedOrganizationGithubActionsEnterprise($params['enterprise'], $params['org_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\DisableSelectedOrganizationGithubActionsEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise', 'org_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\EnterpriseAdmin\DisableSelectedOrganizationGithubActionsEnterprise($params['enterprise'], $params['org_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\GetAllowedActionsEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Permissions\SelectedActions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Permissions\SelectedActions::class] = $this->hydrators->getObjectMapperOperationEnterprisesCbEnterpriseRcbActionsPermissionsSelectedActions();
                }
                $operation = new Operation\EnterpriseAdmin\GetAllowedActionsEnterprise($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Permissions\SelectedActions::class], $params['enterprise']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\SelectedActions {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\SetAllowedActionsEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\EnterpriseAdmin\SetAllowedActionsEnterprise($this->requestSchemaValidator, $params['enterprise']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\GetGithubActionsDefaultWorkflowPermissionsEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Permissions\Workflow::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Permissions\Workflow::class] = $this->hydrators->getObjectMapperOperationEnterprisesCbEnterpriseRcbActionsPermissionsWorkflow();
                }
                $operation = new Operation\Actions\GetGithubActionsDefaultWorkflowPermissionsEnterprise($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Permissions\Workflow::class], $params['enterprise']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ActionsGetDefaultWorkflowPermissions {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\SetGithubActionsDefaultWorkflowPermissionsEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\SetGithubActionsDefaultWorkflowPermissionsEnterprise($this->requestSchemaValidator, $params['enterprise']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\ListSelfHostedRunnerGroupsForEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise', 'visible_to_organization', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\RunnerGroups::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\RunnerGroups::class] = $this->hydrators->getObjectMapperOperationEnterprisesCbEnterpriseRcbActionsRunnerGroups();
                }
                $operation = new Operation\EnterpriseAdmin\ListSelfHostedRunnerGroupsForEnterprise($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\RunnerGroups::class], $params['enterprise'], $params['visible_to_organization'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\EnterpriseAdmin\ListSelfHostedRunnerGroupsForEnterprise\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\CreateSelfHostedRunnerGroupForEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\RunnerGroups::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\RunnerGroups::class] = $this->hydrators->getObjectMapperOperationEnterprisesCbEnterpriseRcbActionsRunnerGroups();
                }
                $operation = new Operation\EnterpriseAdmin\CreateSelfHostedRunnerGroupForEnterprise($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\RunnerGroups::class], $params['enterprise']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\RunnerGroupsEnterprise {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\GetSelfHostedRunnerGroupForEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise', 'runner_group_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\RunnerDashGroups\CbRunnerGroupIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\RunnerDashGroups\CbRunnerGroupIdRcb::class] = $this->hydrators->getObjectMapperOperationEnterprisesCbEnterpriseRcbActionsRunnerDashGroupsCbRunnerGroupIdRcb();
                }
                $operation = new Operation\EnterpriseAdmin\GetSelfHostedRunnerGroupForEnterprise($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\RunnerDashGroups\CbRunnerGroupIdRcb::class], $params['enterprise'], $params['runner_group_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\RunnerGroupsEnterprise {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\DeleteSelfHostedRunnerGroupFromEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise', 'runner_group_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\EnterpriseAdmin\DeleteSelfHostedRunnerGroupFromEnterprise($params['enterprise'], $params['runner_group_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\UpdateSelfHostedRunnerGroupForEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise', 'runner_group_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\RunnerDashGroups\CbRunnerGroupIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\RunnerDashGroups\CbRunnerGroupIdRcb::class] = $this->hydrators->getObjectMapperOperationEnterprisesCbEnterpriseRcbActionsRunnerDashGroupsCbRunnerGroupIdRcb();
                }
                $operation = new Operation\EnterpriseAdmin\UpdateSelfHostedRunnerGroupForEnterprise($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\RunnerDashGroups\CbRunnerGroupIdRcb::class], $params['enterprise'], $params['runner_group_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\RunnerGroupsEnterprise {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\ListOrgAccessToSelfHostedRunnerGroupInEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise', 'runner_group_id', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\RunnerDashGroups\CbRunnerGroupIdRcb\Organizations::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\RunnerDashGroups\CbRunnerGroupIdRcb\Organizations::class] = $this->hydrators->getObjectMapperOperationEnterprisesCbEnterpriseRcbActionsRunnerDashGroupsCbRunnerGroupIdRcbOrganizations();
                }
                $operation = new Operation\EnterpriseAdmin\ListOrgAccessToSelfHostedRunnerGroupInEnterprise($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\RunnerDashGroups\CbRunnerGroupIdRcb\Organizations::class], $params['enterprise'], $params['runner_group_id'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\EnterpriseAdmin\ListSelectedOrganizationsEnabledGithubActionsEnterprise\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\SetOrgAccessToSelfHostedRunnerGroupInEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise', 'runner_group_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\EnterpriseAdmin\SetOrgAccessToSelfHostedRunnerGroupInEnterprise($this->requestSchemaValidator, $params['enterprise'], $params['runner_group_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\AddOrgAccessToSelfHostedRunnerGroupInEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise', 'runner_group_id', 'org_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\EnterpriseAdmin\AddOrgAccessToSelfHostedRunnerGroupInEnterprise($params['enterprise'], $params['runner_group_id'], $params['org_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\RemoveOrgAccessToSelfHostedRunnerGroupInEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise', 'runner_group_id', 'org_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\EnterpriseAdmin\RemoveOrgAccessToSelfHostedRunnerGroupInEnterprise($params['enterprise'], $params['runner_group_id'], $params['org_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\ListSelfHostedRunnersInGroupForEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise', 'runner_group_id', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\RunnerDashGroups\CbRunnerGroupIdRcb\Runners::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\RunnerDashGroups\CbRunnerGroupIdRcb\Runners::class] = $this->hydrators->getObjectMapperOperationEnterprisesCbEnterpriseRcbActionsRunnerDashGroupsCbRunnerGroupIdRcbRunners();
                }
                $operation = new Operation\EnterpriseAdmin\ListSelfHostedRunnersInGroupForEnterprise($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\RunnerDashGroups\CbRunnerGroupIdRcb\Runners::class], $params['enterprise'], $params['runner_group_id'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\EnterpriseAdmin\ListSelfHostedRunnersInGroupForEnterprise\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\SetSelfHostedRunnersInGroupForEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise', 'runner_group_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\EnterpriseAdmin\SetSelfHostedRunnersInGroupForEnterprise($this->requestSchemaValidator, $params['enterprise'], $params['runner_group_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\AddSelfHostedRunnerToGroupForEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise', 'runner_group_id', 'runner_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\EnterpriseAdmin\AddSelfHostedRunnerToGroupForEnterprise($params['enterprise'], $params['runner_group_id'], $params['runner_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\RemoveSelfHostedRunnerFromGroupForEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise', 'runner_group_id', 'runner_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\EnterpriseAdmin\RemoveSelfHostedRunnerFromGroupForEnterprise($params['enterprise'], $params['runner_group_id'], $params['runner_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\ListSelfHostedRunnersForEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Runners::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Runners::class] = $this->hydrators->getObjectMapperOperationEnterprisesCbEnterpriseRcbActionsRunners();
                }
                $operation = new Operation\EnterpriseAdmin\ListSelfHostedRunnersForEnterprise($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Runners::class], $params['enterprise'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\EnterpriseAdmin\ListSelfHostedRunnersForEnterprise\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\ListRunnerApplicationsForEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Runners\Downloads::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Runners\Downloads::class] = $this->hydrators->getObjectMapperOperationEnterprisesCbEnterpriseRcbActionsRunnersDownloads();
                }
                $operation = new Operation\EnterpriseAdmin\ListRunnerApplicationsForEnterprise($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Runners\Downloads::class], $params['enterprise']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\RunnerApplication {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\CreateRegistrationTokenForEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Runners\RegistrationToken::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Runners\RegistrationToken::class] = $this->hydrators->getObjectMapperOperationEnterprisesCbEnterpriseRcbActionsRunnersRegistrationToken();
                }
                $operation = new Operation\EnterpriseAdmin\CreateRegistrationTokenForEnterprise($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Runners\RegistrationToken::class], $params['enterprise']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\AuthenticationToken {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\CreateRemoveTokenForEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Runners\RemoveToken::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Runners\RemoveToken::class] = $this->hydrators->getObjectMapperOperationEnterprisesCbEnterpriseRcbActionsRunnersRemoveToken();
                }
                $operation = new Operation\EnterpriseAdmin\CreateRemoveTokenForEnterprise($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Runners\RemoveToken::class], $params['enterprise']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\AuthenticationToken {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\GetSelfHostedRunnerForEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise', 'runner_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Runners\CbRunnerIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Runners\CbRunnerIdRcb::class] = $this->hydrators->getObjectMapperOperationEnterprisesCbEnterpriseRcbActionsRunnersCbRunnerIdRcb();
                }
                $operation = new Operation\EnterpriseAdmin\GetSelfHostedRunnerForEnterprise($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Runners\CbRunnerIdRcb::class], $params['enterprise'], $params['runner_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Runner {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\DeleteSelfHostedRunnerFromEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise', 'runner_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\EnterpriseAdmin\DeleteSelfHostedRunnerFromEnterprise($params['enterprise'], $params['runner_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise', 'runner_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Runners\CbRunnerIdRcb\Labels::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Runners\CbRunnerIdRcb\Labels::class] = $this->hydrators->getObjectMapperOperationEnterprisesCbEnterpriseRcbActionsRunnersCbRunnerIdRcbLabels();
                }
                $operation = new Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Runners\CbRunnerIdRcb\Labels::class], $params['enterprise'], $params['runner_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\SetCustomLabelsForSelfHostedRunnerForEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise', 'runner_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Runners\CbRunnerIdRcb\Labels::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Runners\CbRunnerIdRcb\Labels::class] = $this->hydrators->getObjectMapperOperationEnterprisesCbEnterpriseRcbActionsRunnersCbRunnerIdRcbLabels();
                }
                $operation = new Operation\EnterpriseAdmin\SetCustomLabelsForSelfHostedRunnerForEnterprise($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Runners\CbRunnerIdRcb\Labels::class], $params['enterprise'], $params['runner_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationErrorSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\AddCustomLabelsToSelfHostedRunnerForEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise', 'runner_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Runners\CbRunnerIdRcb\Labels::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Runners\CbRunnerIdRcb\Labels::class] = $this->hydrators->getObjectMapperOperationEnterprisesCbEnterpriseRcbActionsRunnersCbRunnerIdRcbLabels();
                }
                $operation = new Operation\EnterpriseAdmin\AddCustomLabelsToSelfHostedRunnerForEnterprise($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Runners\CbRunnerIdRcb\Labels::class], $params['enterprise'], $params['runner_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationErrorSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\RemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise', 'runner_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Runners\CbRunnerIdRcb\Labels::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Runners\CbRunnerIdRcb\Labels::class] = $this->hydrators->getObjectMapperOperationEnterprisesCbEnterpriseRcbActionsRunnersCbRunnerIdRcbLabels();
                }
                $operation = new Operation\EnterpriseAdmin\RemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Runners\CbRunnerIdRcb\Labels::class], $params['enterprise'], $params['runner_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationErrorSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\RemoveCustomLabelFromSelfHostedRunnerForEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise', 'runner_id', 'name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Runners\CbRunnerIdRcb\Labels\CbNameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Runners\CbRunnerIdRcb\Labels\CbNameRcb::class] = $this->hydrators->getObjectMapperOperationEnterprisesCbEnterpriseRcbActionsRunnersCbRunnerIdRcbLabelsCbNameRcb();
                }
                $operation = new Operation\EnterpriseAdmin\RemoveCustomLabelFromSelfHostedRunnerForEnterprise($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Actions\Runners\CbRunnerIdRcb\Labels\CbNameRcb::class], $params['enterprise'], $params['runner_id'], $params['name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationErrorSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\GetAuditLog::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise', 'phrase', 'include', 'after', 'before', 'order', 'page', 'per_page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprises\CbEnterpriseRcb\AuditLog::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\AuditLog::class] = $this->hydrators->getObjectMapperOperationEnterprisesCbEnterpriseRcbAuditLog();
                }
                $operation = new Operation\EnterpriseAdmin\GetAuditLog($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\AuditLog::class], $params['enterprise'], $params['phrase'], $params['include'], $params['after'], $params['before'], $params['order'], $params['page'], $params['per_page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\AuditLogEvent {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\SecretScanning\ListAlertsForEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise', 'state', 'secret_type', 'resolution', 'before', 'after', 'sort', 'direction', 'per_page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprises\CbEnterpriseRcb\SecretScanning\Alerts::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\SecretScanning\Alerts::class] = $this->hydrators->getObjectMapperOperationEnterprisesCbEnterpriseRcbSecretScanningAlerts();
                }
                $operation = new Operation\SecretScanning\ListAlertsForEnterprise($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\SecretScanning\Alerts::class], $params['enterprise'], $params['state'], $params['secret_type'], $params['resolution'], $params['before'], $params['after'], $params['sort'], $params['direction'], $params['per_page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\OrganizationSecretScanningAlert|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Billing\GetGithubAdvancedSecurityBillingGhe::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('enterprise', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Enterprises\CbEnterpriseRcb\Settings\Billing\AdvancedSecurity::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Settings\Billing\AdvancedSecurity::class] = $this->hydrators->getObjectMapperOperationEnterprisesCbEnterpriseRcbSettingsBillingAdvancedSecurity();
                }
                $operation = new Operation\Billing\GetGithubAdvancedSecurityBillingGhe($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Enterprises\CbEnterpriseRcb\Settings\Billing\AdvancedSecurity::class], $params['enterprise'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\AdvancedSecurityActiveCommitters|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\ListPublicEvents::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Events::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Events::class] = $this->hydrators->getObjectMapperOperationEvents();
                }
                $operation = new Operation\Activity\ListPublicEvents($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Events::class], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Event|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\GetFeeds::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Feeds::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Feeds::class] = $this->hydrators->getObjectMapperOperationFeeds();
                }
                $operation = new Operation\Activity\GetFeeds($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Feeds::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Feed {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Gists\List_::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('since', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Gists::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Gists::class] = $this->hydrators->getObjectMapperOperationGists();
                }
                $operation = new Operation\Gists\List_($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Gists::class], $params['since'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BaseGist|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Gists\Create::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Gists::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Gists::class] = $this->hydrators->getObjectMapperOperationGists();
                }
                $operation = new Operation\Gists\Create($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Gists::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\GistSimple|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Gists\ListPublic::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('since', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Gists\Public_::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Gists\Public_::class] = $this->hydrators->getObjectMapperOperationGistsPublic_();
                }
                $operation = new Operation\Gists\ListPublic($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Gists\Public_::class], $params['since'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BaseGist|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Gists\ListStarred::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('since', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Gists\Starred::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Gists\Starred::class] = $this->hydrators->getObjectMapperOperationGistsStarred();
                }
                $operation = new Operation\Gists\ListStarred($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Gists\Starred::class], $params['since'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BaseGist|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Gists\Get::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('gist_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Gists\CbGistIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Gists\CbGistIdRcb::class] = $this->hydrators->getObjectMapperOperationGistsCbGistIdRcb();
                }
                $operation = new Operation\Gists\Get($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Gists\CbGistIdRcb::class], $params['gist_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\GistSimple|Schema\Operation\Gists\Get\Response\Applicationjson\H403|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Gists\Delete::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('gist_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Gists\CbGistIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Gists\CbGistIdRcb::class] = $this->hydrators->getObjectMapperOperationGistsCbGistIdRcb();
                }
                $operation = new Operation\Gists\Delete($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Gists\CbGistIdRcb::class], $params['gist_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Gists\Update::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('gist_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Gists\CbGistIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Gists\CbGistIdRcb::class] = $this->hydrators->getObjectMapperOperationGistsCbGistIdRcb();
                }
                $operation = new Operation\Gists\Update($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Gists\CbGistIdRcb::class], $params['gist_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\GistSimple|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Gists\ListComments::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('gist_id', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Gists\CbGistIdRcb\Comments::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Gists\CbGistIdRcb\Comments::class] = $this->hydrators->getObjectMapperOperationGistsCbGistIdRcbComments();
                }
                $operation = new Operation\Gists\ListComments($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Gists\CbGistIdRcb\Comments::class], $params['gist_id'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\GistComment|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Gists\CreateComment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('gist_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Gists\CbGistIdRcb\Comments::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Gists\CbGistIdRcb\Comments::class] = $this->hydrators->getObjectMapperOperationGistsCbGistIdRcbComments();
                }
                $operation = new Operation\Gists\CreateComment($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Gists\CbGistIdRcb\Comments::class], $params['gist_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\GistComment|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Gists\GetComment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('gist_id', 'comment_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Gists\CbGistIdRcb\Comments\CbCommentIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Gists\CbGistIdRcb\Comments\CbCommentIdRcb::class] = $this->hydrators->getObjectMapperOperationGistsCbGistIdRcbCommentsCbCommentIdRcb();
                }
                $operation = new Operation\Gists\GetComment($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Gists\CbGistIdRcb\Comments\CbCommentIdRcb::class], $params['gist_id'], $params['comment_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\GistComment|Schema\BasicError|Schema\Operation\Gists\Get\Response\Applicationjson\H403 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Gists\DeleteComment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('gist_id', 'comment_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Gists\CbGistIdRcb\Comments\CbCommentIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Gists\CbGistIdRcb\Comments\CbCommentIdRcb::class] = $this->hydrators->getObjectMapperOperationGistsCbGistIdRcbCommentsCbCommentIdRcb();
                }
                $operation = new Operation\Gists\DeleteComment($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Gists\CbGistIdRcb\Comments\CbCommentIdRcb::class], $params['gist_id'], $params['comment_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Gists\UpdateComment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('gist_id', 'comment_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Gists\CbGistIdRcb\Comments\CbCommentIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Gists\CbGistIdRcb\Comments\CbCommentIdRcb::class] = $this->hydrators->getObjectMapperOperationGistsCbGistIdRcbCommentsCbCommentIdRcb();
                }
                $operation = new Operation\Gists\UpdateComment($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Gists\CbGistIdRcb\Comments\CbCommentIdRcb::class], $params['gist_id'], $params['comment_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\GistComment|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Gists\ListCommits::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('gist_id', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Gists\CbGistIdRcb\Commits::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Gists\CbGistIdRcb\Commits::class] = $this->hydrators->getObjectMapperOperationGistsCbGistIdRcbCommits();
                }
                $operation = new Operation\Gists\ListCommits($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Gists\CbGistIdRcb\Commits::class], $params['gist_id'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\GistCommit|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Gists\ListForks::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('gist_id', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Gists\CbGistIdRcb\Forks::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Gists\CbGistIdRcb\Forks::class] = $this->hydrators->getObjectMapperOperationGistsCbGistIdRcbForks();
                }
                $operation = new Operation\Gists\ListForks($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Gists\CbGistIdRcb\Forks::class], $params['gist_id'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\GistSimple|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Gists\Fork::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('gist_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Gists\CbGistIdRcb\Forks::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Gists\CbGistIdRcb\Forks::class] = $this->hydrators->getObjectMapperOperationGistsCbGistIdRcbForks();
                }
                $operation = new Operation\Gists\Fork($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Gists\CbGistIdRcb\Forks::class], $params['gist_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BaseGist|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Gists\CheckIsStarred::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('gist_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Gists\CbGistIdRcb\Star::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Gists\CbGistIdRcb\Star::class] = $this->hydrators->getObjectMapperOperationGistsCbGistIdRcbStar();
                }
                $operation = new Operation\Gists\CheckIsStarred($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Gists\CbGistIdRcb\Star::class], $params['gist_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Gists\CheckIsStarred\Response\Applicationjson\H404|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Gists\Star::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('gist_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Gists\CbGistIdRcb\Star::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Gists\CbGistIdRcb\Star::class] = $this->hydrators->getObjectMapperOperationGistsCbGistIdRcbStar();
                }
                $operation = new Operation\Gists\Star($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Gists\CbGistIdRcb\Star::class], $params['gist_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Gists\Unstar::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('gist_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Gists\CbGistIdRcb\Star::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Gists\CbGistIdRcb\Star::class] = $this->hydrators->getObjectMapperOperationGistsCbGistIdRcbStar();
                }
                $operation = new Operation\Gists\Unstar($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Gists\CbGistIdRcb\Star::class], $params['gist_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Gists\GetRevision::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('gist_id', 'sha')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Gists\CbGistIdRcb\CbShaRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Gists\CbGistIdRcb\CbShaRcb::class] = $this->hydrators->getObjectMapperOperationGistsCbGistIdRcbCbShaRcb();
                }
                $operation = new Operation\Gists\GetRevision($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Gists\CbGistIdRcb\CbShaRcb::class], $params['gist_id'], $params['sha']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\GistSimple|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Gitignore\GetAllTemplates::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Gitignore\Templates::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Gitignore\Templates::class] = $this->hydrators->getObjectMapperOperationGitignoreTemplates();
                }
                $operation = new Operation\Gitignore\GetAllTemplates($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Gitignore\Templates::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Gitignore\GetAllTemplates\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Gitignore\GetTemplate::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Gitignore\Templates\CbNameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Gitignore\Templates\CbNameRcb::class] = $this->hydrators->getObjectMapperOperationGitignoreTemplatesCbNameRcb();
                }
                $operation = new Operation\Gitignore\GetTemplate($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Gitignore\Templates\CbNameRcb::class], $params['name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\GitignoreTemplate {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Apps\ListReposAccessibleToInstallation::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Installation\Repositories::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Installation\Repositories::class] = $this->hydrators->getObjectMapperOperationInstallationRepositories();
                }
                $operation = new Operation\Apps\ListReposAccessibleToInstallation($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Installation\Repositories::class], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Apps\ListReposAccessibleToInstallation\Response\Applicationjson\H200|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Apps\RevokeInstallationAccessToken::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Apps\RevokeInstallationAccessToken();
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\List_::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('labels', 'since', 'collab', 'orgs', 'owned', 'pulls', 'filter', 'state', 'sort', 'direction', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Issues::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Issues::class] = $this->hydrators->getObjectMapperOperationIssues();
                }
                $operation = new Operation\Issues\List_($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Issues::class], $params['labels'], $params['since'], $params['collab'], $params['orgs'], $params['owned'], $params['pulls'], $params['filter'], $params['state'], $params['sort'], $params['direction'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Issue|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Licenses\GetAllCommonlyUsed::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('featured', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Licenses::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Licenses::class] = $this->hydrators->getObjectMapperOperationLicenses();
                }
                $operation = new Operation\Licenses\GetAllCommonlyUsed($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Licenses::class], $params['featured'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\LicenseSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Licenses\Get::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('license')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Licenses\CbLicenseRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Licenses\CbLicenseRcb::class] = $this->hydrators->getObjectMapperOperationLicensesCbLicenseRcb();
                }
                $operation = new Operation\Licenses\Get($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Licenses\CbLicenseRcb::class], $params['license']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\License|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Markdown\Render::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Markdown::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Markdown::class] = $this->hydrators->getObjectMapperOperationMarkdown();
                }
                $operation = new Operation\Markdown\Render($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Markdown::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Gitignore\GetAllTemplates\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Markdown\RenderRaw::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Markdown\Raw::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Markdown\Raw::class] = $this->hydrators->getObjectMapperOperationMarkdownRaw();
                }
                $operation = new Operation\Markdown\RenderRaw($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Markdown\Raw::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Gitignore\GetAllTemplates\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Meta\Get::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Meta::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Meta::class] = $this->hydrators->getObjectMapperOperationMeta();
                }
                $operation = new Operation\Meta\Get($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Meta::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ApiOverview {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\ListPublicEventsForRepoNetwork::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Networks\CbOwnerRcb\CbRepoRcb\Events::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Networks\CbOwnerRcb\CbRepoRcb\Events::class] = $this->hydrators->getObjectMapperOperationNetworksCbOwnerRcbCbRepoRcbEvents();
                }
                $operation = new Operation\Activity\ListPublicEventsForRepoNetwork($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Networks\CbOwnerRcb\CbRepoRcb\Events::class], $params['owner'], $params['repo'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Event|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\ListNotificationsForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('since', 'before', 'all', 'participating', 'page', 'per_page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Notifications::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Notifications::class] = $this->hydrators->getObjectMapperOperationNotifications();
                }
                $operation = new Operation\Activity\ListNotificationsForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Notifications::class], $params['since'], $params['before'], $params['all'], $params['participating'], $params['page'], $params['per_page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Thread|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\MarkNotificationsAsRead::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Notifications::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Notifications::class] = $this->hydrators->getObjectMapperOperationNotifications();
                }
                $operation = new Operation\Activity\MarkNotificationsAsRead($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Notifications::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Activity\MarkNotificationsAsRead\Response\Applicationjson\H202|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\GetThread::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('thread_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Notifications\Threads\CbThreadIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Notifications\Threads\CbThreadIdRcb::class] = $this->hydrators->getObjectMapperOperationNotificationsThreadsCbThreadIdRcb();
                }
                $operation = new Operation\Activity\GetThread($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Notifications\Threads\CbThreadIdRcb::class], $params['thread_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Thread|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\MarkThreadAsRead::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('thread_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Notifications\Threads\CbThreadIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Notifications\Threads\CbThreadIdRcb::class] = $this->hydrators->getObjectMapperOperationNotificationsThreadsCbThreadIdRcb();
                }
                $operation = new Operation\Activity\MarkThreadAsRead($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Notifications\Threads\CbThreadIdRcb::class], $params['thread_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\GetThreadSubscriptionForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('thread_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Notifications\Threads\CbThreadIdRcb\Subscription::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Notifications\Threads\CbThreadIdRcb\Subscription::class] = $this->hydrators->getObjectMapperOperationNotificationsThreadsCbThreadIdRcbSubscription();
                }
                $operation = new Operation\Activity\GetThreadSubscriptionForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Notifications\Threads\CbThreadIdRcb\Subscription::class], $params['thread_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ThreadSubscription|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\SetThreadSubscription::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('thread_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Notifications\Threads\CbThreadIdRcb\Subscription::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Notifications\Threads\CbThreadIdRcb\Subscription::class] = $this->hydrators->getObjectMapperOperationNotificationsThreadsCbThreadIdRcbSubscription();
                }
                $operation = new Operation\Activity\SetThreadSubscription($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Notifications\Threads\CbThreadIdRcb\Subscription::class], $params['thread_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ThreadSubscription|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\DeleteThreadSubscription::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('thread_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Notifications\Threads\CbThreadIdRcb\Subscription::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Notifications\Threads\CbThreadIdRcb\Subscription::class] = $this->hydrators->getObjectMapperOperationNotificationsThreadsCbThreadIdRcbSubscription();
                }
                $operation = new Operation\Activity\DeleteThreadSubscription($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Notifications\Threads\CbThreadIdRcb\Subscription::class], $params['thread_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Meta\GetOctocat::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('s')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Octocat::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Octocat::class] = $this->hydrators->getObjectMapperOperationOctocat();
                }
                $operation = new Operation\Meta\GetOctocat($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Octocat::class], $params['s']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Gitignore\GetAllTemplates\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\List_::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('since', 'per_page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Organizations::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Organizations::class] = $this->hydrators->getObjectMapperOperationOrganizations();
                }
                $operation = new Operation\Orgs\List_($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Organizations::class], $params['since'], $params['per_page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\OrganizationSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\ListCustomRoles::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('organization_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Organizations\CbOrganizationIdRcb\CustomRoles::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Organizations\CbOrganizationIdRcb\CustomRoles::class] = $this->hydrators->getObjectMapperOperationOrganizationsCbOrganizationIdRcbCustomRoles();
                }
                $operation = new Operation\Orgs\ListCustomRoles($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Organizations\CbOrganizationIdRcb\CustomRoles::class], $params['organization_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Orgs\ListCustomRoles\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\Get::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcb();
                }
                $operation = new Operation\Orgs\Get($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb::class], $params['org']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\OrganizationFull|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\Update::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcb();
                }
                $operation = new Operation\Orgs\Update($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb::class], $params['org']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\OrganizationFull|Schema\Operation\Orgs\Update\Response\Applicationjson\H422|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\GetActionsCacheUsageForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Actions\Cache\Usage::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Cache\Usage::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbActionsCacheUsage();
                }
                $operation = new Operation\Actions\GetActionsCacheUsageForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Cache\Usage::class], $params['org']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ActionsCacheUsageOrgEnterprise {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\GetActionsCacheUsageByRepoForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Actions\Cache\UsageByRepository::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Cache\UsageByRepository::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbActionsCacheUsageByRepository();
                }
                $operation = new Operation\Actions\GetActionsCacheUsageByRepoForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Cache\UsageByRepository::class], $params['org'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Actions\GetActionsCacheUsageByRepoForOrg\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\GetGithubActionsPermissionsOrganization::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Actions\Permissions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Permissions::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbActionsPermissions();
                }
                $operation = new Operation\Actions\GetGithubActionsPermissionsOrganization($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Permissions::class], $params['org']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ActionsOrganizationPermissions {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\SetGithubActionsPermissionsOrganization::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\SetGithubActionsPermissionsOrganization($this->requestSchemaValidator, $params['org']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\ListSelectedRepositoriesEnabledGithubActionsOrganization::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Actions\Permissions\Repositories::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Permissions\Repositories::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbActionsPermissionsRepositories();
                }
                $operation = new Operation\Actions\ListSelectedRepositoriesEnabledGithubActionsOrganization($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Permissions\Repositories::class], $params['org'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Actions\ListSelectedRepositoriesEnabledGithubActionsOrganization\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\SetSelectedRepositoriesEnabledGithubActionsOrganization::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\SetSelectedRepositoriesEnabledGithubActionsOrganization($this->requestSchemaValidator, $params['org']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\EnableSelectedRepositoryGithubActionsOrganization::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'repository_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\EnableSelectedRepositoryGithubActionsOrganization($params['org'], $params['repository_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\DisableSelectedRepositoryGithubActionsOrganization::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'repository_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\DisableSelectedRepositoryGithubActionsOrganization($params['org'], $params['repository_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\GetAllowedActionsOrganization::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Actions\Permissions\SelectedActions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Permissions\SelectedActions::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbActionsPermissionsSelectedActions();
                }
                $operation = new Operation\Actions\GetAllowedActionsOrganization($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Permissions\SelectedActions::class], $params['org']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\SelectedActions {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\SetAllowedActionsOrganization::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\SetAllowedActionsOrganization($this->requestSchemaValidator, $params['org']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\GetGithubActionsDefaultWorkflowPermissionsOrganization::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Actions\Permissions\Workflow::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Permissions\Workflow::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbActionsPermissionsWorkflow();
                }
                $operation = new Operation\Actions\GetGithubActionsDefaultWorkflowPermissionsOrganization($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Permissions\Workflow::class], $params['org']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ActionsGetDefaultWorkflowPermissions {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\SetGithubActionsDefaultWorkflowPermissionsOrganization::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\SetGithubActionsDefaultWorkflowPermissionsOrganization($this->requestSchemaValidator, $params['org']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\ListSelfHostedRunnerGroupsForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'visible_to_repository', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Actions\RunnerGroups::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\RunnerGroups::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbActionsRunnerGroups();
                }
                $operation = new Operation\Actions\ListSelfHostedRunnerGroupsForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\RunnerGroups::class], $params['org'], $params['visible_to_repository'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Actions\ListSelfHostedRunnerGroupsForOrg\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\CreateSelfHostedRunnerGroupForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Actions\RunnerGroups::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\RunnerGroups::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbActionsRunnerGroups();
                }
                $operation = new Operation\Actions\CreateSelfHostedRunnerGroupForOrg($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\RunnerGroups::class], $params['org']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\RunnerGroupsOrg {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\GetSelfHostedRunnerGroupForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'runner_group_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Actions\RunnerDashGroups\CbRunnerGroupIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\RunnerDashGroups\CbRunnerGroupIdRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbActionsRunnerDashGroupsCbRunnerGroupIdRcb();
                }
                $operation = new Operation\Actions\GetSelfHostedRunnerGroupForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\RunnerDashGroups\CbRunnerGroupIdRcb::class], $params['org'], $params['runner_group_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\RunnerGroupsOrg {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\DeleteSelfHostedRunnerGroupFromOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'runner_group_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\DeleteSelfHostedRunnerGroupFromOrg($params['org'], $params['runner_group_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\UpdateSelfHostedRunnerGroupForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'runner_group_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Actions\RunnerDashGroups\CbRunnerGroupIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\RunnerDashGroups\CbRunnerGroupIdRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbActionsRunnerDashGroupsCbRunnerGroupIdRcb();
                }
                $operation = new Operation\Actions\UpdateSelfHostedRunnerGroupForOrg($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\RunnerDashGroups\CbRunnerGroupIdRcb::class], $params['org'], $params['runner_group_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\RunnerGroupsOrg {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\ListRepoAccessToSelfHostedRunnerGroupInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'runner_group_id', 'page', 'per_page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Actions\RunnerDashGroups\CbRunnerGroupIdRcb\Repositories::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\RunnerDashGroups\CbRunnerGroupIdRcb\Repositories::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbActionsRunnerDashGroupsCbRunnerGroupIdRcbRepositories();
                }
                $operation = new Operation\Actions\ListRepoAccessToSelfHostedRunnerGroupInOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\RunnerDashGroups\CbRunnerGroupIdRcb\Repositories::class], $params['org'], $params['runner_group_id'], $params['page'], $params['per_page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Actions\ListRepoAccessToSelfHostedRunnerGroupInOrg\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\SetRepoAccessToSelfHostedRunnerGroupInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'runner_group_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\SetRepoAccessToSelfHostedRunnerGroupInOrg($this->requestSchemaValidator, $params['org'], $params['runner_group_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\AddRepoAccessToSelfHostedRunnerGroupInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'runner_group_id', 'repository_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\AddRepoAccessToSelfHostedRunnerGroupInOrg($params['org'], $params['runner_group_id'], $params['repository_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\RemoveRepoAccessToSelfHostedRunnerGroupInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'runner_group_id', 'repository_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\RemoveRepoAccessToSelfHostedRunnerGroupInOrg($params['org'], $params['runner_group_id'], $params['repository_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\ListSelfHostedRunnersInGroupForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'runner_group_id', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Actions\RunnerDashGroups\CbRunnerGroupIdRcb\Runners::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\RunnerDashGroups\CbRunnerGroupIdRcb\Runners::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbActionsRunnerDashGroupsCbRunnerGroupIdRcbRunners();
                }
                $operation = new Operation\Actions\ListSelfHostedRunnersInGroupForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\RunnerDashGroups\CbRunnerGroupIdRcb\Runners::class], $params['org'], $params['runner_group_id'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\EnterpriseAdmin\ListSelfHostedRunnersInGroupForEnterprise\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\SetSelfHostedRunnersInGroupForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'runner_group_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\SetSelfHostedRunnersInGroupForOrg($this->requestSchemaValidator, $params['org'], $params['runner_group_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\AddSelfHostedRunnerToGroupForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'runner_group_id', 'runner_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\AddSelfHostedRunnerToGroupForOrg($params['org'], $params['runner_group_id'], $params['runner_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\RemoveSelfHostedRunnerFromGroupForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'runner_group_id', 'runner_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\RemoveSelfHostedRunnerFromGroupForOrg($params['org'], $params['runner_group_id'], $params['runner_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\ListSelfHostedRunnersForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Actions\Runners::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Runners::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbActionsRunners();
                }
                $operation = new Operation\Actions\ListSelfHostedRunnersForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Runners::class], $params['org'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Actions\ListSelfHostedRunnersForOrg\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\ListRunnerApplicationsForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Actions\Runners\Downloads::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Runners\Downloads::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbActionsRunnersDownloads();
                }
                $operation = new Operation\Actions\ListRunnerApplicationsForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Runners\Downloads::class], $params['org']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\RunnerApplication {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\CreateRegistrationTokenForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Actions\Runners\RegistrationToken::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Runners\RegistrationToken::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbActionsRunnersRegistrationToken();
                }
                $operation = new Operation\Actions\CreateRegistrationTokenForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Runners\RegistrationToken::class], $params['org']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\AuthenticationToken {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\CreateRemoveTokenForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Actions\Runners\RemoveToken::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Runners\RemoveToken::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbActionsRunnersRemoveToken();
                }
                $operation = new Operation\Actions\CreateRemoveTokenForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Runners\RemoveToken::class], $params['org']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\AuthenticationToken {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\GetSelfHostedRunnerForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'runner_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Actions\Runners\CbRunnerIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Runners\CbRunnerIdRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbActionsRunnersCbRunnerIdRcb();
                }
                $operation = new Operation\Actions\GetSelfHostedRunnerForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Runners\CbRunnerIdRcb::class], $params['org'], $params['runner_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Runner {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\DeleteSelfHostedRunnerFromOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'runner_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\DeleteSelfHostedRunnerFromOrg($params['org'], $params['runner_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\ListLabelsForSelfHostedRunnerForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'runner_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Actions\Runners\CbRunnerIdRcb\Labels::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Runners\CbRunnerIdRcb\Labels::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbActionsRunnersCbRunnerIdRcbLabels();
                }
                $operation = new Operation\Actions\ListLabelsForSelfHostedRunnerForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Runners\CbRunnerIdRcb\Labels::class], $params['org'], $params['runner_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\SetCustomLabelsForSelfHostedRunnerForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'runner_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Actions\Runners\CbRunnerIdRcb\Labels::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Runners\CbRunnerIdRcb\Labels::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbActionsRunnersCbRunnerIdRcbLabels();
                }
                $operation = new Operation\Actions\SetCustomLabelsForSelfHostedRunnerForOrg($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Runners\CbRunnerIdRcb\Labels::class], $params['org'], $params['runner_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationErrorSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\AddCustomLabelsToSelfHostedRunnerForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'runner_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Actions\Runners\CbRunnerIdRcb\Labels::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Runners\CbRunnerIdRcb\Labels::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbActionsRunnersCbRunnerIdRcbLabels();
                }
                $operation = new Operation\Actions\AddCustomLabelsToSelfHostedRunnerForOrg($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Runners\CbRunnerIdRcb\Labels::class], $params['org'], $params['runner_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationErrorSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\RemoveAllCustomLabelsFromSelfHostedRunnerForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'runner_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Actions\Runners\CbRunnerIdRcb\Labels::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Runners\CbRunnerIdRcb\Labels::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbActionsRunnersCbRunnerIdRcbLabels();
                }
                $operation = new Operation\Actions\RemoveAllCustomLabelsFromSelfHostedRunnerForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Runners\CbRunnerIdRcb\Labels::class], $params['org'], $params['runner_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\RemoveCustomLabelFromSelfHostedRunnerForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'runner_id', 'name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Actions\Runners\CbRunnerIdRcb\Labels\CbNameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Runners\CbRunnerIdRcb\Labels\CbNameRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbActionsRunnersCbRunnerIdRcbLabelsCbNameRcb();
                }
                $operation = new Operation\Actions\RemoveCustomLabelFromSelfHostedRunnerForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Runners\CbRunnerIdRcb\Labels\CbNameRcb::class], $params['org'], $params['runner_id'], $params['name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationErrorSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\ListOrgSecrets::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Actions\Secrets::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Secrets::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbActionsSecrets();
                }
                $operation = new Operation\Actions\ListOrgSecrets($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Secrets::class], $params['org'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Actions\ListOrgSecrets\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\GetOrgPublicKey::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Actions\Secrets\PublicKey::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Secrets\PublicKey::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbActionsSecretsPublicKey();
                }
                $operation = new Operation\Actions\GetOrgPublicKey($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Secrets\PublicKey::class], $params['org']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ActionsPublicKey {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\GetOrgSecret::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'secret_name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Actions\Secrets\CbSecretNameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Secrets\CbSecretNameRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbActionsSecretsCbSecretNameRcb();
                }
                $operation = new Operation\Actions\GetOrgSecret($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Secrets\CbSecretNameRcb::class], $params['org'], $params['secret_name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\OrganizationActionsSecret {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\CreateOrUpdateOrgSecret::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'secret_name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Actions\Secrets\CbSecretNameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Secrets\CbSecretNameRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbActionsSecretsCbSecretNameRcb();
                }
                $operation = new Operation\Actions\CreateOrUpdateOrgSecret($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Secrets\CbSecretNameRcb::class], $params['org'], $params['secret_name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\EmptyObject {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\DeleteOrgSecret::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'secret_name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\DeleteOrgSecret($params['org'], $params['secret_name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\ListSelectedReposForOrgSecret::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'secret_name', 'page', 'per_page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Actions\Secrets\CbSecretNameRcb\Repositories::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Secrets\CbSecretNameRcb\Repositories::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbActionsSecretsCbSecretNameRcbRepositories();
                }
                $operation = new Operation\Actions\ListSelectedReposForOrgSecret($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Actions\Secrets\CbSecretNameRcb\Repositories::class], $params['org'], $params['secret_name'], $params['page'], $params['per_page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Actions\ListSelectedReposForOrgSecret\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\SetSelectedReposForOrgSecret::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'secret_name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\SetSelectedReposForOrgSecret($this->requestSchemaValidator, $params['org'], $params['secret_name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\AddSelectedRepoToOrgSecret::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'secret_name', 'repository_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\AddSelectedRepoToOrgSecret($params['org'], $params['secret_name'], $params['repository_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\RemoveSelectedRepoFromOrgSecret::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'secret_name', 'repository_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\RemoveSelectedRepoFromOrgSecret($params['org'], $params['secret_name'], $params['repository_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\GetAuditLog::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'phrase', 'include', 'after', 'before', 'order', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\AuditLog::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\AuditLog::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbAuditLog();
                }
                $operation = new Operation\Orgs\GetAuditLog($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\AuditLog::class], $params['org'], $params['phrase'], $params['include'], $params['after'], $params['before'], $params['order'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\AuditLogEvent {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\CodeScanning\ListAlertsForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'tool_name', 'tool_guid', 'before', 'after', 'state', 'page', 'per_page', 'direction', 'sort')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\CodeScanning\Alerts::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\CodeScanning\Alerts::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbCodeScanningAlerts();
                }
                $operation = new Operation\CodeScanning\ListAlertsForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\CodeScanning\Alerts::class], $params['org'], $params['tool_name'], $params['tool_guid'], $params['before'], $params['after'], $params['state'], $params['page'], $params['per_page'], $params['direction'], $params['sort']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\CodeScanningOrganizationAlertItems|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Dependabot\ListOrgSecrets::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Dependabot\Secrets::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Dependabot\Secrets::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbDependabotSecrets();
                }
                $operation = new Operation\Dependabot\ListOrgSecrets($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Dependabot\Secrets::class], $params['org'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Dependabot\ListOrgSecrets\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Dependabot\GetOrgPublicKey::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Dependabot\Secrets\PublicKey::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Dependabot\Secrets\PublicKey::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbDependabotSecretsPublicKey();
                }
                $operation = new Operation\Dependabot\GetOrgPublicKey($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Dependabot\Secrets\PublicKey::class], $params['org']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\DependabotPublicKey {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Dependabot\GetOrgSecret::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'secret_name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Dependabot\Secrets\CbSecretNameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Dependabot\Secrets\CbSecretNameRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbDependabotSecretsCbSecretNameRcb();
                }
                $operation = new Operation\Dependabot\GetOrgSecret($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Dependabot\Secrets\CbSecretNameRcb::class], $params['org'], $params['secret_name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\OrganizationDependabotSecret {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Dependabot\CreateOrUpdateOrgSecret::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'secret_name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Dependabot\Secrets\CbSecretNameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Dependabot\Secrets\CbSecretNameRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbDependabotSecretsCbSecretNameRcb();
                }
                $operation = new Operation\Dependabot\CreateOrUpdateOrgSecret($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Dependabot\Secrets\CbSecretNameRcb::class], $params['org'], $params['secret_name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\EmptyObject {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Dependabot\DeleteOrgSecret::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'secret_name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Dependabot\DeleteOrgSecret($params['org'], $params['secret_name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Dependabot\ListSelectedReposForOrgSecret::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'secret_name', 'page', 'per_page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Dependabot\Secrets\CbSecretNameRcb\Repositories::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Dependabot\Secrets\CbSecretNameRcb\Repositories::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbDependabotSecretsCbSecretNameRcbRepositories();
                }
                $operation = new Operation\Dependabot\ListSelectedReposForOrgSecret($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Dependabot\Secrets\CbSecretNameRcb\Repositories::class], $params['org'], $params['secret_name'], $params['page'], $params['per_page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Actions\ListSelectedReposForOrgSecret\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Dependabot\SetSelectedReposForOrgSecret::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'secret_name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Dependabot\SetSelectedReposForOrgSecret($this->requestSchemaValidator, $params['org'], $params['secret_name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Dependabot\AddSelectedRepoToOrgSecret::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'secret_name', 'repository_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Dependabot\AddSelectedRepoToOrgSecret($params['org'], $params['secret_name'], $params['repository_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Dependabot\RemoveSelectedRepoFromOrgSecret::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'secret_name', 'repository_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Dependabot\RemoveSelectedRepoFromOrgSecret($params['org'], $params['secret_name'], $params['repository_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\ListPublicOrgEvents::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Events::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Events::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbEvents();
                }
                $operation = new Operation\Activity\ListPublicOrgEvents($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Events::class], $params['org'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Event {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\ExternalIdpGroupInfoForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'group_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\ExternalDashGroup\CbGroupIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\ExternalDashGroup\CbGroupIdRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbExternalDashGroupCbGroupIdRcb();
                }
                $operation = new Operation\Teams\ExternalIdpGroupInfoForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\ExternalDashGroup\CbGroupIdRcb::class], $params['org'], $params['group_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ExternalGroup {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\ListExternalIdpGroupsForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'page', 'display_name', 'per_page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\ExternalGroups::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\ExternalGroups::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbExternalGroups();
                }
                $operation = new Operation\Teams\ListExternalIdpGroupsForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\ExternalGroups::class], $params['org'], $params['page'], $params['display_name'], $params['per_page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ExternalGroups {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\ListWebhooks::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Hooks::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Hooks::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbHooks();
                }
                $operation = new Operation\Orgs\ListWebhooks($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Hooks::class], $params['org'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\OrgHook|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\CreateWebhook::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Hooks::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Hooks::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbHooks();
                }
                $operation = new Operation\Orgs\CreateWebhook($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Hooks::class], $params['org']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\OrgHook|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\GetWebhook::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'hook_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Hooks\CbHookIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Hooks\CbHookIdRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbHooksCbHookIdRcb();
                }
                $operation = new Operation\Orgs\GetWebhook($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Hooks\CbHookIdRcb::class], $params['org'], $params['hook_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\OrgHook|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\DeleteWebhook::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'hook_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Hooks\CbHookIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Hooks\CbHookIdRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbHooksCbHookIdRcb();
                }
                $operation = new Operation\Orgs\DeleteWebhook($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Hooks\CbHookIdRcb::class], $params['org'], $params['hook_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\UpdateWebhook::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'hook_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Hooks\CbHookIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Hooks\CbHookIdRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbHooksCbHookIdRcb();
                }
                $operation = new Operation\Orgs\UpdateWebhook($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Hooks\CbHookIdRcb::class], $params['org'], $params['hook_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\OrgHook|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\GetWebhookConfigForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'hook_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Hooks\CbHookIdRcb\Config::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Hooks\CbHookIdRcb\Config::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbHooksCbHookIdRcbConfig();
                }
                $operation = new Operation\Orgs\GetWebhookConfigForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Hooks\CbHookIdRcb\Config::class], $params['org'], $params['hook_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\WebhookConfig {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\UpdateWebhookConfigForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'hook_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Hooks\CbHookIdRcb\Config::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Hooks\CbHookIdRcb\Config::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbHooksCbHookIdRcbConfig();
                }
                $operation = new Operation\Orgs\UpdateWebhookConfigForOrg($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Hooks\CbHookIdRcb\Config::class], $params['org'], $params['hook_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\WebhookConfig {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\ListWebhookDeliveries::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'hook_id', 'cursor', 'redelivery', 'per_page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Hooks\CbHookIdRcb\Deliveries::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Hooks\CbHookIdRcb\Deliveries::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbHooksCbHookIdRcbDeliveries();
                }
                $operation = new Operation\Orgs\ListWebhookDeliveries($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Hooks\CbHookIdRcb\Deliveries::class], $params['org'], $params['hook_id'], $params['cursor'], $params['redelivery'], $params['per_page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\HookDeliveryItem|Schema\BasicError|Schema\ScimError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\GetWebhookDelivery::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'hook_id', 'delivery_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Hooks\CbHookIdRcb\Deliveries\CbDeliveryIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Hooks\CbHookIdRcb\Deliveries\CbDeliveryIdRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbHooksCbHookIdRcbDeliveriesCbDeliveryIdRcb();
                }
                $operation = new Operation\Orgs\GetWebhookDelivery($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Hooks\CbHookIdRcb\Deliveries\CbDeliveryIdRcb::class], $params['org'], $params['hook_id'], $params['delivery_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\HookDelivery|Schema\BasicError|Schema\ScimError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\RedeliverWebhookDelivery::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'hook_id', 'delivery_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Hooks\CbHookIdRcb\Deliveries\CbDeliveryIdRcb\Attempts::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Hooks\CbHookIdRcb\Deliveries\CbDeliveryIdRcb\Attempts::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbHooksCbHookIdRcbDeliveriesCbDeliveryIdRcbAttempts();
                }
                $operation = new Operation\Orgs\RedeliverWebhookDelivery($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Hooks\CbHookIdRcb\Deliveries\CbDeliveryIdRcb\Attempts::class], $params['org'], $params['hook_id'], $params['delivery_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\AuditLogEvent\Config|Schema\BasicError|Schema\ScimError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\PingWebhook::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'hook_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Hooks\CbHookIdRcb\Pings::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Hooks\CbHookIdRcb\Pings::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbHooksCbHookIdRcbPings();
                }
                $operation = new Operation\Orgs\PingWebhook($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Hooks\CbHookIdRcb\Pings::class], $params['org'], $params['hook_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Apps\GetOrgInstallation::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Installation::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Installation::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbInstallation();
                }
                $operation = new Operation\Apps\GetOrgInstallation($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Installation::class], $params['org']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Installation {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\ListAppInstallations::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Installations::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Installations::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbInstallations();
                }
                $operation = new Operation\Orgs\ListAppInstallations($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Installations::class], $params['org'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Orgs\ListAppInstallations\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\ListForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'labels', 'since', 'filter', 'state', 'sort', 'direction', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Issues::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Issues::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbIssues();
                }
                $operation = new Operation\Issues\ListForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Issues::class], $params['org'], $params['labels'], $params['since'], $params['filter'], $params['state'], $params['sort'], $params['direction'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Issue|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\ListMembers::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'filter', 'role', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Members::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Members::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbMembers();
                }
                $operation = new Operation\Orgs\ListMembers($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Members::class], $params['org'], $params['filter'], $params['role'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\SimpleUser|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\CheckMembershipForUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Orgs\CheckMembershipForUser($params['org'], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\RemoveMember::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Members\CbUsernameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Members\CbUsernameRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbMembersCbUsernameRcb();
                }
                $operation = new Operation\Orgs\RemoveMember($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Members\CbUsernameRcb::class], $params['org'], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\GetMembershipForUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Memberships\CbUsernameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Memberships\CbUsernameRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbMembershipsCbUsernameRcb();
                }
                $operation = new Operation\Orgs\GetMembershipForUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Memberships\CbUsernameRcb::class], $params['org'], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\OrgMembership|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\SetMembershipForUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Memberships\CbUsernameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Memberships\CbUsernameRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbMembershipsCbUsernameRcb();
                }
                $operation = new Operation\Orgs\SetMembershipForUser($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Memberships\CbUsernameRcb::class], $params['org'], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\OrgMembership|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\RemoveMembershipForUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Memberships\CbUsernameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Memberships\CbUsernameRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbMembershipsCbUsernameRcb();
                }
                $operation = new Operation\Orgs\RemoveMembershipForUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Memberships\CbUsernameRcb::class], $params['org'], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Migrations\ListForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'exclude', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Migrations::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Migrations::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbMigrations();
                }
                $operation = new Operation\Migrations\ListForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Migrations::class], $params['org'], $params['exclude'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Migration {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Migrations\StartForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Migrations::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Migrations::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbMigrations();
                }
                $operation = new Operation\Migrations\StartForOrg($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Migrations::class], $params['org']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Migration|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Migrations\GetStatusForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'migration_id', 'exclude')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Migrations\CbMigrationIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Migrations\CbMigrationIdRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbMigrationsCbMigrationIdRcb();
                }
                $operation = new Operation\Migrations\GetStatusForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Migrations\CbMigrationIdRcb::class], $params['org'], $params['migration_id'], $params['exclude']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Migration|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Migrations\DownloadArchiveForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'migration_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Migrations\CbMigrationIdRcb\Archive::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Migrations\CbMigrationIdRcb\Archive::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbMigrationsCbMigrationIdRcbArchive();
                }
                $operation = new Operation\Migrations\DownloadArchiveForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Migrations\CbMigrationIdRcb\Archive::class], $params['org'], $params['migration_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Migrations\DeleteArchiveForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'migration_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Migrations\CbMigrationIdRcb\Archive::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Migrations\CbMigrationIdRcb\Archive::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbMigrationsCbMigrationIdRcbArchive();
                }
                $operation = new Operation\Migrations\DeleteArchiveForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Migrations\CbMigrationIdRcb\Archive::class], $params['org'], $params['migration_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Migrations\UnlockRepoForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'migration_id', 'repo_name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Migrations\CbMigrationIdRcb\Repos\CbRepoNameRcb\Lock::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Migrations\CbMigrationIdRcb\Repos\CbRepoNameRcb\Lock::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbMigrationsCbMigrationIdRcbReposCbRepoNameRcbLock();
                }
                $operation = new Operation\Migrations\UnlockRepoForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Migrations\CbMigrationIdRcb\Repos\CbRepoNameRcb\Lock::class], $params['org'], $params['migration_id'], $params['repo_name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Migrations\ListReposForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'migration_id', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Migrations\CbMigrationIdRcb\Repositories::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Migrations\CbMigrationIdRcb\Repositories::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbMigrationsCbMigrationIdRcbRepositories();
                }
                $operation = new Operation\Migrations\ListReposForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Migrations\CbMigrationIdRcb\Repositories::class], $params['org'], $params['migration_id'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\MinimalRepository|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\ListOutsideCollaborators::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'filter', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\OutsideCollaborators::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\OutsideCollaborators::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbOutsideCollaborators();
                }
                $operation = new Operation\Orgs\ListOutsideCollaborators($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\OutsideCollaborators::class], $params['org'], $params['filter'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\SimpleUser {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\ConvertMemberToOutsideCollaborator::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\OutsideCollaborators\CbUsernameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\OutsideCollaborators\CbUsernameRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbOutsideCollaboratorsCbUsernameRcb();
                }
                $operation = new Operation\Orgs\ConvertMemberToOutsideCollaborator($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\OutsideCollaborators\CbUsernameRcb::class], $params['org'], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Gists\CheckIsStarred\Response\Applicationjson\H404|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\RemoveOutsideCollaborator::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\OutsideCollaborators\CbUsernameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\OutsideCollaborators\CbUsernameRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbOutsideCollaboratorsCbUsernameRcb();
                }
                $operation = new Operation\Orgs\RemoveOutsideCollaborator($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\OutsideCollaborators\CbUsernameRcb::class], $params['org'], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Orgs\RemoveOutsideCollaborator\Response\Applicationjson\H422 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\ListPreReceiveHooksForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'per_page', 'page', 'direction', 'sort')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\PreReceiveHooks::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\PreReceiveHooks::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbPreReceiveHooks();
                }
                $operation = new Operation\EnterpriseAdmin\ListPreReceiveHooksForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\PreReceiveHooks::class], $params['org'], $params['per_page'], $params['page'], $params['direction'], $params['sort']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\OrgPreReceiveHook {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\GetPreReceiveHookForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'pre_receive_hook_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\PreDashReceiveDashHooks\CbPreReceiveHookIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\PreDashReceiveDashHooks\CbPreReceiveHookIdRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbPreDashReceiveDashHooksCbPreReceiveHookIdRcb();
                }
                $operation = new Operation\EnterpriseAdmin\GetPreReceiveHookForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\PreDashReceiveDashHooks\CbPreReceiveHookIdRcb::class], $params['org'], $params['pre_receive_hook_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\OrgPreReceiveHook {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\RemovePreReceiveHookEnforcementForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'pre_receive_hook_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\PreDashReceiveDashHooks\CbPreReceiveHookIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\PreDashReceiveDashHooks\CbPreReceiveHookIdRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbPreDashReceiveDashHooksCbPreReceiveHookIdRcb();
                }
                $operation = new Operation\EnterpriseAdmin\RemovePreReceiveHookEnforcementForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\PreDashReceiveDashHooks\CbPreReceiveHookIdRcb::class], $params['org'], $params['pre_receive_hook_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\OrgPreReceiveHook {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\UpdatePreReceiveHookEnforcementForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'pre_receive_hook_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\PreDashReceiveDashHooks\CbPreReceiveHookIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\PreDashReceiveDashHooks\CbPreReceiveHookIdRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbPreDashReceiveDashHooksCbPreReceiveHookIdRcb();
                }
                $operation = new Operation\EnterpriseAdmin\UpdatePreReceiveHookEnforcementForOrg($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\PreDashReceiveDashHooks\CbPreReceiveHookIdRcb::class], $params['org'], $params['pre_receive_hook_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\OrgPreReceiveHook {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Projects\ListForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'state', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Projects::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Projects::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbProjects();
                }
                $operation = new Operation\Projects\ListForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Projects::class], $params['org'], $params['state'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Project|Schema\ValidationErrorSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Projects\CreateForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Projects::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Projects::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbProjects();
                }
                $operation = new Operation\Projects\CreateForOrg($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Projects::class], $params['org']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Project|Schema\BasicError|Schema\ValidationErrorSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\ListPublicMembers::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\PublicMembers::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\PublicMembers::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbPublicMembers();
                }
                $operation = new Operation\Orgs\ListPublicMembers($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\PublicMembers::class], $params['org'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\SimpleUser {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\CheckPublicMembershipForUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Orgs\CheckPublicMembershipForUser($params['org'], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\SetPublicMembershipForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\PublicMembers\CbUsernameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\PublicMembers\CbUsernameRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbPublicMembersCbUsernameRcb();
                }
                $operation = new Operation\Orgs\SetPublicMembershipForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\PublicMembers\CbUsernameRcb::class], $params['org'], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\RemovePublicMembershipForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Orgs\RemovePublicMembershipForAuthenticatedUser($params['org'], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'type', 'direction', 'sort', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Repos::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Repos::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbRepos();
                }
                $operation = new Operation\Repos\ListForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Repos::class], $params['org'], $params['type'], $params['direction'], $params['sort'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\MinimalRepository {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\CreateInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Repos::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Repos::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbRepos();
                }
                $operation = new Operation\Repos\CreateInOrg($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Repos::class], $params['org']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Repository|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\SecretScanning\ListAlertsForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'state', 'secret_type', 'resolution', 'sort', 'direction', 'page', 'per_page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\SecretScanning\Alerts::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\SecretScanning\Alerts::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbSecretScanningAlerts();
                }
                $operation = new Operation\SecretScanning\ListAlertsForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\SecretScanning\Alerts::class], $params['org'], $params['state'], $params['secret_type'], $params['resolution'], $params['sort'], $params['direction'], $params['page'], $params['per_page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\OrganizationSecretScanningAlert|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Billing\GetGithubAdvancedSecurityBillingOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Settings\Billing\AdvancedSecurity::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Settings\Billing\AdvancedSecurity::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbSettingsBillingAdvancedSecurity();
                }
                $operation = new Operation\Billing\GetGithubAdvancedSecurityBillingOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Settings\Billing\AdvancedSecurity::class], $params['org'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\AdvancedSecurityActiveCommitters|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\List_::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Teams::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbTeams();
                }
                $operation = new Operation\Teams\List_($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams::class], $params['org'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Team|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\Create::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Teams::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbTeams();
                }
                $operation = new Operation\Teams\Create($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams::class], $params['org']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamFull|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\GetByName::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbTeamsCbTeamSlugRcb();
                }
                $operation = new Operation\Teams\GetByName($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb::class], $params['org'], $params['team_slug']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamFull|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\DeleteInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Teams\DeleteInOrg($params['org'], $params['team_slug']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\UpdateInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbTeamsCbTeamSlugRcb();
                }
                $operation = new Operation\Teams\UpdateInOrg($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb::class], $params['org'], $params['team_slug']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamFull|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\ListDiscussionsInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug', 'pinned', 'direction', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbTeamsCbTeamSlugRcbDiscussions();
                }
                $operation = new Operation\Teams\ListDiscussionsInOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions::class], $params['org'], $params['team_slug'], $params['pinned'], $params['direction'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamDiscussion {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\CreateDiscussionInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbTeamsCbTeamSlugRcbDiscussions();
                }
                $operation = new Operation\Teams\CreateDiscussionInOrg($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions::class], $params['org'], $params['team_slug']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamDiscussion {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\GetDiscussionInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug', 'discussion_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions\CbDiscussionNumberRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions\CbDiscussionNumberRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbTeamsCbTeamSlugRcbDiscussionsCbDiscussionNumberRcb();
                }
                $operation = new Operation\Teams\GetDiscussionInOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions\CbDiscussionNumberRcb::class], $params['org'], $params['team_slug'], $params['discussion_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamDiscussion {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\DeleteDiscussionInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug', 'discussion_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Teams\DeleteDiscussionInOrg($params['org'], $params['team_slug'], $params['discussion_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\UpdateDiscussionInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug', 'discussion_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions\CbDiscussionNumberRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions\CbDiscussionNumberRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbTeamsCbTeamSlugRcbDiscussionsCbDiscussionNumberRcb();
                }
                $operation = new Operation\Teams\UpdateDiscussionInOrg($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions\CbDiscussionNumberRcb::class], $params['org'], $params['team_slug'], $params['discussion_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamDiscussion {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\ListDiscussionCommentsInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug', 'discussion_number', 'direction', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions\CbDiscussionNumberRcb\Comments::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions\CbDiscussionNumberRcb\Comments::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbTeamsCbTeamSlugRcbDiscussionsCbDiscussionNumberRcbComments();
                }
                $operation = new Operation\Teams\ListDiscussionCommentsInOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions\CbDiscussionNumberRcb\Comments::class], $params['org'], $params['team_slug'], $params['discussion_number'], $params['direction'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamDiscussionComment {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\CreateDiscussionCommentInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug', 'discussion_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions\CbDiscussionNumberRcb\Comments::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions\CbDiscussionNumberRcb\Comments::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbTeamsCbTeamSlugRcbDiscussionsCbDiscussionNumberRcbComments();
                }
                $operation = new Operation\Teams\CreateDiscussionCommentInOrg($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions\CbDiscussionNumberRcb\Comments::class], $params['org'], $params['team_slug'], $params['discussion_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamDiscussionComment {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\GetDiscussionCommentInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug', 'discussion_number', 'comment_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions\CbDiscussionNumberRcb\Comments\CbCommentNumberRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions\CbDiscussionNumberRcb\Comments\CbCommentNumberRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbTeamsCbTeamSlugRcbDiscussionsCbDiscussionNumberRcbCommentsCbCommentNumberRcb();
                }
                $operation = new Operation\Teams\GetDiscussionCommentInOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions\CbDiscussionNumberRcb\Comments\CbCommentNumberRcb::class], $params['org'], $params['team_slug'], $params['discussion_number'], $params['comment_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamDiscussionComment {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\DeleteDiscussionCommentInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug', 'discussion_number', 'comment_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Teams\DeleteDiscussionCommentInOrg($params['org'], $params['team_slug'], $params['discussion_number'], $params['comment_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\UpdateDiscussionCommentInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug', 'discussion_number', 'comment_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions\CbDiscussionNumberRcb\Comments\CbCommentNumberRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions\CbDiscussionNumberRcb\Comments\CbCommentNumberRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbTeamsCbTeamSlugRcbDiscussionsCbDiscussionNumberRcbCommentsCbCommentNumberRcb();
                }
                $operation = new Operation\Teams\UpdateDiscussionCommentInOrg($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions\CbDiscussionNumberRcb\Comments\CbCommentNumberRcb::class], $params['org'], $params['team_slug'], $params['discussion_number'], $params['comment_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamDiscussionComment {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Reactions\ListForTeamDiscussionCommentInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug', 'discussion_number', 'comment_number', 'content', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions\CbDiscussionNumberRcb\Comments\CbCommentNumberRcb\Reactions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions\CbDiscussionNumberRcb\Comments\CbCommentNumberRcb\Reactions::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbTeamsCbTeamSlugRcbDiscussionsCbDiscussionNumberRcbCommentsCbCommentNumberRcbReactions();
                }
                $operation = new Operation\Reactions\ListForTeamDiscussionCommentInOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions\CbDiscussionNumberRcb\Comments\CbCommentNumberRcb\Reactions::class], $params['org'], $params['team_slug'], $params['discussion_number'], $params['comment_number'], $params['content'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Reaction {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Reactions\CreateForTeamDiscussionCommentInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug', 'discussion_number', 'comment_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions\CbDiscussionNumberRcb\Comments\CbCommentNumberRcb\Reactions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions\CbDiscussionNumberRcb\Comments\CbCommentNumberRcb\Reactions::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbTeamsCbTeamSlugRcbDiscussionsCbDiscussionNumberRcbCommentsCbCommentNumberRcbReactions();
                }
                $operation = new Operation\Reactions\CreateForTeamDiscussionCommentInOrg($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions\CbDiscussionNumberRcb\Comments\CbCommentNumberRcb\Reactions::class], $params['org'], $params['team_slug'], $params['discussion_number'], $params['comment_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Reaction {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Reactions\DeleteForTeamDiscussionComment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug', 'discussion_number', 'comment_number', 'reaction_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Reactions\DeleteForTeamDiscussionComment($params['org'], $params['team_slug'], $params['discussion_number'], $params['comment_number'], $params['reaction_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Reactions\ListForTeamDiscussionInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug', 'discussion_number', 'content', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions\CbDiscussionNumberRcb\Reactions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions\CbDiscussionNumberRcb\Reactions::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbTeamsCbTeamSlugRcbDiscussionsCbDiscussionNumberRcbReactions();
                }
                $operation = new Operation\Reactions\ListForTeamDiscussionInOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions\CbDiscussionNumberRcb\Reactions::class], $params['org'], $params['team_slug'], $params['discussion_number'], $params['content'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Reaction {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Reactions\CreateForTeamDiscussionInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug', 'discussion_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions\CbDiscussionNumberRcb\Reactions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions\CbDiscussionNumberRcb\Reactions::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbTeamsCbTeamSlugRcbDiscussionsCbDiscussionNumberRcbReactions();
                }
                $operation = new Operation\Reactions\CreateForTeamDiscussionInOrg($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Discussions\CbDiscussionNumberRcb\Reactions::class], $params['org'], $params['team_slug'], $params['discussion_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Reaction {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Reactions\DeleteForTeamDiscussion::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug', 'discussion_number', 'reaction_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Reactions\DeleteForTeamDiscussion($params['org'], $params['team_slug'], $params['discussion_number'], $params['reaction_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\ListLinkedExternalIdpGroupsToTeamForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\ExternalDashGroups::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\ExternalDashGroups::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbTeamsCbTeamSlugRcbExternalDashGroups();
                }
                $operation = new Operation\Teams\ListLinkedExternalIdpGroupsToTeamForOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\ExternalDashGroups::class], $params['org'], $params['team_slug']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ExternalGroups {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\UnlinkExternalIdpGroupFromTeamForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Teams\UnlinkExternalIdpGroupFromTeamForOrg($params['org'], $params['team_slug']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\LinkExternalIdpGroupToTeamForOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\ExternalDashGroups::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\ExternalDashGroups::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbTeamsCbTeamSlugRcbExternalDashGroups();
                }
                $operation = new Operation\Teams\LinkExternalIdpGroupToTeamForOrg($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\ExternalDashGroups::class], $params['org'], $params['team_slug']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ExternalGroup {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\ListMembersInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug', 'role', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Members::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Members::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbTeamsCbTeamSlugRcbMembers();
                }
                $operation = new Operation\Teams\ListMembersInOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Members::class], $params['org'], $params['team_slug'], $params['role'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\SimpleUser {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\GetMembershipForUserInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug', 'username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Memberships\CbUsernameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Memberships\CbUsernameRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbTeamsCbTeamSlugRcbMembershipsCbUsernameRcb();
                }
                $operation = new Operation\Teams\GetMembershipForUserInOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Memberships\CbUsernameRcb::class], $params['org'], $params['team_slug'], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamMembership {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\AddOrUpdateMembershipForUserInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug', 'username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Memberships\CbUsernameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Memberships\CbUsernameRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbTeamsCbTeamSlugRcbMembershipsCbUsernameRcb();
                }
                $operation = new Operation\Teams\AddOrUpdateMembershipForUserInOrg($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Memberships\CbUsernameRcb::class], $params['org'], $params['team_slug'], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamMembership {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\RemoveMembershipForUserInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug', 'username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Teams\RemoveMembershipForUserInOrg($params['org'], $params['team_slug'], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\ListProjectsInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Projects::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Projects::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbTeamsCbTeamSlugRcbProjects();
                }
                $operation = new Operation\Teams\ListProjectsInOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Projects::class], $params['org'], $params['team_slug'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamProject {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\CheckPermissionsForProjectInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug', 'project_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Projects\CbProjectIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Projects\CbProjectIdRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbTeamsCbTeamSlugRcbProjectsCbProjectIdRcb();
                }
                $operation = new Operation\Teams\CheckPermissionsForProjectInOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Projects\CbProjectIdRcb::class], $params['org'], $params['team_slug'], $params['project_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamProject {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\AddOrUpdateProjectPermissionsInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug', 'project_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Projects\CbProjectIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Projects\CbProjectIdRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbTeamsCbTeamSlugRcbProjectsCbProjectIdRcb();
                }
                $operation = new Operation\Teams\AddOrUpdateProjectPermissionsInOrg($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Projects\CbProjectIdRcb::class], $params['org'], $params['team_slug'], $params['project_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Orgs\RemoveOutsideCollaborator\Response\Applicationjson\H422 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\RemoveProjectInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug', 'project_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Teams\RemoveProjectInOrg($params['org'], $params['team_slug'], $params['project_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\ListReposInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Repos::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Repos::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbTeamsCbTeamSlugRcbRepos();
                }
                $operation = new Operation\Teams\ListReposInOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Repos::class], $params['org'], $params['team_slug'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\MinimalRepository {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\CheckPermissionsForRepoInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug', 'owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Repos\CbOwnerRcb\CbRepoRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Repos\CbOwnerRcb\CbRepoRcb::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbTeamsCbTeamSlugRcbReposCbOwnerRcbCbRepoRcb();
                }
                $operation = new Operation\Teams\CheckPermissionsForRepoInOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Repos\CbOwnerRcb\CbRepoRcb::class], $params['org'], $params['team_slug'], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamRepository {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\AddOrUpdateRepoPermissionsInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug', 'owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Teams\AddOrUpdateRepoPermissionsInOrg($this->requestSchemaValidator, $params['org'], $params['team_slug'], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\RemoveRepoInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug', 'owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Teams\RemoveRepoInOrg($params['org'], $params['team_slug'], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\ListChildInOrg::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org', 'team_slug', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Teams::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Teams::class] = $this->hydrators->getObjectMapperOperationOrgsCbOrgRcbTeamsCbTeamSlugRcbTeams();
                }
                $operation = new Operation\Teams\ListChildInOrg($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Orgs\CbOrgRcb\Teams\CbTeamSlugRcb\Teams::class], $params['org'], $params['team_slug'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Team {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Projects\GetCard::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('card_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Projects\Columns\Cards\CbCardIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Projects\Columns\Cards\CbCardIdRcb::class] = $this->hydrators->getObjectMapperOperationProjectsColumnsCardsCbCardIdRcb();
                }
                $operation = new Operation\Projects\GetCard($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Projects\Columns\Cards\CbCardIdRcb::class], $params['card_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ProjectCard|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Projects\DeleteCard::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('card_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Projects\Columns\Cards\CbCardIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Projects\Columns\Cards\CbCardIdRcb::class] = $this->hydrators->getObjectMapperOperationProjectsColumnsCardsCbCardIdRcb();
                }
                $operation = new Operation\Projects\DeleteCard($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Projects\Columns\Cards\CbCardIdRcb::class], $params['card_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Projects\DeleteCard\Response\Applicationjson\H403|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Projects\UpdateCard::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('card_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Projects\Columns\Cards\CbCardIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Projects\Columns\Cards\CbCardIdRcb::class] = $this->hydrators->getObjectMapperOperationProjectsColumnsCardsCbCardIdRcb();
                }
                $operation = new Operation\Projects\UpdateCard($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Projects\Columns\Cards\CbCardIdRcb::class], $params['card_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ProjectCard|Schema\BasicError|Schema\ValidationErrorSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Projects\MoveCard::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('card_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Projects\Columns\Cards\CbCardIdRcb\Moves::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Projects\Columns\Cards\CbCardIdRcb\Moves::class] = $this->hydrators->getObjectMapperOperationProjectsColumnsCardsCbCardIdRcbMoves();
                }
                $operation = new Operation\Projects\MoveCard($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Projects\Columns\Cards\CbCardIdRcb\Moves::class], $params['card_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Gists\CheckIsStarred\Response\Applicationjson\H404|Schema\Operation\Projects\MoveCard\Response\Applicationjson\H403|Schema\BasicError|Schema\Operation\Projects\MoveCard\Response\Applicationjson\H503|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Projects\GetColumn::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('column_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Projects\Columns\CbColumnIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Projects\Columns\CbColumnIdRcb::class] = $this->hydrators->getObjectMapperOperationProjectsColumnsCbColumnIdRcb();
                }
                $operation = new Operation\Projects\GetColumn($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Projects\Columns\CbColumnIdRcb::class], $params['column_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ProjectColumn|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Projects\DeleteColumn::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('column_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Projects\Columns\CbColumnIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Projects\Columns\CbColumnIdRcb::class] = $this->hydrators->getObjectMapperOperationProjectsColumnsCbColumnIdRcb();
                }
                $operation = new Operation\Projects\DeleteColumn($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Projects\Columns\CbColumnIdRcb::class], $params['column_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Projects\UpdateColumn::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('column_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Projects\Columns\CbColumnIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Projects\Columns\CbColumnIdRcb::class] = $this->hydrators->getObjectMapperOperationProjectsColumnsCbColumnIdRcb();
                }
                $operation = new Operation\Projects\UpdateColumn($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Projects\Columns\CbColumnIdRcb::class], $params['column_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ProjectColumn|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Projects\ListCards::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('column_id', 'archived_state', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Projects\Columns\CbColumnIdRcb\Cards::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Projects\Columns\CbColumnIdRcb\Cards::class] = $this->hydrators->getObjectMapperOperationProjectsColumnsCbColumnIdRcbCards();
                }
                $operation = new Operation\Projects\ListCards($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Projects\Columns\CbColumnIdRcb\Cards::class], $params['column_id'], $params['archived_state'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ProjectCard|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Projects\CreateCard::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('column_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Projects\Columns\CbColumnIdRcb\Cards::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Projects\Columns\CbColumnIdRcb\Cards::class] = $this->hydrators->getObjectMapperOperationProjectsColumnsCbColumnIdRcbCards();
                }
                $operation = new Operation\Projects\CreateCard($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Projects\Columns\CbColumnIdRcb\Cards::class], $params['column_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ProjectCard|Schema\BasicError|Schema\Operation\Orgs\Update\Response\Applicationjson\H422|Schema\Operation\Projects\MoveCard\Response\Applicationjson\H503 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Projects\MoveColumn::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('column_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Projects\Columns\CbColumnIdRcb\Moves::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Projects\Columns\CbColumnIdRcb\Moves::class] = $this->hydrators->getObjectMapperOperationProjectsColumnsCbColumnIdRcbMoves();
                }
                $operation = new Operation\Projects\MoveColumn($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Projects\Columns\CbColumnIdRcb\Moves::class], $params['column_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Gists\CheckIsStarred\Response\Applicationjson\H404|Schema\BasicError|Schema\ValidationErrorSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Projects\Get::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('project_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Projects\CbProjectIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Projects\CbProjectIdRcb::class] = $this->hydrators->getObjectMapperOperationProjectsCbProjectIdRcb();
                }
                $operation = new Operation\Projects\Get($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Projects\CbProjectIdRcb::class], $params['project_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Project|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Projects\Delete::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('project_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Projects\CbProjectIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Projects\CbProjectIdRcb::class] = $this->hydrators->getObjectMapperOperationProjectsCbProjectIdRcb();
                }
                $operation = new Operation\Projects\Delete($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Projects\CbProjectIdRcb::class], $params['project_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Projects\DeleteCard\Response\Applicationjson\H403|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Projects\Update::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('project_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Projects\CbProjectIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Projects\CbProjectIdRcb::class] = $this->hydrators->getObjectMapperOperationProjectsCbProjectIdRcb();
                }
                $operation = new Operation\Projects\Update($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Projects\CbProjectIdRcb::class], $params['project_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Project|Schema\Operation\Projects\DeleteCard\Response\Applicationjson\H403|Schema\BasicError|Schema\ValidationErrorSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Projects\ListCollaborators::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('project_id', 'affiliation', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Projects\CbProjectIdRcb\Collaborators::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Projects\CbProjectIdRcb\Collaborators::class] = $this->hydrators->getObjectMapperOperationProjectsCbProjectIdRcbCollaborators();
                }
                $operation = new Operation\Projects\ListCollaborators($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Projects\CbProjectIdRcb\Collaborators::class], $params['project_id'], $params['affiliation'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\SimpleUser|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Projects\AddCollaborator::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('project_id', 'username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Projects\CbProjectIdRcb\Collaborators\CbUsernameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Projects\CbProjectIdRcb\Collaborators\CbUsernameRcb::class] = $this->hydrators->getObjectMapperOperationProjectsCbProjectIdRcbCollaboratorsCbUsernameRcb();
                }
                $operation = new Operation\Projects\AddCollaborator($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Projects\CbProjectIdRcb\Collaborators\CbUsernameRcb::class], $params['project_id'], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Projects\RemoveCollaborator::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('project_id', 'username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Projects\CbProjectIdRcb\Collaborators\CbUsernameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Projects\CbProjectIdRcb\Collaborators\CbUsernameRcb::class] = $this->hydrators->getObjectMapperOperationProjectsCbProjectIdRcbCollaboratorsCbUsernameRcb();
                }
                $operation = new Operation\Projects\RemoveCollaborator($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Projects\CbProjectIdRcb\Collaborators\CbUsernameRcb::class], $params['project_id'], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Projects\GetPermissionForUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('project_id', 'username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Projects\CbProjectIdRcb\Collaborators\CbUsernameRcb\Permission::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Projects\CbProjectIdRcb\Collaborators\CbUsernameRcb\Permission::class] = $this->hydrators->getObjectMapperOperationProjectsCbProjectIdRcbCollaboratorsCbUsernameRcbPermission();
                }
                $operation = new Operation\Projects\GetPermissionForUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Projects\CbProjectIdRcb\Collaborators\CbUsernameRcb\Permission::class], $params['project_id'], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ProjectCollaboratorPermission|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Projects\ListColumns::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('project_id', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Projects\CbProjectIdRcb\Columns::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Projects\CbProjectIdRcb\Columns::class] = $this->hydrators->getObjectMapperOperationProjectsCbProjectIdRcbColumns();
                }
                $operation = new Operation\Projects\ListColumns($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Projects\CbProjectIdRcb\Columns::class], $params['project_id'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ProjectColumn|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Projects\CreateColumn::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('project_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Projects\CbProjectIdRcb\Columns::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Projects\CbProjectIdRcb\Columns::class] = $this->hydrators->getObjectMapperOperationProjectsCbProjectIdRcbColumns();
                }
                $operation = new Operation\Projects\CreateColumn($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Projects\CbProjectIdRcb\Columns::class], $params['project_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ProjectColumn|Schema\BasicError|Schema\ValidationErrorSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\RateLimit\Get::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\RateLimit::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\RateLimit::class] = $this->hydrators->getObjectMapperOperationRateLimit();
                }
                $operation = new Operation\RateLimit\Get($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\RateLimit::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\RateLimitOverview|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\Get::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcb();
                }
                $operation = new Operation\Repos\Get($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\FullRepository|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\Delete::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcb();
                }
                $operation = new Operation\Repos\Delete($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Orgs\RemoveOutsideCollaborator\Response\Applicationjson\H422|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\Update::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcb();
                }
                $operation = new Operation\Repos\Update($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\FullRepository|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\ListArtifactsForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'name', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Artifacts::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Artifacts::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsArtifacts();
                }
                $operation = new Operation\Actions\ListArtifactsForRepo($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Artifacts::class], $params['owner'], $params['repo'], $params['name'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Actions\ListArtifactsForRepo\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\GetArtifact::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'artifact_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Artifacts\CbArtifactIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Artifacts\CbArtifactIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsArtifactsCbArtifactIdRcb();
                }
                $operation = new Operation\Actions\GetArtifact($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Artifacts\CbArtifactIdRcb::class], $params['owner'], $params['repo'], $params['artifact_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Artifact {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\DeleteArtifact::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'artifact_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\DeleteArtifact($params['owner'], $params['repo'], $params['artifact_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\DownloadArtifact::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'artifact_id', 'archive_format')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Artifacts\CbArtifactIdRcb\CbArchiveFormatRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Artifacts\CbArtifactIdRcb\CbArchiveFormatRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsArtifactsCbArtifactIdRcbCbArchiveFormatRcb();
                }
                $operation = new Operation\Actions\DownloadArtifact($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Artifacts\CbArtifactIdRcb\CbArchiveFormatRcb::class], $params['owner'], $params['repo'], $params['artifact_id'], $params['archive_format']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\GetActionsCacheUsage::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Cache\Usage::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Cache\Usage::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsCacheUsage();
                }
                $operation = new Operation\Actions\GetActionsCacheUsage($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Cache\Usage::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ActionsCacheUsageByRepository {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\GetActionsCacheUsagePolicy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Cache\UsagePolicy::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Cache\UsagePolicy::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsCacheUsagePolicy();
                }
                $operation = new Operation\Actions\GetActionsCacheUsagePolicy($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Cache\UsagePolicy::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ActionsCacheUsagePolicyForRepository {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\SetActionsCacheUsagePolicy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\SetActionsCacheUsagePolicy($this->requestSchemaValidator, $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\GetJobForWorkflowRun::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'job_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Jobs\CbJobIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Jobs\CbJobIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsJobsCbJobIdRcb();
                }
                $operation = new Operation\Actions\GetJobForWorkflowRun($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Jobs\CbJobIdRcb::class], $params['owner'], $params['repo'], $params['job_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Job {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\DownloadJobLogsForWorkflowRun::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'job_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\DownloadJobLogsForWorkflowRun($params['owner'], $params['repo'], $params['job_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\ReRunJobForWorkflowRun::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'job_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Jobs\CbJobIdRcb\Rerun::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Jobs\CbJobIdRcb\Rerun::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsJobsCbJobIdRcbRerun();
                }
                $operation = new Operation\Actions\ReRunJobForWorkflowRun($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Jobs\CbJobIdRcb\Rerun::class], $params['owner'], $params['repo'], $params['job_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\EmptyObject|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\GetGithubActionsPermissionsRepository::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Permissions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Permissions::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsPermissions();
                }
                $operation = new Operation\Actions\GetGithubActionsPermissionsRepository($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Permissions::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ActionsRepositoryPermissions {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\SetGithubActionsPermissionsRepository::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\SetGithubActionsPermissionsRepository($this->requestSchemaValidator, $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\GetWorkflowAccessToRepository::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Permissions\Access::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Permissions\Access::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsPermissionsAccess();
                }
                $operation = new Operation\Actions\GetWorkflowAccessToRepository($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Permissions\Access::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ActionsWorkflowAccessToRepository {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\SetWorkflowAccessToRepository::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\SetWorkflowAccessToRepository($this->requestSchemaValidator, $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\GetAllowedActionsRepository::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Permissions\SelectedActions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Permissions\SelectedActions::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsPermissionsSelectedActions();
                }
                $operation = new Operation\Actions\GetAllowedActionsRepository($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Permissions\SelectedActions::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\SelectedActions {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\SetAllowedActionsRepository::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\SetAllowedActionsRepository($this->requestSchemaValidator, $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\GetGithubActionsDefaultWorkflowPermissionsRepository::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Permissions\Workflow::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Permissions\Workflow::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsPermissionsWorkflow();
                }
                $operation = new Operation\Actions\GetGithubActionsDefaultWorkflowPermissionsRepository($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Permissions\Workflow::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ActionsGetDefaultWorkflowPermissions {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\SetGithubActionsDefaultWorkflowPermissionsRepository::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\SetGithubActionsDefaultWorkflowPermissionsRepository($this->requestSchemaValidator, $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\ListSelfHostedRunnersForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runners::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runners::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsRunners();
                }
                $operation = new Operation\Actions\ListSelfHostedRunnersForRepo($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runners::class], $params['owner'], $params['repo'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Actions\ListSelfHostedRunnersForOrg\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\ListRunnerApplicationsForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runners\Downloads::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runners\Downloads::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsRunnersDownloads();
                }
                $operation = new Operation\Actions\ListRunnerApplicationsForRepo($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runners\Downloads::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\RunnerApplication {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\CreateRegistrationTokenForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runners\RegistrationToken::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runners\RegistrationToken::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsRunnersRegistrationToken();
                }
                $operation = new Operation\Actions\CreateRegistrationTokenForRepo($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runners\RegistrationToken::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\AuthenticationToken {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\CreateRemoveTokenForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runners\RemoveToken::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runners\RemoveToken::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsRunnersRemoveToken();
                }
                $operation = new Operation\Actions\CreateRemoveTokenForRepo($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runners\RemoveToken::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\AuthenticationToken {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\GetSelfHostedRunnerForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'runner_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runners\CbRunnerIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runners\CbRunnerIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsRunnersCbRunnerIdRcb();
                }
                $operation = new Operation\Actions\GetSelfHostedRunnerForRepo($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runners\CbRunnerIdRcb::class], $params['owner'], $params['repo'], $params['runner_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Runner {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\DeleteSelfHostedRunnerFromRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'runner_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\DeleteSelfHostedRunnerFromRepo($params['owner'], $params['repo'], $params['runner_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\ListLabelsForSelfHostedRunnerForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'runner_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runners\CbRunnerIdRcb\Labels::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runners\CbRunnerIdRcb\Labels::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsRunnersCbRunnerIdRcbLabels();
                }
                $operation = new Operation\Actions\ListLabelsForSelfHostedRunnerForRepo($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runners\CbRunnerIdRcb\Labels::class], $params['owner'], $params['repo'], $params['runner_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\SetCustomLabelsForSelfHostedRunnerForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'runner_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runners\CbRunnerIdRcb\Labels::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runners\CbRunnerIdRcb\Labels::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsRunnersCbRunnerIdRcbLabels();
                }
                $operation = new Operation\Actions\SetCustomLabelsForSelfHostedRunnerForRepo($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runners\CbRunnerIdRcb\Labels::class], $params['owner'], $params['repo'], $params['runner_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationErrorSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\AddCustomLabelsToSelfHostedRunnerForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'runner_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runners\CbRunnerIdRcb\Labels::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runners\CbRunnerIdRcb\Labels::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsRunnersCbRunnerIdRcbLabels();
                }
                $operation = new Operation\Actions\AddCustomLabelsToSelfHostedRunnerForRepo($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runners\CbRunnerIdRcb\Labels::class], $params['owner'], $params['repo'], $params['runner_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationErrorSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\RemoveAllCustomLabelsFromSelfHostedRunnerForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'runner_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runners\CbRunnerIdRcb\Labels::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runners\CbRunnerIdRcb\Labels::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsRunnersCbRunnerIdRcbLabels();
                }
                $operation = new Operation\Actions\RemoveAllCustomLabelsFromSelfHostedRunnerForRepo($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runners\CbRunnerIdRcb\Labels::class], $params['owner'], $params['repo'], $params['runner_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\RemoveCustomLabelFromSelfHostedRunnerForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'runner_id', 'name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runners\CbRunnerIdRcb\Labels\CbNameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runners\CbRunnerIdRcb\Labels\CbNameRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsRunnersCbRunnerIdRcbLabelsCbNameRcb();
                }
                $operation = new Operation\Actions\RemoveCustomLabelFromSelfHostedRunnerForRepo($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runners\CbRunnerIdRcb\Labels\CbNameRcb::class], $params['owner'], $params['repo'], $params['runner_id'], $params['name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\EnterpriseAdmin\ListLabelsForSelfHostedRunnerForEnterprise\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationErrorSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\ListWorkflowRunsForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'actor', 'branch', 'event', 'status', 'created', 'check_suite_id', 'per_page', 'page', 'exclude_pull_requests')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsRuns();
                }
                $operation = new Operation\Actions\ListWorkflowRunsForRepo($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs::class], $params['owner'], $params['repo'], $params['actor'], $params['branch'], $params['event'], $params['status'], $params['created'], $params['check_suite_id'], $params['per_page'], $params['page'], $params['exclude_pull_requests']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Actions\ListWorkflowRunsForRepo\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\GetWorkflowRun::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'run_id', 'exclude_pull_requests')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsRunsCbRunIdRcb();
                }
                $operation = new Operation\Actions\GetWorkflowRun($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb::class], $params['owner'], $params['repo'], $params['run_id'], $params['exclude_pull_requests']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\WorkflowRun {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\DeleteWorkflowRun::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'run_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\DeleteWorkflowRun($params['owner'], $params['repo'], $params['run_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\GetReviewsForRun::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'run_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\Approvals::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\Approvals::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsRunsCbRunIdRcbApprovals();
                }
                $operation = new Operation\Actions\GetReviewsForRun($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\Approvals::class], $params['owner'], $params['repo'], $params['run_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\EnvironmentApprovals {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\ListWorkflowRunArtifacts::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'run_id', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\Artifacts::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\Artifacts::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsRunsCbRunIdRcbArtifacts();
                }
                $operation = new Operation\Actions\ListWorkflowRunArtifacts($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\Artifacts::class], $params['owner'], $params['repo'], $params['run_id'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Actions\ListArtifactsForRepo\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\GetWorkflowRunAttempt::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'run_id', 'attempt_number', 'exclude_pull_requests')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\Attempts\CbAttemptNumberRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\Attempts\CbAttemptNumberRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsRunsCbRunIdRcbAttemptsCbAttemptNumberRcb();
                }
                $operation = new Operation\Actions\GetWorkflowRunAttempt($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\Attempts\CbAttemptNumberRcb::class], $params['owner'], $params['repo'], $params['run_id'], $params['attempt_number'], $params['exclude_pull_requests']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\WorkflowRun {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\ListJobsForWorkflowRunAttempt::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'run_id', 'attempt_number', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\Attempts\CbAttemptNumberRcb\Jobs::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\Attempts\CbAttemptNumberRcb\Jobs::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsRunsCbRunIdRcbAttemptsCbAttemptNumberRcbJobs();
                }
                $operation = new Operation\Actions\ListJobsForWorkflowRunAttempt($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\Attempts\CbAttemptNumberRcb\Jobs::class], $params['owner'], $params['repo'], $params['run_id'], $params['attempt_number'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Actions\ListJobsForWorkflowRunAttempt\Response\Applicationjson\H200|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\DownloadWorkflowRunAttemptLogs::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'run_id', 'attempt_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\DownloadWorkflowRunAttemptLogs($params['owner'], $params['repo'], $params['run_id'], $params['attempt_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\CancelWorkflowRun::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'run_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\Cancel::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\Cancel::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsRunsCbRunIdRcbCancel();
                }
                $operation = new Operation\Actions\CancelWorkflowRun($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\Cancel::class], $params['owner'], $params['repo'], $params['run_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\EmptyObject|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\ListJobsForWorkflowRun::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'run_id', 'filter', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\Jobs::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\Jobs::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsRunsCbRunIdRcbJobs();
                }
                $operation = new Operation\Actions\ListJobsForWorkflowRun($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\Jobs::class], $params['owner'], $params['repo'], $params['run_id'], $params['filter'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Actions\ListJobsForWorkflowRunAttempt\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\DownloadWorkflowRunLogs::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'run_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\DownloadWorkflowRunLogs($params['owner'], $params['repo'], $params['run_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\DeleteWorkflowRunLogs::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'run_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\Logs::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\Logs::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsRunsCbRunIdRcbLogs();
                }
                $operation = new Operation\Actions\DeleteWorkflowRunLogs($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\Logs::class], $params['owner'], $params['repo'], $params['run_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\GetPendingDeploymentsForRun::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'run_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\PendingDeployments::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\PendingDeployments::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsRunsCbRunIdRcbPendingDeployments();
                }
                $operation = new Operation\Actions\GetPendingDeploymentsForRun($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\PendingDeployments::class], $params['owner'], $params['repo'], $params['run_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PendingDeployment {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\ReviewPendingDeploymentsForRun::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'run_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\PendingDeployments::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\PendingDeployments::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsRunsCbRunIdRcbPendingDeployments();
                }
                $operation = new Operation\Actions\ReviewPendingDeploymentsForRun($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\PendingDeployments::class], $params['owner'], $params['repo'], $params['run_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Deployment {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\ReRunWorkflow::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'run_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\Rerun::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\Rerun::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsRunsCbRunIdRcbRerun();
                }
                $operation = new Operation\Actions\ReRunWorkflow($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\Rerun::class], $params['owner'], $params['repo'], $params['run_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\EmptyObject {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\ReRunWorkflowFailedJobs::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'run_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\RerunDashFailedDashJobs::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\RerunDashFailedDashJobs::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsRunsCbRunIdRcbRerunDashFailedDashJobs();
                }
                $operation = new Operation\Actions\ReRunWorkflowFailedJobs($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Runs\CbRunIdRcb\RerunDashFailedDashJobs::class], $params['owner'], $params['repo'], $params['run_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\EmptyObject {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\ListRepoSecrets::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Secrets::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Secrets::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsSecrets();
                }
                $operation = new Operation\Actions\ListRepoSecrets($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Secrets::class], $params['owner'], $params['repo'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Actions\ListRepoSecrets\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\GetRepoPublicKey::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Secrets\PublicKey::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Secrets\PublicKey::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsSecretsPublicKey();
                }
                $operation = new Operation\Actions\GetRepoPublicKey($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Secrets\PublicKey::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ActionsPublicKey {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\GetRepoSecret::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'secret_name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Secrets\CbSecretNameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Secrets\CbSecretNameRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsSecretsCbSecretNameRcb();
                }
                $operation = new Operation\Actions\GetRepoSecret($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Secrets\CbSecretNameRcb::class], $params['owner'], $params['repo'], $params['secret_name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ActionsSecret {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\CreateOrUpdateRepoSecret::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'secret_name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Secrets\CbSecretNameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Secrets\CbSecretNameRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsSecretsCbSecretNameRcb();
                }
                $operation = new Operation\Actions\CreateOrUpdateRepoSecret($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Secrets\CbSecretNameRcb::class], $params['owner'], $params['repo'], $params['secret_name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\EmptyObject {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\DeleteRepoSecret::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'secret_name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\DeleteRepoSecret($params['owner'], $params['repo'], $params['secret_name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\ListRepoWorkflows::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Workflows::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Workflows::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsWorkflows();
                }
                $operation = new Operation\Actions\ListRepoWorkflows($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Workflows::class], $params['owner'], $params['repo'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Actions\ListRepoWorkflows\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\GetWorkflow::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'workflow_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Workflows\CbWorkflowIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Workflows\CbWorkflowIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsWorkflowsCbWorkflowIdRcb();
                }
                $operation = new Operation\Actions\GetWorkflow($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Workflows\CbWorkflowIdRcb::class], $params['owner'], $params['repo'], $params['workflow_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Workflow {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\DisableWorkflow::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'workflow_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\DisableWorkflow($params['owner'], $params['repo'], $params['workflow_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\CreateWorkflowDispatch::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'workflow_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\CreateWorkflowDispatch($this->requestSchemaValidator, $params['owner'], $params['repo'], $params['workflow_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\EnableWorkflow::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'workflow_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\EnableWorkflow($params['owner'], $params['repo'], $params['workflow_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\ListWorkflowRuns::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'workflow_id', 'actor', 'branch', 'event', 'status', 'created', 'check_suite_id', 'per_page', 'page', 'exclude_pull_requests')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Workflows\CbWorkflowIdRcb\Runs::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Workflows\CbWorkflowIdRcb\Runs::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbActionsWorkflowsCbWorkflowIdRcbRuns();
                }
                $operation = new Operation\Actions\ListWorkflowRuns($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Actions\Workflows\CbWorkflowIdRcb\Runs::class], $params['owner'], $params['repo'], $params['workflow_id'], $params['actor'], $params['branch'], $params['event'], $params['status'], $params['created'], $params['check_suite_id'], $params['per_page'], $params['page'], $params['exclude_pull_requests']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Actions\ListWorkflowRunsForRepo\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\ListAssignees::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Assignees::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Assignees::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbAssignees();
                }
                $operation = new Operation\Issues\ListAssignees($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Assignees::class], $params['owner'], $params['repo'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\SimpleUser|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\CheckUserCanBeAssigned::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'assignee')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Assignees\CbAssigneeRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Assignees\CbAssigneeRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbAssigneesCbAssigneeRcb();
                }
                $operation = new Operation\Issues\CheckUserCanBeAssigned($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Assignees\CbAssigneeRcb::class], $params['owner'], $params['repo'], $params['assignee']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListAutolinks::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Autolinks::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Autolinks::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbAutolinks();
                }
                $operation = new Operation\Repos\ListAutolinks($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Autolinks::class], $params['owner'], $params['repo'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Autolink {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\CreateAutolink::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Autolinks::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Autolinks::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbAutolinks();
                }
                $operation = new Operation\Repos\CreateAutolink($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Autolinks::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Autolink|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetAutolink::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'autolink_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Autolinks\CbAutolinkIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Autolinks\CbAutolinkIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbAutolinksCbAutolinkIdRcb();
                }
                $operation = new Operation\Repos\GetAutolink($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Autolinks\CbAutolinkIdRcb::class], $params['owner'], $params['repo'], $params['autolink_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Autolink|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\DeleteAutolink::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'autolink_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Autolinks\CbAutolinkIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Autolinks\CbAutolinkIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbAutolinksCbAutolinkIdRcb();
                }
                $operation = new Operation\Repos\DeleteAutolink($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Autolinks\CbAutolinkIdRcb::class], $params['owner'], $params['repo'], $params['autolink_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListBranches::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'protected', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranches();
                }
                $operation = new Operation\Repos\ListBranches($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches::class], $params['owner'], $params['repo'], $params['protected'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ShortBranch|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetBranch::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcb();
                }
                $operation = new Operation\Repos\GetBranch($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BranchWithProtection|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetBranchProtection::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtection();
                }
                $operation = new Operation\Repos\GetBranchProtection($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BranchProtection|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\UpdateBranchProtection::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtection();
                }
                $operation = new Operation\Repos\UpdateBranchProtection($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ProtectedBranch|Schema\BasicError|Schema\ValidationErrorSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\DeleteBranchProtection::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtection();
                }
                $operation = new Operation\Repos\DeleteBranchProtection($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetAdminBranchProtection::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\EnforceAdmins::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\EnforceAdmins::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtectionEnforceAdmins();
                }
                $operation = new Operation\Repos\GetAdminBranchProtection($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\EnforceAdmins::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ProtectedBranchAdminEnforced {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\SetAdminBranchProtection::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\EnforceAdmins::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\EnforceAdmins::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtectionEnforceAdmins();
                }
                $operation = new Operation\Repos\SetAdminBranchProtection($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\EnforceAdmins::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ProtectedBranchAdminEnforced {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\DeleteAdminBranchProtection::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\EnforceAdmins::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\EnforceAdmins::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtectionEnforceAdmins();
                }
                $operation = new Operation\Repos\DeleteAdminBranchProtection($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\EnforceAdmins::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetPullRequestReviewProtection::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredPullRequestReviews::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredPullRequestReviews::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtectionRequiredPullRequestReviews();
                }
                $operation = new Operation\Repos\GetPullRequestReviewProtection($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredPullRequestReviews::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ProtectedBranchPullRequestReview {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\DeletePullRequestReviewProtection::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredPullRequestReviews::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredPullRequestReviews::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtectionRequiredPullRequestReviews();
                }
                $operation = new Operation\Repos\DeletePullRequestReviewProtection($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredPullRequestReviews::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\UpdatePullRequestReviewProtection::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredPullRequestReviews::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredPullRequestReviews::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtectionRequiredPullRequestReviews();
                }
                $operation = new Operation\Repos\UpdatePullRequestReviewProtection($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredPullRequestReviews::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ProtectedBranchPullRequestReview|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetCommitSignatureProtection::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredSignatures::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredSignatures::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtectionRequiredSignatures();
                }
                $operation = new Operation\Repos\GetCommitSignatureProtection($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredSignatures::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ProtectedBranchAdminEnforced|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\CreateCommitSignatureProtection::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredSignatures::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredSignatures::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtectionRequiredSignatures();
                }
                $operation = new Operation\Repos\CreateCommitSignatureProtection($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredSignatures::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ProtectedBranchAdminEnforced|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\DeleteCommitSignatureProtection::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredSignatures::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredSignatures::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtectionRequiredSignatures();
                }
                $operation = new Operation\Repos\DeleteCommitSignatureProtection($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredSignatures::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetStatusChecksProtection::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredStatusChecks::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredStatusChecks::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtectionRequiredStatusChecks();
                }
                $operation = new Operation\Repos\GetStatusChecksProtection($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredStatusChecks::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\StatusCheckPolicy|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\RemoveStatusCheckProtection::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Repos\RemoveStatusCheckProtection($params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\UpdateStatusCheckProtection::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredStatusChecks::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredStatusChecks::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtectionRequiredStatusChecks();
                }
                $operation = new Operation\Repos\UpdateStatusCheckProtection($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredStatusChecks::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\StatusCheckPolicy|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetAllStatusCheckContexts::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredStatusChecks\Contexts::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredStatusChecks\Contexts::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtectionRequiredStatusChecksContexts();
                }
                $operation = new Operation\Repos\GetAllStatusCheckContexts($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredStatusChecks\Contexts::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Gitignore\GetAllTemplates\Response\Applicationjson\H200|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\SetStatusCheckContexts::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredStatusChecks\Contexts::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredStatusChecks\Contexts::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtectionRequiredStatusChecksContexts();
                }
                $operation = new Operation\Repos\SetStatusCheckContexts($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredStatusChecks\Contexts::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Gitignore\GetAllTemplates\Response\Applicationjson\H200|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\AddStatusCheckContexts::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredStatusChecks\Contexts::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredStatusChecks\Contexts::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtectionRequiredStatusChecksContexts();
                }
                $operation = new Operation\Repos\AddStatusCheckContexts($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredStatusChecks\Contexts::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Gitignore\GetAllTemplates\Response\Applicationjson\H200|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\RemoveStatusCheckContexts::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredStatusChecks\Contexts::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredStatusChecks\Contexts::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtectionRequiredStatusChecksContexts();
                }
                $operation = new Operation\Repos\RemoveStatusCheckContexts($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\RequiredStatusChecks\Contexts::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Gitignore\GetAllTemplates\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetAccessRestrictions::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtectionRestrictions();
                }
                $operation = new Operation\Repos\GetAccessRestrictions($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BranchRestrictionPolicy|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\DeleteAccessRestrictions::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Repos\DeleteAccessRestrictions($params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetAppsWithAccessToProtectedBranch::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Apps::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Apps::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtectionRestrictionsApps();
                }
                $operation = new Operation\Repos\GetAppsWithAccessToProtectedBranch($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Apps::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Integration|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\SetAppAccessRestrictions::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Apps::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Apps::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtectionRestrictionsApps();
                }
                $operation = new Operation\Repos\SetAppAccessRestrictions($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Apps::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Integration|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\AddAppAccessRestrictions::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Apps::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Apps::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtectionRestrictionsApps();
                }
                $operation = new Operation\Repos\AddAppAccessRestrictions($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Apps::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Integration|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\RemoveAppAccessRestrictions::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Apps::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Apps::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtectionRestrictionsApps();
                }
                $operation = new Operation\Repos\RemoveAppAccessRestrictions($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Apps::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Integration|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetTeamsWithAccessToProtectedBranch::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Teams::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Teams::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtectionRestrictionsTeams();
                }
                $operation = new Operation\Repos\GetTeamsWithAccessToProtectedBranch($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Teams::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Team|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\SetTeamAccessRestrictions::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Teams::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Teams::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtectionRestrictionsTeams();
                }
                $operation = new Operation\Repos\SetTeamAccessRestrictions($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Teams::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Team|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\AddTeamAccessRestrictions::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Teams::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Teams::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtectionRestrictionsTeams();
                }
                $operation = new Operation\Repos\AddTeamAccessRestrictions($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Teams::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Team|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\RemoveTeamAccessRestrictions::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Teams::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Teams::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtectionRestrictionsTeams();
                }
                $operation = new Operation\Repos\RemoveTeamAccessRestrictions($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Teams::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Team|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetUsersWithAccessToProtectedBranch::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Users::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Users::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtectionRestrictionsUsers();
                }
                $operation = new Operation\Repos\GetUsersWithAccessToProtectedBranch($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Users::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\SimpleUser|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\SetUserAccessRestrictions::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Users::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Users::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtectionRestrictionsUsers();
                }
                $operation = new Operation\Repos\SetUserAccessRestrictions($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Users::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\SimpleUser|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\AddUserAccessRestrictions::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Users::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Users::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtectionRestrictionsUsers();
                }
                $operation = new Operation\Repos\AddUserAccessRestrictions($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Users::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\SimpleUser|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\RemoveUserAccessRestrictions::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Users::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Users::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbProtectionRestrictionsUsers();
                }
                $operation = new Operation\Repos\RemoveUserAccessRestrictions($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Protection\Restrictions\Users::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\SimpleUser|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\RenameBranch::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'branch')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Rename::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Rename::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbBranchesCbBranchRcbRename();
                }
                $operation = new Operation\Repos\RenameBranch($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Branches\CbBranchRcb\Rename::class], $params['owner'], $params['repo'], $params['branch']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BranchWithProtection|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Checks\Create::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CheckRuns::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CheckRuns::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCheckRuns();
                }
                $operation = new Operation\Checks\Create($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CheckRuns::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\CheckRun {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Checks\Get::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'check_run_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CheckDashRuns\CbCheckRunIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CheckDashRuns\CbCheckRunIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCheckDashRunsCbCheckRunIdRcb();
                }
                $operation = new Operation\Checks\Get($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CheckDashRuns\CbCheckRunIdRcb::class], $params['owner'], $params['repo'], $params['check_run_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\CheckRun {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Checks\Update::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'check_run_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CheckDashRuns\CbCheckRunIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CheckDashRuns\CbCheckRunIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCheckDashRunsCbCheckRunIdRcb();
                }
                $operation = new Operation\Checks\Update($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CheckDashRuns\CbCheckRunIdRcb::class], $params['owner'], $params['repo'], $params['check_run_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\CheckRun {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Checks\ListAnnotations::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'check_run_id', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CheckDashRuns\CbCheckRunIdRcb\Annotations::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CheckDashRuns\CbCheckRunIdRcb\Annotations::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCheckDashRunsCbCheckRunIdRcbAnnotations();
                }
                $operation = new Operation\Checks\ListAnnotations($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CheckDashRuns\CbCheckRunIdRcb\Annotations::class], $params['owner'], $params['repo'], $params['check_run_id'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\CheckAnnotation {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Checks\RerequestRun::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'check_run_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CheckDashRuns\CbCheckRunIdRcb\Rerequest::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CheckDashRuns\CbCheckRunIdRcb\Rerequest::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCheckDashRunsCbCheckRunIdRcbRerequest();
                }
                $operation = new Operation\Checks\RerequestRun($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CheckDashRuns\CbCheckRunIdRcb\Rerequest::class], $params['owner'], $params['repo'], $params['check_run_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\EmptyObject|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Checks\CreateSuite::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CheckSuites::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CheckSuites::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCheckSuites();
                }
                $operation = new Operation\Checks\CreateSuite($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CheckSuites::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\CheckSuite {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Checks\SetSuitesPreferences::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CheckSuites\Preferences::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CheckSuites\Preferences::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCheckSuitesPreferences();
                }
                $operation = new Operation\Checks\SetSuitesPreferences($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CheckSuites\Preferences::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\CheckSuitePreference {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Checks\GetSuite::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'check_suite_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CheckDashSuites\CbCheckSuiteIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CheckDashSuites\CbCheckSuiteIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCheckDashSuitesCbCheckSuiteIdRcb();
                }
                $operation = new Operation\Checks\GetSuite($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CheckDashSuites\CbCheckSuiteIdRcb::class], $params['owner'], $params['repo'], $params['check_suite_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\CheckSuite {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Checks\ListForSuite::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'check_suite_id', 'check_name', 'status', 'filter', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CheckDashSuites\CbCheckSuiteIdRcb\CheckDashRuns::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CheckDashSuites\CbCheckSuiteIdRcb\CheckDashRuns::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCheckDashSuitesCbCheckSuiteIdRcbCheckDashRuns();
                }
                $operation = new Operation\Checks\ListForSuite($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CheckDashSuites\CbCheckSuiteIdRcb\CheckDashRuns::class], $params['owner'], $params['repo'], $params['check_suite_id'], $params['check_name'], $params['status'], $params['filter'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Checks\ListForSuite\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Checks\RerequestSuite::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'check_suite_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CheckDashSuites\CbCheckSuiteIdRcb\Rerequest::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CheckDashSuites\CbCheckSuiteIdRcb\Rerequest::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCheckDashSuitesCbCheckSuiteIdRcbRerequest();
                }
                $operation = new Operation\Checks\RerequestSuite($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CheckDashSuites\CbCheckSuiteIdRcb\Rerequest::class], $params['owner'], $params['repo'], $params['check_suite_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\EmptyObject {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\CodeScanning\ListAlertsForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'tool_name', 'tool_guid', 'ref', 'state', 'page', 'per_page', 'direction', 'sort')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CodeScanning\Alerts::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CodeScanning\Alerts::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCodeScanningAlerts();
                }
                $operation = new Operation\CodeScanning\ListAlertsForRepo($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CodeScanning\Alerts::class], $params['owner'], $params['repo'], $params['tool_name'], $params['tool_guid'], $params['ref'], $params['state'], $params['page'], $params['per_page'], $params['direction'], $params['sort']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\CodeScanningAlertItems|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\CodeScanning\GetAlert::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'alert_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CodeDashScanning\Alerts\CbAlertNumberRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CodeDashScanning\Alerts\CbAlertNumberRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCodeDashScanningAlertsCbAlertNumberRcb();
                }
                $operation = new Operation\CodeScanning\GetAlert($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CodeDashScanning\Alerts\CbAlertNumberRcb::class], $params['owner'], $params['repo'], $params['alert_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\CodeScanningAlert|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\CodeScanning\UpdateAlert::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'alert_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CodeDashScanning\Alerts\CbAlertNumberRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CodeDashScanning\Alerts\CbAlertNumberRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCodeDashScanningAlertsCbAlertNumberRcb();
                }
                $operation = new Operation\CodeScanning\UpdateAlert($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CodeDashScanning\Alerts\CbAlertNumberRcb::class], $params['owner'], $params['repo'], $params['alert_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\CodeScanningAlert|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\CodeScanning\ListAlertInstances::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'alert_number', 'ref', 'page', 'per_page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CodeDashScanning\Alerts\CbAlertNumberRcb\Instances::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CodeDashScanning\Alerts\CbAlertNumberRcb\Instances::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCodeDashScanningAlertsCbAlertNumberRcbInstances();
                }
                $operation = new Operation\CodeScanning\ListAlertInstances($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CodeDashScanning\Alerts\CbAlertNumberRcb\Instances::class], $params['owner'], $params['repo'], $params['alert_number'], $params['ref'], $params['page'], $params['per_page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\CodeScanningAlertInstance|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\CodeScanning\ListRecentAnalyses::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'tool_name', 'tool_guid', 'ref', 'sarif_id', 'page', 'per_page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CodeScanning\Analyses::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CodeScanning\Analyses::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCodeScanningAnalyses();
                }
                $operation = new Operation\CodeScanning\ListRecentAnalyses($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CodeScanning\Analyses::class], $params['owner'], $params['repo'], $params['tool_name'], $params['tool_guid'], $params['ref'], $params['sarif_id'], $params['page'], $params['per_page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\CodeScanningAnalysis|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\CodeScanning\GetAnalysis::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'analysis_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CodeDashScanning\Analyses\CbAnalysisIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CodeDashScanning\Analyses\CbAnalysisIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCodeDashScanningAnalysesCbAnalysisIdRcb();
                }
                $operation = new Operation\CodeScanning\GetAnalysis($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CodeDashScanning\Analyses\CbAnalysisIdRcb::class], $params['owner'], $params['repo'], $params['analysis_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\CodeScanningAnalysis|Schema\AuditLogEvent\Data|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\CodeScanning\DeleteAnalysis::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'analysis_id', 'confirm_delete')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CodeDashScanning\Analyses\CbAnalysisIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CodeDashScanning\Analyses\CbAnalysisIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCodeDashScanningAnalysesCbAnalysisIdRcb();
                }
                $operation = new Operation\CodeScanning\DeleteAnalysis($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CodeDashScanning\Analyses\CbAnalysisIdRcb::class], $params['owner'], $params['repo'], $params['analysis_id'], $params['confirm_delete']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\CodeScanningAnalysisDeletion|Schema\BasicError|Schema\ScimError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\CodeScanning\UploadSarif::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CodeScanning\Sarifs::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CodeScanning\Sarifs::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCodeScanningSarifs();
                }
                $operation = new Operation\CodeScanning\UploadSarif($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CodeScanning\Sarifs::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\CodeScanningSarifsReceipt|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\CodeScanning\GetSarif::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'sarif_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CodeDashScanning\Sarifs\CbSarifIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CodeDashScanning\Sarifs\CbSarifIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCodeDashScanningSarifsCbSarifIdRcb();
                }
                $operation = new Operation\CodeScanning\GetSarif($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\CodeDashScanning\Sarifs\CbSarifIdRcb::class], $params['owner'], $params['repo'], $params['sarif_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\CodeScanningSarifsStatus|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\CodeownersErrors::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'ref')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Codeowners\Errors::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Codeowners\Errors::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCodeownersErrors();
                }
                $operation = new Operation\Repos\CodeownersErrors($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Codeowners\Errors::class], $params['owner'], $params['repo'], $params['ref']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\CodeownersErrors {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListCollaborators::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'affiliation', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Collaborators::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Collaborators::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCollaborators();
                }
                $operation = new Operation\Repos\ListCollaborators($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Collaborators::class], $params['owner'], $params['repo'], $params['affiliation'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Collaborator|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\CheckCollaborator::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Repos\CheckCollaborator($params['owner'], $params['repo'], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\AddCollaborator::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Collaborators\CbUsernameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Collaborators\CbUsernameRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCollaboratorsCbUsernameRcb();
                }
                $operation = new Operation\Repos\AddCollaborator($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Collaborators\CbUsernameRcb::class], $params['owner'], $params['repo'], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\RepositoryInvitation|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\RemoveCollaborator::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Repos\RemoveCollaborator($params['owner'], $params['repo'], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetCollaboratorPermissionLevel::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Collaborators\CbUsernameRcb\Permission::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Collaborators\CbUsernameRcb\Permission::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCollaboratorsCbUsernameRcbPermission();
                }
                $operation = new Operation\Repos\GetCollaboratorPermissionLevel($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Collaborators\CbUsernameRcb\Permission::class], $params['owner'], $params['repo'], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\RepositoryCollaboratorPermission|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListCommitCommentsForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Comments::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Comments::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbComments();
                }
                $operation = new Operation\Repos\ListCommitCommentsForRepo($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Comments::class], $params['owner'], $params['repo'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\CommitComment {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetCommitComment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'comment_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Comments\CbCommentIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Comments\CbCommentIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCommentsCbCommentIdRcb();
                }
                $operation = new Operation\Repos\GetCommitComment($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Comments\CbCommentIdRcb::class], $params['owner'], $params['repo'], $params['comment_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\CommitComment|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\DeleteCommitComment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'comment_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Comments\CbCommentIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Comments\CbCommentIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCommentsCbCommentIdRcb();
                }
                $operation = new Operation\Repos\DeleteCommitComment($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Comments\CbCommentIdRcb::class], $params['owner'], $params['repo'], $params['comment_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\UpdateCommitComment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'comment_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Comments\CbCommentIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Comments\CbCommentIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCommentsCbCommentIdRcb();
                }
                $operation = new Operation\Repos\UpdateCommitComment($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Comments\CbCommentIdRcb::class], $params['owner'], $params['repo'], $params['comment_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\CommitComment|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Reactions\ListForCommitComment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'comment_id', 'content', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Comments\CbCommentIdRcb\Reactions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Comments\CbCommentIdRcb\Reactions::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCommentsCbCommentIdRcbReactions();
                }
                $operation = new Operation\Reactions\ListForCommitComment($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Comments\CbCommentIdRcb\Reactions::class], $params['owner'], $params['repo'], $params['comment_id'], $params['content'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Reaction|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Reactions\CreateForCommitComment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'comment_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Comments\CbCommentIdRcb\Reactions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Comments\CbCommentIdRcb\Reactions::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCommentsCbCommentIdRcbReactions();
                }
                $operation = new Operation\Reactions\CreateForCommitComment($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Comments\CbCommentIdRcb\Reactions::class], $params['owner'], $params['repo'], $params['comment_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Reaction|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Reactions\DeleteForCommitComment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'comment_id', 'reaction_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Reactions\DeleteForCommitComment($params['owner'], $params['repo'], $params['comment_id'], $params['reaction_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListCommits::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'sha', 'path', 'author', 'committer', 'since', 'until', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Commits::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Commits::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCommits();
                }
                $operation = new Operation\Repos\ListCommits($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Commits::class], $params['owner'], $params['repo'], $params['sha'], $params['path'], $params['author'], $params['committer'], $params['since'], $params['until'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Commit|Schema\BasicError|Schema\ScimError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListBranchesForHeadCommit::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'commit_sha')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Commits\CbCommitShaRcb\BranchesDashWhereDashHead::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Commits\CbCommitShaRcb\BranchesDashWhereDashHead::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCommitsCbCommitShaRcbBranchesDashWhereDashHead();
                }
                $operation = new Operation\Repos\ListBranchesForHeadCommit($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Commits\CbCommitShaRcb\BranchesDashWhereDashHead::class], $params['owner'], $params['repo'], $params['commit_sha']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BranchShort|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListCommentsForCommit::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'commit_sha', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Commits\CbCommitShaRcb\Comments::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Commits\CbCommitShaRcb\Comments::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCommitsCbCommitShaRcbComments();
                }
                $operation = new Operation\Repos\ListCommentsForCommit($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Commits\CbCommitShaRcb\Comments::class], $params['owner'], $params['repo'], $params['commit_sha'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\CommitComment {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\CreateCommitComment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'commit_sha')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Commits\CbCommitShaRcb\Comments::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Commits\CbCommitShaRcb\Comments::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCommitsCbCommitShaRcbComments();
                }
                $operation = new Operation\Repos\CreateCommitComment($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Commits\CbCommitShaRcb\Comments::class], $params['owner'], $params['repo'], $params['commit_sha']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\CommitComment|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListPullRequestsAssociatedWithCommit::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'commit_sha', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Commits\CbCommitShaRcb\Pulls::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Commits\CbCommitShaRcb\Pulls::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCommitsCbCommitShaRcbPulls();
                }
                $operation = new Operation\Repos\ListPullRequestsAssociatedWithCommit($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Commits\CbCommitShaRcb\Pulls::class], $params['owner'], $params['repo'], $params['commit_sha'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PullRequestSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetCommit::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'ref', 'page', 'per_page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Commits\CbRefRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Commits\CbRefRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCommitsCbRefRcb();
                }
                $operation = new Operation\Repos\GetCommit($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Commits\CbRefRcb::class], $params['owner'], $params['repo'], $params['ref'], $params['page'], $params['per_page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Commit|Schema\ValidationError|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Checks\ListForRef::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'ref', 'check_name', 'status', 'app_id', 'filter', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Commits\CbRefRcb\CheckRuns::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Commits\CbRefRcb\CheckRuns::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCommitsCbRefRcbCheckRuns();
                }
                $operation = new Operation\Checks\ListForRef($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Commits\CbRefRcb\CheckRuns::class], $params['owner'], $params['repo'], $params['ref'], $params['check_name'], $params['status'], $params['app_id'], $params['filter'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Checks\ListForSuite\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Checks\ListSuitesForRef::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'ref', 'app_id', 'check_name', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Commits\CbRefRcb\CheckSuites::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Commits\CbRefRcb\CheckSuites::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCommitsCbRefRcbCheckSuites();
                }
                $operation = new Operation\Checks\ListSuitesForRef($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Commits\CbRefRcb\CheckSuites::class], $params['owner'], $params['repo'], $params['ref'], $params['app_id'], $params['check_name'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Checks\ListSuitesForRef\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetCombinedStatusForRef::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'ref', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Commits\CbRefRcb\Status::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Commits\CbRefRcb\Status::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCommitsCbRefRcbStatus();
                }
                $operation = new Operation\Repos\GetCombinedStatusForRef($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Commits\CbRefRcb\Status::class], $params['owner'], $params['repo'], $params['ref'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\CombinedCommitStatus|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListCommitStatusesForRef::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'ref', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Commits\CbRefRcb\Statuses::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Commits\CbRefRcb\Statuses::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCommitsCbRefRcbStatuses();
                }
                $operation = new Operation\Repos\ListCommitStatusesForRef($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Commits\CbRefRcb\Statuses::class], $params['owner'], $params['repo'], $params['ref'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Status|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\CompareCommits::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'basehead', 'page', 'per_page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Compare\CbBaseheadRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Compare\CbBaseheadRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbCompareCbBaseheadRcb();
                }
                $operation = new Operation\Repos\CompareCommits($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Compare\CbBaseheadRcb::class], $params['owner'], $params['repo'], $params['basehead'], $params['page'], $params['per_page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\CommitComparison|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetContent::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'path', 'ref')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Contents\CbPathRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Contents\CbPathRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbContentsCbPathRcb();
                }
                $operation = new Operation\Repos\GetContent($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Contents\CbPathRcb::class], $params['owner'], $params['repo'], $params['path'], $params['ref']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ContentTree|Schema\Operation\Repos\GetContent\Response\Applicationjson\H200|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\CreateOrUpdateFileContents::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'path')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Contents\CbPathRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Contents\CbPathRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbContentsCbPathRcb();
                }
                $operation = new Operation\Repos\CreateOrUpdateFileContents($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Contents\CbPathRcb::class], $params['owner'], $params['repo'], $params['path']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\FileCommit|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\DeleteFile::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'path')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Contents\CbPathRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Contents\CbPathRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbContentsCbPathRcb();
                }
                $operation = new Operation\Repos\DeleteFile($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Contents\CbPathRcb::class], $params['owner'], $params['repo'], $params['path']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\FileCommit|Schema\ValidationError|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListContributors::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'anon', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Contributors::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Contributors::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbContributors();
                }
                $operation = new Operation\Repos\ListContributors($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Contributors::class], $params['owner'], $params['repo'], $params['anon'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Contributor|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Dependabot\ListRepoSecrets::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Dependabot\Secrets::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Dependabot\Secrets::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbDependabotSecrets();
                }
                $operation = new Operation\Dependabot\ListRepoSecrets($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Dependabot\Secrets::class], $params['owner'], $params['repo'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Dependabot\ListRepoSecrets\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Dependabot\GetRepoPublicKey::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Dependabot\Secrets\PublicKey::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Dependabot\Secrets\PublicKey::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbDependabotSecretsPublicKey();
                }
                $operation = new Operation\Dependabot\GetRepoPublicKey($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Dependabot\Secrets\PublicKey::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\DependabotPublicKey {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Dependabot\GetRepoSecret::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'secret_name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Dependabot\Secrets\CbSecretNameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Dependabot\Secrets\CbSecretNameRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbDependabotSecretsCbSecretNameRcb();
                }
                $operation = new Operation\Dependabot\GetRepoSecret($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Dependabot\Secrets\CbSecretNameRcb::class], $params['owner'], $params['repo'], $params['secret_name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\DependabotSecret {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Dependabot\CreateOrUpdateRepoSecret::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'secret_name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Dependabot\Secrets\CbSecretNameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Dependabot\Secrets\CbSecretNameRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbDependabotSecretsCbSecretNameRcb();
                }
                $operation = new Operation\Dependabot\CreateOrUpdateRepoSecret($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Dependabot\Secrets\CbSecretNameRcb::class], $params['owner'], $params['repo'], $params['secret_name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\EmptyObject {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Dependabot\DeleteRepoSecret::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'secret_name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Dependabot\DeleteRepoSecret($params['owner'], $params['repo'], $params['secret_name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\DependencyGraph\DiffRange::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'basehead', 'name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\DependencyGraph\Compare\CbBaseheadRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\DependencyGraph\Compare\CbBaseheadRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbDependencyGraphCompareCbBaseheadRcb();
                }
                $operation = new Operation\DependencyGraph\DiffRange($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\DependencyGraph\Compare\CbBaseheadRcb::class], $params['owner'], $params['repo'], $params['basehead'], $params['name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\DependencyGraphDiff|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListDeployments::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'sha', 'ref', 'task', 'environment', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Deployments::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Deployments::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbDeployments();
                }
                $operation = new Operation\Repos\ListDeployments($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Deployments::class], $params['owner'], $params['repo'], $params['sha'], $params['ref'], $params['task'], $params['environment'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Deployment {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\CreateDeployment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Deployments::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Deployments::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbDeployments();
                }
                $operation = new Operation\Repos\CreateDeployment($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Deployments::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Deployment|Schema\Operation\Activity\MarkNotificationsAsRead\Response\Applicationjson\H202|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetDeployment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'deployment_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Deployments\CbDeploymentIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Deployments\CbDeploymentIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbDeploymentsCbDeploymentIdRcb();
                }
                $operation = new Operation\Repos\GetDeployment($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Deployments\CbDeploymentIdRcb::class], $params['owner'], $params['repo'], $params['deployment_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Deployment|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\DeleteDeployment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'deployment_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Deployments\CbDeploymentIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Deployments\CbDeploymentIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbDeploymentsCbDeploymentIdRcb();
                }
                $operation = new Operation\Repos\DeleteDeployment($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Deployments\CbDeploymentIdRcb::class], $params['owner'], $params['repo'], $params['deployment_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError|Schema\ValidationErrorSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListDeploymentStatuses::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'deployment_id', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Deployments\CbDeploymentIdRcb\Statuses::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Deployments\CbDeploymentIdRcb\Statuses::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbDeploymentsCbDeploymentIdRcbStatuses();
                }
                $operation = new Operation\Repos\ListDeploymentStatuses($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Deployments\CbDeploymentIdRcb\Statuses::class], $params['owner'], $params['repo'], $params['deployment_id'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\DeploymentStatus|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\CreateDeploymentStatus::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'deployment_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Deployments\CbDeploymentIdRcb\Statuses::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Deployments\CbDeploymentIdRcb\Statuses::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbDeploymentsCbDeploymentIdRcbStatuses();
                }
                $operation = new Operation\Repos\CreateDeploymentStatus($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Deployments\CbDeploymentIdRcb\Statuses::class], $params['owner'], $params['repo'], $params['deployment_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\DeploymentStatus|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetDeploymentStatus::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'deployment_id', 'status_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Deployments\CbDeploymentIdRcb\Statuses\CbStatusIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Deployments\CbDeploymentIdRcb\Statuses\CbStatusIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbDeploymentsCbDeploymentIdRcbStatusesCbStatusIdRcb();
                }
                $operation = new Operation\Repos\GetDeploymentStatus($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Deployments\CbDeploymentIdRcb\Statuses\CbStatusIdRcb::class], $params['owner'], $params['repo'], $params['deployment_id'], $params['status_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\DeploymentStatus|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\CreateDispatchEvent::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Dispatches::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Dispatches::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbDispatches();
                }
                $operation = new Operation\Repos\CreateDispatchEvent($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Dispatches::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetAllEnvironments::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Environments::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Environments::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbEnvironments();
                }
                $operation = new Operation\Repos\GetAllEnvironments($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Environments::class], $params['owner'], $params['repo'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Repos\GetAllEnvironments\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetEnvironment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'environment_name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Environments\CbEnvironmentNameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Environments\CbEnvironmentNameRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbEnvironmentsCbEnvironmentNameRcb();
                }
                $operation = new Operation\Repos\GetEnvironment($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Environments\CbEnvironmentNameRcb::class], $params['owner'], $params['repo'], $params['environment_name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Environment {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\CreateOrUpdateEnvironment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'environment_name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Environments\CbEnvironmentNameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Environments\CbEnvironmentNameRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbEnvironmentsCbEnvironmentNameRcb();
                }
                $operation = new Operation\Repos\CreateOrUpdateEnvironment($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Environments\CbEnvironmentNameRcb::class], $params['owner'], $params['repo'], $params['environment_name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Environment|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\DeleteAnEnvironment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'environment_name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Repos\DeleteAnEnvironment($params['owner'], $params['repo'], $params['environment_name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListDeploymentBranchPolicies::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'environment_name', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Environments\CbEnvironmentNameRcb\DeploymentDashBranchDashPolicies::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Environments\CbEnvironmentNameRcb\DeploymentDashBranchDashPolicies::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbEnvironmentsCbEnvironmentNameRcbDeploymentDashBranchDashPolicies();
                }
                $operation = new Operation\Repos\ListDeploymentBranchPolicies($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Environments\CbEnvironmentNameRcb\DeploymentDashBranchDashPolicies::class], $params['owner'], $params['repo'], $params['environment_name'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Repos\ListDeploymentBranchPolicies\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\CreateDeploymentBranchPolicy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'environment_name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Environments\CbEnvironmentNameRcb\DeploymentDashBranchDashPolicies::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Environments\CbEnvironmentNameRcb\DeploymentDashBranchDashPolicies::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbEnvironmentsCbEnvironmentNameRcbDeploymentDashBranchDashPolicies();
                }
                $operation = new Operation\Repos\CreateDeploymentBranchPolicy($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Environments\CbEnvironmentNameRcb\DeploymentDashBranchDashPolicies::class], $params['owner'], $params['repo'], $params['environment_name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\DeploymentBranchPolicy {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetDeploymentBranchPolicy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'environment_name', 'branch_policy_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Environments\CbEnvironmentNameRcb\DeploymentDashBranchDashPolicies\CbBranchPolicyIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Environments\CbEnvironmentNameRcb\DeploymentDashBranchDashPolicies\CbBranchPolicyIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbEnvironmentsCbEnvironmentNameRcbDeploymentDashBranchDashPoliciesCbBranchPolicyIdRcb();
                }
                $operation = new Operation\Repos\GetDeploymentBranchPolicy($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Environments\CbEnvironmentNameRcb\DeploymentDashBranchDashPolicies\CbBranchPolicyIdRcb::class], $params['owner'], $params['repo'], $params['environment_name'], $params['branch_policy_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\DeploymentBranchPolicy {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\UpdateDeploymentBranchPolicy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'environment_name', 'branch_policy_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Environments\CbEnvironmentNameRcb\DeploymentDashBranchDashPolicies\CbBranchPolicyIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Environments\CbEnvironmentNameRcb\DeploymentDashBranchDashPolicies\CbBranchPolicyIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbEnvironmentsCbEnvironmentNameRcbDeploymentDashBranchDashPoliciesCbBranchPolicyIdRcb();
                }
                $operation = new Operation\Repos\UpdateDeploymentBranchPolicy($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Environments\CbEnvironmentNameRcb\DeploymentDashBranchDashPolicies\CbBranchPolicyIdRcb::class], $params['owner'], $params['repo'], $params['environment_name'], $params['branch_policy_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\DeploymentBranchPolicy {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\DeleteDeploymentBranchPolicy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'environment_name', 'branch_policy_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Repos\DeleteDeploymentBranchPolicy($params['owner'], $params['repo'], $params['environment_name'], $params['branch_policy_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\ListRepoEvents::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Events::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Events::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbEvents();
                }
                $operation = new Operation\Activity\ListRepoEvents($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Events::class], $params['owner'], $params['repo'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Event {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListForks::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'sort', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Forks::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Forks::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbForks();
                }
                $operation = new Operation\Repos\ListForks($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Forks::class], $params['owner'], $params['repo'], $params['sort'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\MinimalRepository|Schema\BasicError|Schema\ScimError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\CreateFork::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Forks::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Forks::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbForks();
                }
                $operation = new Operation\Repos\CreateFork($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Forks::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\FullRepository|Schema\BasicError|Schema\ScimError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Git\CreateBlob::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Blobs::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Blobs::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbGitBlobs();
                }
                $operation = new Operation\Git\CreateBlob($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Blobs::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ShortBlob|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Git\GetBlob::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'file_sha')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Blobs\CbFileShaRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Blobs\CbFileShaRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbGitBlobsCbFileShaRcb();
                }
                $operation = new Operation\Git\GetBlob($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Blobs\CbFileShaRcb::class], $params['owner'], $params['repo'], $params['file_sha']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Blob|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Git\CreateCommit::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Commits::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Commits::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbGitCommits();
                }
                $operation = new Operation\Git\CreateCommit($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Commits::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\GitCommit|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Git\GetCommit::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'commit_sha')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Commits\CbCommitShaRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Commits\CbCommitShaRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbGitCommitsCbCommitShaRcb();
                }
                $operation = new Operation\Git\GetCommit($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Commits\CbCommitShaRcb::class], $params['owner'], $params['repo'], $params['commit_sha']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\GitCommit|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Git\ListMatchingRefs::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'ref')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\MatchingRefs\CbRefRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\MatchingRefs\CbRefRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbGitMatchingRefsCbRefRcb();
                }
                $operation = new Operation\Git\ListMatchingRefs($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\MatchingRefs\CbRefRcb::class], $params['owner'], $params['repo'], $params['ref']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\GitRef {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Git\GetRef::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'ref')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Ref\CbRefRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Ref\CbRefRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbGitRefCbRefRcb();
                }
                $operation = new Operation\Git\GetRef($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Ref\CbRefRcb::class], $params['owner'], $params['repo'], $params['ref']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\GitRef|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Git\CreateRef::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Refs::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Refs::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbGitRefs();
                }
                $operation = new Operation\Git\CreateRef($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Refs::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\GitRef|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Git\DeleteRef::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'ref')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Refs\CbRefRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Refs\CbRefRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbGitRefsCbRefRcb();
                }
                $operation = new Operation\Git\DeleteRef($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Refs\CbRefRcb::class], $params['owner'], $params['repo'], $params['ref']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Git\UpdateRef::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'ref')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Refs\CbRefRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Refs\CbRefRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbGitRefsCbRefRcb();
                }
                $operation = new Operation\Git\UpdateRef($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Refs\CbRefRcb::class], $params['owner'], $params['repo'], $params['ref']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\GitRef|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Git\CreateTag::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Tags::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Tags::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbGitTags();
                }
                $operation = new Operation\Git\CreateTag($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Tags::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\GitTag|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Git\GetTag::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'tag_sha')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Tags\CbTagShaRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Tags\CbTagShaRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbGitTagsCbTagShaRcb();
                }
                $operation = new Operation\Git\GetTag($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Tags\CbTagShaRcb::class], $params['owner'], $params['repo'], $params['tag_sha']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\GitTag|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Git\CreateTree::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Trees::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Trees::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbGitTrees();
                }
                $operation = new Operation\Git\CreateTree($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Trees::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\GitTree|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Git\GetTree::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'tree_sha', 'recursive')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Trees\CbTreeShaRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Trees\CbTreeShaRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbGitTreesCbTreeShaRcb();
                }
                $operation = new Operation\Git\GetTree($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Git\Trees\CbTreeShaRcb::class], $params['owner'], $params['repo'], $params['tree_sha'], $params['recursive']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\GitTree|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListWebhooks::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbHooks();
                }
                $operation = new Operation\Repos\ListWebhooks($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks::class], $params['owner'], $params['repo'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Hook|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\CreateWebhook::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbHooks();
                }
                $operation = new Operation\Repos\CreateWebhook($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Hook|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetWebhook::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'hook_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks\CbHookIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks\CbHookIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbHooksCbHookIdRcb();
                }
                $operation = new Operation\Repos\GetWebhook($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks\CbHookIdRcb::class], $params['owner'], $params['repo'], $params['hook_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Hook|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\DeleteWebhook::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'hook_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks\CbHookIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks\CbHookIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbHooksCbHookIdRcb();
                }
                $operation = new Operation\Repos\DeleteWebhook($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks\CbHookIdRcb::class], $params['owner'], $params['repo'], $params['hook_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\UpdateWebhook::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'hook_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks\CbHookIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks\CbHookIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbHooksCbHookIdRcb();
                }
                $operation = new Operation\Repos\UpdateWebhook($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks\CbHookIdRcb::class], $params['owner'], $params['repo'], $params['hook_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Hook|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetWebhookConfigForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'hook_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks\CbHookIdRcb\Config::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks\CbHookIdRcb\Config::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbHooksCbHookIdRcbConfig();
                }
                $operation = new Operation\Repos\GetWebhookConfigForRepo($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks\CbHookIdRcb\Config::class], $params['owner'], $params['repo'], $params['hook_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\WebhookConfig {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\UpdateWebhookConfigForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'hook_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks\CbHookIdRcb\Config::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks\CbHookIdRcb\Config::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbHooksCbHookIdRcbConfig();
                }
                $operation = new Operation\Repos\UpdateWebhookConfigForRepo($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks\CbHookIdRcb\Config::class], $params['owner'], $params['repo'], $params['hook_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\WebhookConfig {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListWebhookDeliveries::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'hook_id', 'cursor', 'redelivery', 'per_page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks\CbHookIdRcb\Deliveries::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks\CbHookIdRcb\Deliveries::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbHooksCbHookIdRcbDeliveries();
                }
                $operation = new Operation\Repos\ListWebhookDeliveries($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks\CbHookIdRcb\Deliveries::class], $params['owner'], $params['repo'], $params['hook_id'], $params['cursor'], $params['redelivery'], $params['per_page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\HookDeliveryItem|Schema\BasicError|Schema\ScimError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetWebhookDelivery::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'hook_id', 'delivery_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks\CbHookIdRcb\Deliveries\CbDeliveryIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks\CbHookIdRcb\Deliveries\CbDeliveryIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbHooksCbHookIdRcbDeliveriesCbDeliveryIdRcb();
                }
                $operation = new Operation\Repos\GetWebhookDelivery($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks\CbHookIdRcb\Deliveries\CbDeliveryIdRcb::class], $params['owner'], $params['repo'], $params['hook_id'], $params['delivery_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\HookDelivery|Schema\BasicError|Schema\ScimError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\RedeliverWebhookDelivery::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'hook_id', 'delivery_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks\CbHookIdRcb\Deliveries\CbDeliveryIdRcb\Attempts::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks\CbHookIdRcb\Deliveries\CbDeliveryIdRcb\Attempts::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbHooksCbHookIdRcbDeliveriesCbDeliveryIdRcbAttempts();
                }
                $operation = new Operation\Repos\RedeliverWebhookDelivery($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks\CbHookIdRcb\Deliveries\CbDeliveryIdRcb\Attempts::class], $params['owner'], $params['repo'], $params['hook_id'], $params['delivery_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\AuditLogEvent\Config|Schema\BasicError|Schema\ScimError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\PingWebhook::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'hook_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks\CbHookIdRcb\Pings::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks\CbHookIdRcb\Pings::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbHooksCbHookIdRcbPings();
                }
                $operation = new Operation\Repos\PingWebhook($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks\CbHookIdRcb\Pings::class], $params['owner'], $params['repo'], $params['hook_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\TestPushWebhook::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'hook_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks\CbHookIdRcb\Tests::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks\CbHookIdRcb\Tests::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbHooksCbHookIdRcbTests();
                }
                $operation = new Operation\Repos\TestPushWebhook($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Hooks\CbHookIdRcb\Tests::class], $params['owner'], $params['repo'], $params['hook_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Apps\GetRepoInstallation::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Installation::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Installation::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbInstallation();
                }
                $operation = new Operation\Apps\GetRepoInstallation($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Installation::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Installation|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListInvitations::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Invitations::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Invitations::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbInvitations();
                }
                $operation = new Operation\Repos\ListInvitations($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Invitations::class], $params['owner'], $params['repo'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\RepositoryInvitation {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\DeleteInvitation::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'invitation_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Repos\DeleteInvitation($params['owner'], $params['repo'], $params['invitation_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\UpdateInvitation::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'invitation_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Invitations\CbInvitationIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Invitations\CbInvitationIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbInvitationsCbInvitationIdRcb();
                }
                $operation = new Operation\Repos\UpdateInvitation($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Invitations\CbInvitationIdRcb::class], $params['owner'], $params['repo'], $params['invitation_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\RepositoryInvitation {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\ListForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'milestone', 'assignee', 'creator', 'mentioned', 'labels', 'since', 'state', 'sort', 'direction', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbIssues();
                }
                $operation = new Operation\Issues\ListForRepo($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues::class], $params['owner'], $params['repo'], $params['milestone'], $params['assignee'], $params['creator'], $params['mentioned'], $params['labels'], $params['since'], $params['state'], $params['sort'], $params['direction'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Issue|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\Create::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbIssues();
                }
                $operation = new Operation\Issues\Create($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Issue|Schema\BasicError|Schema\ValidationError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\ListCommentsForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'direction', 'since', 'sort', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\Comments::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\Comments::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbIssuesComments();
                }
                $operation = new Operation\Issues\ListCommentsForRepo($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\Comments::class], $params['owner'], $params['repo'], $params['direction'], $params['since'], $params['sort'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\IssueComment|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\GetComment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'comment_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\Comments\CbCommentIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\Comments\CbCommentIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbIssuesCommentsCbCommentIdRcb();
                }
                $operation = new Operation\Issues\GetComment($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\Comments\CbCommentIdRcb::class], $params['owner'], $params['repo'], $params['comment_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\IssueComment|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\DeleteComment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'comment_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Issues\DeleteComment($params['owner'], $params['repo'], $params['comment_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\UpdateComment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'comment_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\Comments\CbCommentIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\Comments\CbCommentIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbIssuesCommentsCbCommentIdRcb();
                }
                $operation = new Operation\Issues\UpdateComment($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\Comments\CbCommentIdRcb::class], $params['owner'], $params['repo'], $params['comment_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\IssueComment|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Reactions\ListForIssueComment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'comment_id', 'content', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\Comments\CbCommentIdRcb\Reactions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\Comments\CbCommentIdRcb\Reactions::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbIssuesCommentsCbCommentIdRcbReactions();
                }
                $operation = new Operation\Reactions\ListForIssueComment($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\Comments\CbCommentIdRcb\Reactions::class], $params['owner'], $params['repo'], $params['comment_id'], $params['content'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Reaction|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Reactions\CreateForIssueComment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'comment_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\Comments\CbCommentIdRcb\Reactions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\Comments\CbCommentIdRcb\Reactions::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbIssuesCommentsCbCommentIdRcbReactions();
                }
                $operation = new Operation\Reactions\CreateForIssueComment($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\Comments\CbCommentIdRcb\Reactions::class], $params['owner'], $params['repo'], $params['comment_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Reaction|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Reactions\DeleteForIssueComment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'comment_id', 'reaction_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Reactions\DeleteForIssueComment($params['owner'], $params['repo'], $params['comment_id'], $params['reaction_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\ListEventsForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\Events::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\Events::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbIssuesEvents();
                }
                $operation = new Operation\Issues\ListEventsForRepo($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\Events::class], $params['owner'], $params['repo'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\IssueEvent|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\GetEvent::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'event_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\Events\CbEventIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\Events\CbEventIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbIssuesEventsCbEventIdRcb();
                }
                $operation = new Operation\Issues\GetEvent($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\Events\CbEventIdRcb::class], $params['owner'], $params['repo'], $params['event_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\IssueEvent|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\Get::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'issue_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbIssuesCbIssueNumberRcb();
                }
                $operation = new Operation\Issues\Get($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb::class], $params['owner'], $params['repo'], $params['issue_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Issue|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\Update::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'issue_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbIssuesCbIssueNumberRcb();
                }
                $operation = new Operation\Issues\Update($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb::class], $params['owner'], $params['repo'], $params['issue_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Issue|Schema\ValidationError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\AddAssignees::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'issue_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Assignees::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Assignees::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbIssuesCbIssueNumberRcbAssignees();
                }
                $operation = new Operation\Issues\AddAssignees($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Assignees::class], $params['owner'], $params['repo'], $params['issue_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Issue {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\RemoveAssignees::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'issue_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Assignees::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Assignees::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbIssuesCbIssueNumberRcbAssignees();
                }
                $operation = new Operation\Issues\RemoveAssignees($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Assignees::class], $params['owner'], $params['repo'], $params['issue_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Issue {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\CheckUserCanBeAssignedToIssue::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'issue_number', 'assignee')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Assignees\CbAssigneeRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Assignees\CbAssigneeRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbIssuesCbIssueNumberRcbAssigneesCbAssigneeRcb();
                }
                $operation = new Operation\Issues\CheckUserCanBeAssignedToIssue($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Assignees\CbAssigneeRcb::class], $params['owner'], $params['repo'], $params['issue_number'], $params['assignee']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\ListComments::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'issue_number', 'since', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Comments::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Comments::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbIssuesCbIssueNumberRcbComments();
                }
                $operation = new Operation\Issues\ListComments($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Comments::class], $params['owner'], $params['repo'], $params['issue_number'], $params['since'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\IssueComment|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\CreateComment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'issue_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Comments::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Comments::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbIssuesCbIssueNumberRcbComments();
                }
                $operation = new Operation\Issues\CreateComment($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Comments::class], $params['owner'], $params['repo'], $params['issue_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\IssueComment|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\ListEvents::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'issue_number', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Events::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Events::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbIssuesCbIssueNumberRcbEvents();
                }
                $operation = new Operation\Issues\ListEvents($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Events::class], $params['owner'], $params['repo'], $params['issue_number'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\IssueEventForIssue|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\ListLabelsOnIssue::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'issue_number', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Labels::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Labels::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbIssuesCbIssueNumberRcbLabels();
                }
                $operation = new Operation\Issues\ListLabelsOnIssue($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Labels::class], $params['owner'], $params['repo'], $params['issue_number'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Label|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\SetLabels::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'issue_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Labels::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Labels::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbIssuesCbIssueNumberRcbLabels();
                }
                $operation = new Operation\Issues\SetLabels($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Labels::class], $params['owner'], $params['repo'], $params['issue_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Label|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\AddLabels::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'issue_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Labels::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Labels::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbIssuesCbIssueNumberRcbLabels();
                }
                $operation = new Operation\Issues\AddLabels($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Labels::class], $params['owner'], $params['repo'], $params['issue_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Label|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\RemoveAllLabels::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'issue_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Labels::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Labels::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbIssuesCbIssueNumberRcbLabels();
                }
                $operation = new Operation\Issues\RemoveAllLabels($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Labels::class], $params['owner'], $params['repo'], $params['issue_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\RemoveLabel::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'issue_number', 'name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Labels\CbNameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Labels\CbNameRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbIssuesCbIssueNumberRcbLabelsCbNameRcb();
                }
                $operation = new Operation\Issues\RemoveLabel($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Labels\CbNameRcb::class], $params['owner'], $params['repo'], $params['issue_number'], $params['name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Label|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\Lock::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'issue_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Lock::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Lock::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbIssuesCbIssueNumberRcbLock();
                }
                $operation = new Operation\Issues\Lock($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Lock::class], $params['owner'], $params['repo'], $params['issue_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\Unlock::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'issue_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Lock::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Lock::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbIssuesCbIssueNumberRcbLock();
                }
                $operation = new Operation\Issues\Unlock($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Lock::class], $params['owner'], $params['repo'], $params['issue_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Reactions\ListForIssue::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'issue_number', 'content', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Reactions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Reactions::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbIssuesCbIssueNumberRcbReactions();
                }
                $operation = new Operation\Reactions\ListForIssue($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Reactions::class], $params['owner'], $params['repo'], $params['issue_number'], $params['content'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Reaction|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Reactions\CreateForIssue::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'issue_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Reactions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Reactions::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbIssuesCbIssueNumberRcbReactions();
                }
                $operation = new Operation\Reactions\CreateForIssue($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Reactions::class], $params['owner'], $params['repo'], $params['issue_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Reaction|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Reactions\DeleteForIssue::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'issue_number', 'reaction_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Reactions\DeleteForIssue($params['owner'], $params['repo'], $params['issue_number'], $params['reaction_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\ListEventsForTimeline::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'issue_number', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Timeline::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Timeline::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbIssuesCbIssueNumberRcbTimeline();
                }
                $operation = new Operation\Issues\ListEventsForTimeline($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Issues\CbIssueNumberRcb\Timeline::class], $params['owner'], $params['repo'], $params['issue_number'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TimelineIssueEvents|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListDeployKeys::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Keys::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Keys::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbKeys();
                }
                $operation = new Operation\Repos\ListDeployKeys($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Keys::class], $params['owner'], $params['repo'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\DeployKey {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\CreateDeployKey::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Keys::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Keys::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbKeys();
                }
                $operation = new Operation\Repos\CreateDeployKey($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Keys::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\DeployKey|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetDeployKey::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'key_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Keys\CbKeyIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Keys\CbKeyIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbKeysCbKeyIdRcb();
                }
                $operation = new Operation\Repos\GetDeployKey($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Keys\CbKeyIdRcb::class], $params['owner'], $params['repo'], $params['key_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\DeployKey|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\DeleteDeployKey::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'key_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Repos\DeleteDeployKey($params['owner'], $params['repo'], $params['key_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\ListLabelsForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Labels::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Labels::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbLabels();
                }
                $operation = new Operation\Issues\ListLabelsForRepo($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Labels::class], $params['owner'], $params['repo'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Label|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\CreateLabel::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Labels::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Labels::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbLabels();
                }
                $operation = new Operation\Issues\CreateLabel($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Labels::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Label|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\GetLabel::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Labels\CbNameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Labels\CbNameRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbLabelsCbNameRcb();
                }
                $operation = new Operation\Issues\GetLabel($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Labels\CbNameRcb::class], $params['owner'], $params['repo'], $params['name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Label|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\DeleteLabel::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Issues\DeleteLabel($params['owner'], $params['repo'], $params['name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\UpdateLabel::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Labels\CbNameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Labels\CbNameRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbLabelsCbNameRcb();
                }
                $operation = new Operation\Issues\UpdateLabel($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Labels\CbNameRcb::class], $params['owner'], $params['repo'], $params['name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Label {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListLanguages::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Languages::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Languages::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbLanguages();
                }
                $operation = new Operation\Repos\ListLanguages($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Languages::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Language {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\EnableLfsForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Lfs::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Lfs::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbLfs();
                }
                $operation = new Operation\Repos\EnableLfsForRepo($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Lfs::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\AuditLogEvent\Config {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\DisableLfsForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Repos\DisableLfsForRepo($params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Licenses\GetForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\License::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\License::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbLicense();
                }
                $operation = new Operation\Licenses\GetForRepo($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\License::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\LicenseContent {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\MergeUpstream::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\MergeUpstream::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\MergeUpstream::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbMergeUpstream();
                }
                $operation = new Operation\Repos\MergeUpstream($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\MergeUpstream::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\MergedUpstream {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\Merge::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Merges::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Merges::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbMerges();
                }
                $operation = new Operation\Repos\Merge($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Merges::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Commit|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\ListMilestones::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'state', 'sort', 'direction', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Milestones::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Milestones::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbMilestones();
                }
                $operation = new Operation\Issues\ListMilestones($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Milestones::class], $params['owner'], $params['repo'], $params['state'], $params['sort'], $params['direction'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Milestone|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\CreateMilestone::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Milestones::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Milestones::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbMilestones();
                }
                $operation = new Operation\Issues\CreateMilestone($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Milestones::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Milestone|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\GetMilestone::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'milestone_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Milestones\CbMilestoneNumberRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Milestones\CbMilestoneNumberRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbMilestonesCbMilestoneNumberRcb();
                }
                $operation = new Operation\Issues\GetMilestone($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Milestones\CbMilestoneNumberRcb::class], $params['owner'], $params['repo'], $params['milestone_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Milestone|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\DeleteMilestone::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'milestone_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Milestones\CbMilestoneNumberRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Milestones\CbMilestoneNumberRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbMilestonesCbMilestoneNumberRcb();
                }
                $operation = new Operation\Issues\DeleteMilestone($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Milestones\CbMilestoneNumberRcb::class], $params['owner'], $params['repo'], $params['milestone_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\UpdateMilestone::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'milestone_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Milestones\CbMilestoneNumberRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Milestones\CbMilestoneNumberRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbMilestonesCbMilestoneNumberRcb();
                }
                $operation = new Operation\Issues\UpdateMilestone($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Milestones\CbMilestoneNumberRcb::class], $params['owner'], $params['repo'], $params['milestone_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Milestone {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\ListLabelsForMilestone::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'milestone_number', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Milestones\CbMilestoneNumberRcb\Labels::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Milestones\CbMilestoneNumberRcb\Labels::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbMilestonesCbMilestoneNumberRcbLabels();
                }
                $operation = new Operation\Issues\ListLabelsForMilestone($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Milestones\CbMilestoneNumberRcb\Labels::class], $params['owner'], $params['repo'], $params['milestone_number'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Label {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\ListRepoNotificationsForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'since', 'before', 'all', 'participating', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Notifications::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Notifications::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbNotifications();
                }
                $operation = new Operation\Activity\ListRepoNotificationsForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Notifications::class], $params['owner'], $params['repo'], $params['since'], $params['before'], $params['all'], $params['participating'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Thread {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\MarkRepoNotificationsAsRead::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Notifications::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Notifications::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbNotifications();
                }
                $operation = new Operation\Activity\MarkRepoNotificationsAsRead($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Notifications::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\EnterpriseAdmin\UpdateOrgName\Response\Applicationjson\H202 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetPages::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pages::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pages::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPages();
                }
                $operation = new Operation\Repos\GetPages($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pages::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Page|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\UpdateInformationAboutPagesSite::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pages::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pages::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPages();
                }
                $operation = new Operation\Repos\UpdateInformationAboutPagesSite($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pages::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ValidationError|Schema\BasicError|Schema\ScimError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\CreatePagesSite::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pages::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pages::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPages();
                }
                $operation = new Operation\Repos\CreatePagesSite($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pages::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Page|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\DeletePagesSite::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pages::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pages::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPages();
                }
                $operation = new Operation\Repos\DeletePagesSite($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pages::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListPagesBuilds::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pages\Builds::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pages\Builds::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPagesBuilds();
                }
                $operation = new Operation\Repos\ListPagesBuilds($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pages\Builds::class], $params['owner'], $params['repo'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PageBuild {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\RequestPagesBuild::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pages\Builds::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pages\Builds::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPagesBuilds();
                }
                $operation = new Operation\Repos\RequestPagesBuild($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pages\Builds::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PageBuildStatus {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetLatestPagesBuild::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pages\Builds\Latest::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pages\Builds\Latest::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPagesBuildsLatest();
                }
                $operation = new Operation\Repos\GetLatestPagesBuild($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pages\Builds\Latest::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PageBuild {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetPagesBuild::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'build_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pages\Builds\CbBuildIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pages\Builds\CbBuildIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPagesBuildsCbBuildIdRcb();
                }
                $operation = new Operation\Repos\GetPagesBuild($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pages\Builds\CbBuildIdRcb::class], $params['owner'], $params['repo'], $params['build_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PageBuild {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\ListPreReceiveHooksForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'per_page', 'page', 'direction', 'sort')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\PreReceiveHooks::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\PreReceiveHooks::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPreReceiveHooks();
                }
                $operation = new Operation\EnterpriseAdmin\ListPreReceiveHooksForRepo($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\PreReceiveHooks::class], $params['owner'], $params['repo'], $params['per_page'], $params['page'], $params['direction'], $params['sort']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\RepositoryPreReceiveHook {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\GetPreReceiveHookForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'pre_receive_hook_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\PreDashReceiveDashHooks\CbPreReceiveHookIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\PreDashReceiveDashHooks\CbPreReceiveHookIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPreDashReceiveDashHooksCbPreReceiveHookIdRcb();
                }
                $operation = new Operation\EnterpriseAdmin\GetPreReceiveHookForRepo($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\PreDashReceiveDashHooks\CbPreReceiveHookIdRcb::class], $params['owner'], $params['repo'], $params['pre_receive_hook_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\RepositoryPreReceiveHook {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\RemovePreReceiveHookEnforcementForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'pre_receive_hook_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\PreDashReceiveDashHooks\CbPreReceiveHookIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\PreDashReceiveDashHooks\CbPreReceiveHookIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPreDashReceiveDashHooksCbPreReceiveHookIdRcb();
                }
                $operation = new Operation\EnterpriseAdmin\RemovePreReceiveHookEnforcementForRepo($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\PreDashReceiveDashHooks\CbPreReceiveHookIdRcb::class], $params['owner'], $params['repo'], $params['pre_receive_hook_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\RepositoryPreReceiveHook {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\UpdatePreReceiveHookEnforcementForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'pre_receive_hook_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\PreDashReceiveDashHooks\CbPreReceiveHookIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\PreDashReceiveDashHooks\CbPreReceiveHookIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPreDashReceiveDashHooksCbPreReceiveHookIdRcb();
                }
                $operation = new Operation\EnterpriseAdmin\UpdatePreReceiveHookEnforcementForRepo($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\PreDashReceiveDashHooks\CbPreReceiveHookIdRcb::class], $params['owner'], $params['repo'], $params['pre_receive_hook_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\RepositoryPreReceiveHook {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Projects\ListForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'state', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Projects::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Projects::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbProjects();
                }
                $operation = new Operation\Projects\ListForRepo($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Projects::class], $params['owner'], $params['repo'], $params['state'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Project|Schema\BasicError|Schema\ValidationErrorSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Projects\CreateForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Projects::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Projects::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbProjects();
                }
                $operation = new Operation\Projects\CreateForRepo($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Projects::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Project|Schema\BasicError|Schema\ValidationErrorSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Pulls\List_::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'head', 'base', 'direction', 'state', 'sort', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPulls();
                }
                $operation = new Operation\Pulls\List_($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls::class], $params['owner'], $params['repo'], $params['head'], $params['base'], $params['direction'], $params['state'], $params['sort'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PullRequestSimple|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Pulls\Create::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPulls();
                }
                $operation = new Operation\Pulls\Create($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PullRequest|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Pulls\ListReviewCommentsForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'sort', 'direction', 'since', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\Comments::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\Comments::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPullsComments();
                }
                $operation = new Operation\Pulls\ListReviewCommentsForRepo($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\Comments::class], $params['owner'], $params['repo'], $params['sort'], $params['direction'], $params['since'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PullRequestReviewComment {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Pulls\GetReviewComment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'comment_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\Comments\CbCommentIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\Comments\CbCommentIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPullsCommentsCbCommentIdRcb();
                }
                $operation = new Operation\Pulls\GetReviewComment($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\Comments\CbCommentIdRcb::class], $params['owner'], $params['repo'], $params['comment_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PullRequestReviewComment|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Pulls\DeleteReviewComment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'comment_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\Comments\CbCommentIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\Comments\CbCommentIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPullsCommentsCbCommentIdRcb();
                }
                $operation = new Operation\Pulls\DeleteReviewComment($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\Comments\CbCommentIdRcb::class], $params['owner'], $params['repo'], $params['comment_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Pulls\UpdateReviewComment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'comment_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\Comments\CbCommentIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\Comments\CbCommentIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPullsCommentsCbCommentIdRcb();
                }
                $operation = new Operation\Pulls\UpdateReviewComment($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\Comments\CbCommentIdRcb::class], $params['owner'], $params['repo'], $params['comment_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PullRequestReviewComment {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Reactions\ListForPullRequestReviewComment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'comment_id', 'content', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\Comments\CbCommentIdRcb\Reactions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\Comments\CbCommentIdRcb\Reactions::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPullsCommentsCbCommentIdRcbReactions();
                }
                $operation = new Operation\Reactions\ListForPullRequestReviewComment($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\Comments\CbCommentIdRcb\Reactions::class], $params['owner'], $params['repo'], $params['comment_id'], $params['content'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Reaction|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Reactions\CreateForPullRequestReviewComment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'comment_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\Comments\CbCommentIdRcb\Reactions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\Comments\CbCommentIdRcb\Reactions::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPullsCommentsCbCommentIdRcbReactions();
                }
                $operation = new Operation\Reactions\CreateForPullRequestReviewComment($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\Comments\CbCommentIdRcb\Reactions::class], $params['owner'], $params['repo'], $params['comment_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Reaction|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Reactions\DeleteForPullRequestComment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'comment_id', 'reaction_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Reactions\DeleteForPullRequestComment($params['owner'], $params['repo'], $params['comment_id'], $params['reaction_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Pulls\Get::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'pull_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPullsCbPullNumberRcb();
                }
                $operation = new Operation\Pulls\Get($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb::class], $params['owner'], $params['repo'], $params['pull_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PullRequest|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Pulls\Update::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'pull_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPullsCbPullNumberRcb();
                }
                $operation = new Operation\Pulls\Update($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb::class], $params['owner'], $params['repo'], $params['pull_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PullRequest|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Pulls\ListReviewComments::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'pull_number', 'direction', 'since', 'sort', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Comments::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Comments::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPullsCbPullNumberRcbComments();
                }
                $operation = new Operation\Pulls\ListReviewComments($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Comments::class], $params['owner'], $params['repo'], $params['pull_number'], $params['direction'], $params['since'], $params['sort'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PullRequestReviewComment {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Pulls\CreateReviewComment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'pull_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Comments::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Comments::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPullsCbPullNumberRcbComments();
                }
                $operation = new Operation\Pulls\CreateReviewComment($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Comments::class], $params['owner'], $params['repo'], $params['pull_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PullRequestReviewComment|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Pulls\CreateReplyForReviewComment::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'pull_number', 'comment_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Comments\CbCommentIdRcb\Replies::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Comments\CbCommentIdRcb\Replies::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPullsCbPullNumberRcbCommentsCbCommentIdRcbReplies();
                }
                $operation = new Operation\Pulls\CreateReplyForReviewComment($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Comments\CbCommentIdRcb\Replies::class], $params['owner'], $params['repo'], $params['pull_number'], $params['comment_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PullRequestReviewComment|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Pulls\ListCommits::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'pull_number', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Commits::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Commits::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPullsCbPullNumberRcbCommits();
                }
                $operation = new Operation\Pulls\ListCommits($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Commits::class], $params['owner'], $params['repo'], $params['pull_number'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Commit {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Pulls\ListFiles::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'pull_number', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Files::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Files::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPullsCbPullNumberRcbFiles();
                }
                $operation = new Operation\Pulls\ListFiles($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Files::class], $params['owner'], $params['repo'], $params['pull_number'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\DiffEntry|Schema\ValidationError|Schema\BasicError|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Pulls\CheckIfMerged::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'pull_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Pulls\CheckIfMerged($params['owner'], $params['repo'], $params['pull_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Pulls\Merge::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'pull_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Merge::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Merge::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPullsCbPullNumberRcbMerge();
                }
                $operation = new Operation\Pulls\Merge($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Merge::class], $params['owner'], $params['repo'], $params['pull_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PullRequestMergeResult|Schema\Operation\Orgs\RemoveOutsideCollaborator\Response\Applicationjson\H422|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Pulls\ListRequestedReviewers::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'pull_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\RequestedReviewers::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\RequestedReviewers::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPullsCbPullNumberRcbRequestedReviewers();
                }
                $operation = new Operation\Pulls\ListRequestedReviewers($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\RequestedReviewers::class], $params['owner'], $params['repo'], $params['pull_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PullRequestReviewRequest {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Pulls\RequestReviewers::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'pull_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\RequestedReviewers::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\RequestedReviewers::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPullsCbPullNumberRcbRequestedReviewers();
                }
                $operation = new Operation\Pulls\RequestReviewers($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\RequestedReviewers::class], $params['owner'], $params['repo'], $params['pull_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PullRequestSimple|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Pulls\RemoveRequestedReviewers::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'pull_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\RequestedReviewers::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\RequestedReviewers::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPullsCbPullNumberRcbRequestedReviewers();
                }
                $operation = new Operation\Pulls\RemoveRequestedReviewers($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\RequestedReviewers::class], $params['owner'], $params['repo'], $params['pull_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PullRequestSimple|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Pulls\ListReviews::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'pull_number', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Reviews::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Reviews::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPullsCbPullNumberRcbReviews();
                }
                $operation = new Operation\Pulls\ListReviews($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Reviews::class], $params['owner'], $params['repo'], $params['pull_number'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PullRequestReview {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Pulls\CreateReview::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'pull_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Reviews::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Reviews::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPullsCbPullNumberRcbReviews();
                }
                $operation = new Operation\Pulls\CreateReview($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Reviews::class], $params['owner'], $params['repo'], $params['pull_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PullRequestReview|Schema\ValidationErrorSimple|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Pulls\GetReview::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'pull_number', 'review_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Reviews\CbReviewIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Reviews\CbReviewIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPullsCbPullNumberRcbReviewsCbReviewIdRcb();
                }
                $operation = new Operation\Pulls\GetReview($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Reviews\CbReviewIdRcb::class], $params['owner'], $params['repo'], $params['pull_number'], $params['review_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PullRequestReview|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Pulls\UpdateReview::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'pull_number', 'review_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Reviews\CbReviewIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Reviews\CbReviewIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPullsCbPullNumberRcbReviewsCbReviewIdRcb();
                }
                $operation = new Operation\Pulls\UpdateReview($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Reviews\CbReviewIdRcb::class], $params['owner'], $params['repo'], $params['pull_number'], $params['review_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PullRequestReview|Schema\ValidationErrorSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Pulls\DeletePendingReview::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'pull_number', 'review_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Reviews\CbReviewIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Reviews\CbReviewIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPullsCbPullNumberRcbReviewsCbReviewIdRcb();
                }
                $operation = new Operation\Pulls\DeletePendingReview($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Reviews\CbReviewIdRcb::class], $params['owner'], $params['repo'], $params['pull_number'], $params['review_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PullRequestReview|Schema\ValidationErrorSimple|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Pulls\ListCommentsForReview::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'pull_number', 'review_id', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Reviews\CbReviewIdRcb\Comments::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Reviews\CbReviewIdRcb\Comments::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPullsCbPullNumberRcbReviewsCbReviewIdRcbComments();
                }
                $operation = new Operation\Pulls\ListCommentsForReview($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Reviews\CbReviewIdRcb\Comments::class], $params['owner'], $params['repo'], $params['pull_number'], $params['review_id'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ReviewComment|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Pulls\DismissReview::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'pull_number', 'review_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Reviews\CbReviewIdRcb\Dismissals::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Reviews\CbReviewIdRcb\Dismissals::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPullsCbPullNumberRcbReviewsCbReviewIdRcbDismissals();
                }
                $operation = new Operation\Pulls\DismissReview($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Reviews\CbReviewIdRcb\Dismissals::class], $params['owner'], $params['repo'], $params['pull_number'], $params['review_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PullRequestReview|Schema\BasicError|Schema\ValidationErrorSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Pulls\SubmitReview::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'pull_number', 'review_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Reviews\CbReviewIdRcb\Events::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Reviews\CbReviewIdRcb\Events::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPullsCbPullNumberRcbReviewsCbReviewIdRcbEvents();
                }
                $operation = new Operation\Pulls\SubmitReview($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\Reviews\CbReviewIdRcb\Events::class], $params['owner'], $params['repo'], $params['pull_number'], $params['review_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PullRequestReview|Schema\BasicError|Schema\ValidationErrorSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Pulls\UpdateBranch::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'pull_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\UpdateDashBranch::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\UpdateDashBranch::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbPullsCbPullNumberRcbUpdateDashBranch();
                }
                $operation = new Operation\Pulls\UpdateBranch($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Pulls\CbPullNumberRcb\UpdateDashBranch::class], $params['owner'], $params['repo'], $params['pull_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\EnterpriseAdmin\UpdateOrgName\Response\Applicationjson\H202|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetReadme::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'ref')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Readme::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Readme::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbReadme();
                }
                $operation = new Operation\Repos\GetReadme($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Readme::class], $params['owner'], $params['repo'], $params['ref']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ContentFile|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetReadmeInDirectory::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'dir', 'ref')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Readme\CbDirRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Readme\CbDirRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbReadmeCbDirRcb();
                }
                $operation = new Operation\Repos\GetReadmeInDirectory($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Readme\CbDirRcb::class], $params['owner'], $params['repo'], $params['dir'], $params['ref']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ContentFile|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListReleases::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbReleases();
                }
                $operation = new Operation\Repos\ListReleases($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases::class], $params['owner'], $params['repo'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Release|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\CreateRelease::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbReleases();
                }
                $operation = new Operation\Repos\CreateRelease($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Release|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetReleaseAsset::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'asset_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\Assets\CbAssetIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\Assets\CbAssetIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbReleasesAssetsCbAssetIdRcb();
                }
                $operation = new Operation\Repos\GetReleaseAsset($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\Assets\CbAssetIdRcb::class], $params['owner'], $params['repo'], $params['asset_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ReleaseAsset|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\DeleteReleaseAsset::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'asset_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Repos\DeleteReleaseAsset($params['owner'], $params['repo'], $params['asset_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\UpdateReleaseAsset::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'asset_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\Assets\CbAssetIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\Assets\CbAssetIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbReleasesAssetsCbAssetIdRcb();
                }
                $operation = new Operation\Repos\UpdateReleaseAsset($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\Assets\CbAssetIdRcb::class], $params['owner'], $params['repo'], $params['asset_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ReleaseAsset {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GenerateReleaseNotes::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\GenerateNotes::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\GenerateNotes::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbReleasesGenerateNotes();
                }
                $operation = new Operation\Repos\GenerateReleaseNotes($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\GenerateNotes::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ReleaseNotesContent|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetLatestRelease::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\Latest::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\Latest::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbReleasesLatest();
                }
                $operation = new Operation\Repos\GetLatestRelease($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\Latest::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Release {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetReleaseByTag::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'tag')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\Tags\CbTagRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\Tags\CbTagRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbReleasesTagsCbTagRcb();
                }
                $operation = new Operation\Repos\GetReleaseByTag($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\Tags\CbTagRcb::class], $params['owner'], $params['repo'], $params['tag']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Release|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetRelease::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'release_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\CbReleaseIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\CbReleaseIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbReleasesCbReleaseIdRcb();
                }
                $operation = new Operation\Repos\GetRelease($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\CbReleaseIdRcb::class], $params['owner'], $params['repo'], $params['release_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Release|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\DeleteRelease::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'release_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Repos\DeleteRelease($params['owner'], $params['repo'], $params['release_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\UpdateRelease::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'release_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\CbReleaseIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\CbReleaseIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbReleasesCbReleaseIdRcb();
                }
                $operation = new Operation\Repos\UpdateRelease($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\CbReleaseIdRcb::class], $params['owner'], $params['repo'], $params['release_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Release {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListReleaseAssets::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'release_id', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\CbReleaseIdRcb\Assets::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\CbReleaseIdRcb\Assets::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbReleasesCbReleaseIdRcbAssets();
                }
                $operation = new Operation\Repos\ListReleaseAssets($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\CbReleaseIdRcb\Assets::class], $params['owner'], $params['repo'], $params['release_id'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ReleaseAsset {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\UploadReleaseAsset::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'release_id', 'name', 'label')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\CbReleaseIdRcb\Assets::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\CbReleaseIdRcb\Assets::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbReleasesCbReleaseIdRcbAssets();
                }
                $operation = new Operation\Repos\UploadReleaseAsset($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\CbReleaseIdRcb\Assets::class], $params['owner'], $params['repo'], $params['release_id'], $params['name'], $params['label']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ReleaseAsset {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Reactions\ListForRelease::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'release_id', 'content', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\CbReleaseIdRcb\Reactions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\CbReleaseIdRcb\Reactions::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbReleasesCbReleaseIdRcbReactions();
                }
                $operation = new Operation\Reactions\ListForRelease($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\CbReleaseIdRcb\Reactions::class], $params['owner'], $params['repo'], $params['release_id'], $params['content'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Reaction|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Reactions\CreateForRelease::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'release_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\CbReleaseIdRcb\Reactions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\CbReleaseIdRcb\Reactions::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbReleasesCbReleaseIdRcbReactions();
                }
                $operation = new Operation\Reactions\CreateForRelease($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Releases\CbReleaseIdRcb\Reactions::class], $params['owner'], $params['repo'], $params['release_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Reaction|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Reactions\DeleteForRelease::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'release_id', 'reaction_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Reactions\DeleteForRelease($params['owner'], $params['repo'], $params['release_id'], $params['reaction_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListCacheInfo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Replicas\Caches::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Replicas\Caches::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbReplicasCaches();
                }
                $operation = new Operation\Repos\ListCacheInfo($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Replicas\Caches::class], $params['owner'], $params['repo'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Repos\ListCacheInfo\Response\Applicationjson\H200|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\SecretScanning\ListAlertsForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'state', 'secret_type', 'resolution', 'sort', 'direction', 'page', 'per_page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\SecretScanning\Alerts::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\SecretScanning\Alerts::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbSecretScanningAlerts();
                }
                $operation = new Operation\SecretScanning\ListAlertsForRepo($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\SecretScanning\Alerts::class], $params['owner'], $params['repo'], $params['state'], $params['secret_type'], $params['resolution'], $params['sort'], $params['direction'], $params['page'], $params['per_page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\SecretScanningAlert|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\SecretScanning\GetAlert::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'alert_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\SecretDashScanning\Alerts\CbAlertNumberRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\SecretDashScanning\Alerts\CbAlertNumberRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbSecretDashScanningAlertsCbAlertNumberRcb();
                }
                $operation = new Operation\SecretScanning\GetAlert($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\SecretDashScanning\Alerts\CbAlertNumberRcb::class], $params['owner'], $params['repo'], $params['alert_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\SecretScanningAlert|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\SecretScanning\UpdateAlert::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'alert_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\SecretDashScanning\Alerts\CbAlertNumberRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\SecretDashScanning\Alerts\CbAlertNumberRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbSecretDashScanningAlertsCbAlertNumberRcb();
                }
                $operation = new Operation\SecretScanning\UpdateAlert($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\SecretDashScanning\Alerts\CbAlertNumberRcb::class], $params['owner'], $params['repo'], $params['alert_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\SecretScanningAlert|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\SecretScanning\ListLocationsForAlert::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'alert_number', 'page', 'per_page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\SecretDashScanning\Alerts\CbAlertNumberRcb\Locations::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\SecretDashScanning\Alerts\CbAlertNumberRcb\Locations::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbSecretDashScanningAlertsCbAlertNumberRcbLocations();
                }
                $operation = new Operation\SecretScanning\ListLocationsForAlert($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\SecretDashScanning\Alerts\CbAlertNumberRcb\Locations::class], $params['owner'], $params['repo'], $params['alert_number'], $params['page'], $params['per_page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\SecretScanningLocation|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\ListStargazersForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Stargazers::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Stargazers::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbStargazers();
                }
                $operation = new Operation\Activity\ListStargazersForRepo($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Stargazers::class], $params['owner'], $params['repo'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Activity\ListStargazersForRepo\Response\Applicationjson\H200|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetCodeFrequencyStats::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Stats\CodeFrequency::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Stats\CodeFrequency::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbStatsCodeFrequency();
                }
                $operation = new Operation\Repos\GetCodeFrequencyStats($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Stats\CodeFrequency::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Repos\GetCodeFrequencyStats\Response\Applicationjson\H200|Schema\AuditLogEvent\Config {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetCommitActivityStats::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Stats\CommitActivity::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Stats\CommitActivity::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbStatsCommitActivity();
                }
                $operation = new Operation\Repos\GetCommitActivityStats($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Stats\CommitActivity::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\CommitActivity|Schema\AuditLogEvent\Config {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetContributorsStats::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Stats\Contributors::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Stats\Contributors::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbStatsContributors();
                }
                $operation = new Operation\Repos\GetContributorsStats($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Stats\Contributors::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ContributorActivity|Schema\AuditLogEvent\Config {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetParticipationStats::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Stats\Participation::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Stats\Participation::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbStatsParticipation();
                }
                $operation = new Operation\Repos\GetParticipationStats($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Stats\Participation::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ParticipationStats|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetPunchCardStats::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Stats\PunchCard::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Stats\PunchCard::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbStatsPunchCard();
                }
                $operation = new Operation\Repos\GetPunchCardStats($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Stats\PunchCard::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Repos\GetCodeFrequencyStats\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\CreateCommitStatus::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'sha')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Statuses\CbShaRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Statuses\CbShaRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbStatusesCbShaRcb();
                }
                $operation = new Operation\Repos\CreateCommitStatus($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Statuses\CbShaRcb::class], $params['owner'], $params['repo'], $params['sha']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Status {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\ListWatchersForRepo::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Subscribers::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Subscribers::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbSubscribers();
                }
                $operation = new Operation\Activity\ListWatchersForRepo($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Subscribers::class], $params['owner'], $params['repo'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\SimpleUser {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\GetRepoSubscription::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Subscription::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Subscription::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbSubscription();
                }
                $operation = new Operation\Activity\GetRepoSubscription($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Subscription::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\RepositorySubscription|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\SetRepoSubscription::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Subscription::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Subscription::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbSubscription();
                }
                $operation = new Operation\Activity\SetRepoSubscription($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Subscription::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\RepositorySubscription {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\DeleteRepoSubscription::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Activity\DeleteRepoSubscription($params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListTags::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Tags::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Tags::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbTags();
                }
                $operation = new Operation\Repos\ListTags($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Tags::class], $params['owner'], $params['repo'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Tag {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListTagProtection::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Tags\Protection::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Tags\Protection::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbTagsProtection();
                }
                $operation = new Operation\Repos\ListTagProtection($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Tags\Protection::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TagProtection|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\CreateTagProtection::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Tags\Protection::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Tags\Protection::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbTagsProtection();
                }
                $operation = new Operation\Repos\CreateTagProtection($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Tags\Protection::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TagProtection|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\DeleteTagProtection::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'tag_protection_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Tags\Protection\CbTagProtectionIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Tags\Protection\CbTagProtectionIdRcb::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbTagsProtectionCbTagProtectionIdRcb();
                }
                $operation = new Operation\Repos\DeleteTagProtection($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Tags\Protection\CbTagProtectionIdRcb::class], $params['owner'], $params['repo'], $params['tag_protection_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\DownloadTarballArchive::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'ref')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Repos\DownloadTarballArchive($params['owner'], $params['repo'], $params['ref']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListTeams::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Teams::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Teams::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbTeams();
                }
                $operation = new Operation\Repos\ListTeams($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Teams::class], $params['owner'], $params['repo'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Team {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\GetAllTopics::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'page', 'per_page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Topics::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Topics::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbTopics();
                }
                $operation = new Operation\Repos\GetAllTopics($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Topics::class], $params['owner'], $params['repo'], $params['page'], $params['per_page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Topic|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ReplaceAllTopics::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Topics::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Topics::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbTopics();
                }
                $operation = new Operation\Repos\ReplaceAllTopics($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Topics::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Topic|Schema\BasicError|Schema\ValidationErrorSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\Transfer::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Transfer::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Transfer::class] = $this->hydrators->getObjectMapperOperationReposCbOwnerRcbCbRepoRcbTransfer();
                }
                $operation = new Operation\Repos\Transfer($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbOwnerRcb\CbRepoRcb\Transfer::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\MinimalRepository {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\DownloadZipballArchive::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo', 'ref')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Repos\DownloadZipballArchive($params['owner'], $params['repo'], $params['ref']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\CreateUsingTemplate::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('template_owner', 'template_repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repos\CbTemplateOwnerRcb\CbTemplateRepoRcb\Generate::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repos\CbTemplateOwnerRcb\CbTemplateRepoRcb\Generate::class] = $this->hydrators->getObjectMapperOperationReposCbTemplateOwnerRcbCbTemplateRepoRcbGenerate();
                }
                $operation = new Operation\Repos\CreateUsingTemplate($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repos\CbTemplateOwnerRcb\CbTemplateRepoRcb\Generate::class], $params['template_owner'], $params['template_repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Repository {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListPublic::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('since', 'visibility')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repositories::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repositories::class] = $this->hydrators->getObjectMapperOperationRepositories();
                }
                $operation = new Operation\Repos\ListPublic($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repositories::class], $params['since'], $params['visibility']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\MinimalRepository|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\ListEnvironmentSecrets::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('repository_id', 'environment_name', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repositories\CbRepositoryIdRcb\Environments\CbEnvironmentNameRcb\Secrets::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repositories\CbRepositoryIdRcb\Environments\CbEnvironmentNameRcb\Secrets::class] = $this->hydrators->getObjectMapperOperationRepositoriesCbRepositoryIdRcbEnvironmentsCbEnvironmentNameRcbSecrets();
                }
                $operation = new Operation\Actions\ListEnvironmentSecrets($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repositories\CbRepositoryIdRcb\Environments\CbEnvironmentNameRcb\Secrets::class], $params['repository_id'], $params['environment_name'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Actions\ListRepoSecrets\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\GetEnvironmentPublicKey::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('repository_id', 'environment_name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repositories\CbRepositoryIdRcb\Environments\CbEnvironmentNameRcb\Secrets\PublicDashKey::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repositories\CbRepositoryIdRcb\Environments\CbEnvironmentNameRcb\Secrets\PublicDashKey::class] = $this->hydrators->getObjectMapperOperationRepositoriesCbRepositoryIdRcbEnvironmentsCbEnvironmentNameRcbSecretsPublicDashKey();
                }
                $operation = new Operation\Actions\GetEnvironmentPublicKey($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repositories\CbRepositoryIdRcb\Environments\CbEnvironmentNameRcb\Secrets\PublicDashKey::class], $params['repository_id'], $params['environment_name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ActionsPublicKey {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\GetEnvironmentSecret::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('repository_id', 'environment_name', 'secret_name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repositories\CbRepositoryIdRcb\Environments\CbEnvironmentNameRcb\Secrets\CbSecretNameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repositories\CbRepositoryIdRcb\Environments\CbEnvironmentNameRcb\Secrets\CbSecretNameRcb::class] = $this->hydrators->getObjectMapperOperationRepositoriesCbRepositoryIdRcbEnvironmentsCbEnvironmentNameRcbSecretsCbSecretNameRcb();
                }
                $operation = new Operation\Actions\GetEnvironmentSecret($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repositories\CbRepositoryIdRcb\Environments\CbEnvironmentNameRcb\Secrets\CbSecretNameRcb::class], $params['repository_id'], $params['environment_name'], $params['secret_name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ActionsSecret {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\CreateOrUpdateEnvironmentSecret::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('repository_id', 'environment_name', 'secret_name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Repositories\CbRepositoryIdRcb\Environments\CbEnvironmentNameRcb\Secrets\CbSecretNameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Repositories\CbRepositoryIdRcb\Environments\CbEnvironmentNameRcb\Secrets\CbSecretNameRcb::class] = $this->hydrators->getObjectMapperOperationRepositoriesCbRepositoryIdRcbEnvironmentsCbEnvironmentNameRcbSecretsCbSecretNameRcb();
                }
                $operation = new Operation\Actions\CreateOrUpdateEnvironmentSecret($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Repositories\CbRepositoryIdRcb\Environments\CbEnvironmentNameRcb\Secrets\CbSecretNameRcb::class], $params['repository_id'], $params['environment_name'], $params['secret_name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\EmptyObject {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Actions\DeleteEnvironmentSecret::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('repository_id', 'environment_name', 'secret_name')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Actions\DeleteEnvironmentSecret($params['repository_id'], $params['environment_name'], $params['secret_name']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\ListProvisionedGroupsEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('filter', 'excludedAttributes', 'startIndex', 'count')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Scim\V2\Groups::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Scim\V2\Groups::class] = $this->hydrators->getObjectMapperOperationScimV2Groups();
                }
                $operation = new Operation\EnterpriseAdmin\ListProvisionedGroupsEnterprise($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Scim\V2\Groups::class], $params['filter'], $params['excludedAttributes'], $params['startIndex'], $params['count']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ScimEnterpriseGroupList|Schema\ScimError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\ProvisionEnterpriseGroup::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Scim\V2\Groups::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Scim\V2\Groups::class] = $this->hydrators->getObjectMapperOperationScimV2Groups();
                }
                $operation = new Operation\EnterpriseAdmin\ProvisionEnterpriseGroup($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Scim\V2\Groups::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ScimEnterpriseGroupResponse|Schema\ScimError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\GetProvisioningInformationForEnterpriseGroup::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('scim_group_id', 'excludedAttributes')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Scim\V2\Groups\CbScimGroupIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Scim\V2\Groups\CbScimGroupIdRcb::class] = $this->hydrators->getObjectMapperOperationScimV2GroupsCbScimGroupIdRcb();
                }
                $operation = new Operation\EnterpriseAdmin\GetProvisioningInformationForEnterpriseGroup($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Scim\V2\Groups\CbScimGroupIdRcb::class], $params['scim_group_id'], $params['excludedAttributes']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ScimEnterpriseGroupResponse|Schema\ScimError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\SetInformationForProvisionedEnterpriseGroup::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('scim_group_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Scim\V2\Groups\CbScimGroupIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Scim\V2\Groups\CbScimGroupIdRcb::class] = $this->hydrators->getObjectMapperOperationScimV2GroupsCbScimGroupIdRcb();
                }
                $operation = new Operation\EnterpriseAdmin\SetInformationForProvisionedEnterpriseGroup($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Scim\V2\Groups\CbScimGroupIdRcb::class], $params['scim_group_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ScimEnterpriseGroupResponse|Schema\ScimError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\DeleteScimGroupFromEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('scim_group_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Scim\V2\Groups\CbScimGroupIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Scim\V2\Groups\CbScimGroupIdRcb::class] = $this->hydrators->getObjectMapperOperationScimV2GroupsCbScimGroupIdRcb();
                }
                $operation = new Operation\EnterpriseAdmin\DeleteScimGroupFromEnterprise($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Scim\V2\Groups\CbScimGroupIdRcb::class], $params['scim_group_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ScimError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\UpdateAttributeForEnterpriseGroup::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('scim_group_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Scim\V2\Groups\CbScimGroupIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Scim\V2\Groups\CbScimGroupIdRcb::class] = $this->hydrators->getObjectMapperOperationScimV2GroupsCbScimGroupIdRcb();
                }
                $operation = new Operation\EnterpriseAdmin\UpdateAttributeForEnterpriseGroup($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Scim\V2\Groups\CbScimGroupIdRcb::class], $params['scim_group_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ScimEnterpriseGroupResponse|Schema\ScimError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\ListProvisionedIdentitiesEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('filter', 'excludedAttributes', 'startIndex', 'count')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Scim\V2\Users::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Scim\V2\Users::class] = $this->hydrators->getObjectMapperOperationScimV2Users();
                }
                $operation = new Operation\EnterpriseAdmin\ListProvisionedIdentitiesEnterprise($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Scim\V2\Users::class], $params['filter'], $params['excludedAttributes'], $params['startIndex'], $params['count']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ScimEnterpriseUserList|Schema\ScimError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\ProvisionEnterpriseUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Scim\V2\Users::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Scim\V2\Users::class] = $this->hydrators->getObjectMapperOperationScimV2Users();
                }
                $operation = new Operation\EnterpriseAdmin\ProvisionEnterpriseUser($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Scim\V2\Users::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ScimEnterpriseUserResponse|Schema\ScimError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\GetProvisioningInformationForEnterpriseUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('scim_user_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Scim\V2\Users\CbScimUserIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Scim\V2\Users\CbScimUserIdRcb::class] = $this->hydrators->getObjectMapperOperationScimV2UsersCbScimUserIdRcb();
                }
                $operation = new Operation\EnterpriseAdmin\GetProvisioningInformationForEnterpriseUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Scim\V2\Users\CbScimUserIdRcb::class], $params['scim_user_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ScimEnterpriseUserResponse|Schema\ScimError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\SetInformationForProvisionedEnterpriseUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('scim_user_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Scim\V2\Users\CbScimUserIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Scim\V2\Users\CbScimUserIdRcb::class] = $this->hydrators->getObjectMapperOperationScimV2UsersCbScimUserIdRcb();
                }
                $operation = new Operation\EnterpriseAdmin\SetInformationForProvisionedEnterpriseUser($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Scim\V2\Users\CbScimUserIdRcb::class], $params['scim_user_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ScimEnterpriseUserResponse|Schema\ScimError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\DeleteUserFromEnterprise::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('scim_user_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Scim\V2\Users\CbScimUserIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Scim\V2\Users\CbScimUserIdRcb::class] = $this->hydrators->getObjectMapperOperationScimV2UsersCbScimUserIdRcb();
                }
                $operation = new Operation\EnterpriseAdmin\DeleteUserFromEnterprise($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Scim\V2\Users\CbScimUserIdRcb::class], $params['scim_user_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ScimError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\UpdateAttributeForEnterpriseUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('scim_user_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Scim\V2\Users\CbScimUserIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Scim\V2\Users\CbScimUserIdRcb::class] = $this->hydrators->getObjectMapperOperationScimV2UsersCbScimUserIdRcb();
                }
                $operation = new Operation\EnterpriseAdmin\UpdateAttributeForEnterpriseUser($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Scim\V2\Users\CbScimUserIdRcb::class], $params['scim_user_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ScimEnterpriseUserResponse|Schema\ScimError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Search\Code::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('q', 'sort', 'order', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Search\Code::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Search\Code::class] = $this->hydrators->getObjectMapperOperationSearchCode();
                }
                $operation = new Operation\Search\Code($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Search\Code::class], $params['q'], $params['sort'], $params['order'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Search\Code\Response\Applicationjson\H200|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Search\Commits::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('q', 'sort', 'order', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Search\Commits::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Search\Commits::class] = $this->hydrators->getObjectMapperOperationSearchCommits();
                }
                $operation = new Operation\Search\Commits($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Search\Commits::class], $params['q'], $params['sort'], $params['order'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Search\Commits\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Search\IssuesAndPullRequests::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('q', 'sort', 'order', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Search\Issues::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Search\Issues::class] = $this->hydrators->getObjectMapperOperationSearchIssues();
                }
                $operation = new Operation\Search\IssuesAndPullRequests($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Search\Issues::class], $params['q'], $params['sort'], $params['order'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Search\IssuesAndPullRequests\Response\Applicationjson\H200|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Search\Labels::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('repository_id', 'q', 'sort', 'order', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Search\Labels::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Search\Labels::class] = $this->hydrators->getObjectMapperOperationSearchLabels();
                }
                $operation = new Operation\Search\Labels($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Search\Labels::class], $params['repository_id'], $params['q'], $params['sort'], $params['order'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Search\Labels\Response\Applicationjson\H200|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Search\Repos::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('q', 'sort', 'order', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Search\Repositories::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Search\Repositories::class] = $this->hydrators->getObjectMapperOperationSearchRepositories();
                }
                $operation = new Operation\Search\Repos($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Search\Repositories::class], $params['q'], $params['sort'], $params['order'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Search\Repos\Response\Applicationjson\H200|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Search\Topics::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('q', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Search\Topics::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Search\Topics::class] = $this->hydrators->getObjectMapperOperationSearchTopics();
                }
                $operation = new Operation\Search\Topics($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Search\Topics::class], $params['q'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Search\Topics\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Search\Users::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('q', 'sort', 'order', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Search\Users::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Search\Users::class] = $this->hydrators->getObjectMapperOperationSearchUsers();
                }
                $operation = new Operation\Search\Users($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Search\Users::class], $params['q'], $params['sort'], $params['order'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Search\Users\Response\Applicationjson\H200|Schema\Operation\SecretScanning\ListAlertsForEnterprise\Response\Applicationjson\H503|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\GetConfigurationStatus::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Setup\Api\Configcheck::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Setup\Api\Configcheck::class] = $this->hydrators->getObjectMapperOperationSetupApiConfigcheck();
                }
                $operation = new Operation\EnterpriseAdmin\GetConfigurationStatus($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Setup\Api\Configcheck::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\ConfigurationStatus {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\StartConfigurationProcess::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\EnterpriseAdmin\StartConfigurationProcess();
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\GetMaintenanceStatus::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Setup\Api\Maintenance::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Setup\Api\Maintenance::class] = $this->hydrators->getObjectMapperOperationSetupApiMaintenance();
                }
                $operation = new Operation\EnterpriseAdmin\GetMaintenanceStatus($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Setup\Api\Maintenance::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\MaintenanceStatus {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\EnableOrDisableMaintenanceMode::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Setup\Api\Maintenance::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Setup\Api\Maintenance::class] = $this->hydrators->getObjectMapperOperationSetupApiMaintenance();
                }
                $operation = new Operation\EnterpriseAdmin\EnableOrDisableMaintenanceMode($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Setup\Api\Maintenance::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\MaintenanceStatus {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\GetSettings::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Setup\Api\Settings::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Setup\Api\Settings::class] = $this->hydrators->getObjectMapperOperationSetupApiSettings();
                }
                $operation = new Operation\EnterpriseAdmin\GetSettings($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Setup\Api\Settings::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\EnterpriseSettings {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\SetSettings::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\EnterpriseAdmin\SetSettings($this->requestSchemaValidator);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\GetAllAuthorizedSshKeys::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Setup\Api\Settings\AuthorizedKeys::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Setup\Api\Settings\AuthorizedKeys::class] = $this->hydrators->getObjectMapperOperationSetupApiSettingsAuthorizedKeys();
                }
                $operation = new Operation\EnterpriseAdmin\GetAllAuthorizedSshKeys($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Setup\Api\Settings\AuthorizedKeys::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\SshKey {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\AddAuthorizedSshKey::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Setup\Api\Settings\AuthorizedKeys::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Setup\Api\Settings\AuthorizedKeys::class] = $this->hydrators->getObjectMapperOperationSetupApiSettingsAuthorizedKeys();
                }
                $operation = new Operation\EnterpriseAdmin\AddAuthorizedSshKey($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Setup\Api\Settings\AuthorizedKeys::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\SshKey {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\RemoveAuthorizedSshKey::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Setup\Api\Settings\AuthorizedKeys::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Setup\Api\Settings\AuthorizedKeys::class] = $this->hydrators->getObjectMapperOperationSetupApiSettingsAuthorizedKeys();
                }
                $operation = new Operation\EnterpriseAdmin\RemoveAuthorizedSshKey($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Setup\Api\Settings\AuthorizedKeys::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\SshKey {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\CreateEnterpriseServerLicense::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\EnterpriseAdmin\CreateEnterpriseServerLicense($this->requestSchemaValidator);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\UpgradeLicense::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\EnterpriseAdmin\UpgradeLicense($this->requestSchemaValidator);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\GetLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Teams\CbTeamIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb::class] = $this->hydrators->getObjectMapperOperationTeamsCbTeamIdRcb();
                }
                $operation = new Operation\Teams\GetLegacy($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb::class], $params['team_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamFull|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\DeleteLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Teams\CbTeamIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb::class] = $this->hydrators->getObjectMapperOperationTeamsCbTeamIdRcb();
                }
                $operation = new Operation\Teams\DeleteLegacy($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb::class], $params['team_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\UpdateLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Teams\CbTeamIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb::class] = $this->hydrators->getObjectMapperOperationTeamsCbTeamIdRcb();
                }
                $operation = new Operation\Teams\UpdateLegacy($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb::class], $params['team_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamFull|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\ListDiscussionsLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id', 'direction', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Teams\CbTeamIdRcb\Discussions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Discussions::class] = $this->hydrators->getObjectMapperOperationTeamsCbTeamIdRcbDiscussions();
                }
                $operation = new Operation\Teams\ListDiscussionsLegacy($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Discussions::class], $params['team_id'], $params['direction'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamDiscussion {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\CreateDiscussionLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Teams\CbTeamIdRcb\Discussions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Discussions::class] = $this->hydrators->getObjectMapperOperationTeamsCbTeamIdRcbDiscussions();
                }
                $operation = new Operation\Teams\CreateDiscussionLegacy($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Discussions::class], $params['team_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamDiscussion {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\GetDiscussionLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id', 'discussion_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Teams\CbTeamIdRcb\Discussions\CbDiscussionNumberRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Discussions\CbDiscussionNumberRcb::class] = $this->hydrators->getObjectMapperOperationTeamsCbTeamIdRcbDiscussionsCbDiscussionNumberRcb();
                }
                $operation = new Operation\Teams\GetDiscussionLegacy($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Discussions\CbDiscussionNumberRcb::class], $params['team_id'], $params['discussion_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamDiscussion {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\DeleteDiscussionLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id', 'discussion_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Teams\DeleteDiscussionLegacy($params['team_id'], $params['discussion_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\UpdateDiscussionLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id', 'discussion_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Teams\CbTeamIdRcb\Discussions\CbDiscussionNumberRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Discussions\CbDiscussionNumberRcb::class] = $this->hydrators->getObjectMapperOperationTeamsCbTeamIdRcbDiscussionsCbDiscussionNumberRcb();
                }
                $operation = new Operation\Teams\UpdateDiscussionLegacy($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Discussions\CbDiscussionNumberRcb::class], $params['team_id'], $params['discussion_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamDiscussion {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\ListDiscussionCommentsLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id', 'discussion_number', 'direction', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Teams\CbTeamIdRcb\Discussions\CbDiscussionNumberRcb\Comments::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Discussions\CbDiscussionNumberRcb\Comments::class] = $this->hydrators->getObjectMapperOperationTeamsCbTeamIdRcbDiscussionsCbDiscussionNumberRcbComments();
                }
                $operation = new Operation\Teams\ListDiscussionCommentsLegacy($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Discussions\CbDiscussionNumberRcb\Comments::class], $params['team_id'], $params['discussion_number'], $params['direction'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamDiscussionComment {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\CreateDiscussionCommentLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id', 'discussion_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Teams\CbTeamIdRcb\Discussions\CbDiscussionNumberRcb\Comments::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Discussions\CbDiscussionNumberRcb\Comments::class] = $this->hydrators->getObjectMapperOperationTeamsCbTeamIdRcbDiscussionsCbDiscussionNumberRcbComments();
                }
                $operation = new Operation\Teams\CreateDiscussionCommentLegacy($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Discussions\CbDiscussionNumberRcb\Comments::class], $params['team_id'], $params['discussion_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamDiscussionComment {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\GetDiscussionCommentLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id', 'discussion_number', 'comment_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Teams\CbTeamIdRcb\Discussions\CbDiscussionNumberRcb\Comments\CbCommentNumberRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Discussions\CbDiscussionNumberRcb\Comments\CbCommentNumberRcb::class] = $this->hydrators->getObjectMapperOperationTeamsCbTeamIdRcbDiscussionsCbDiscussionNumberRcbCommentsCbCommentNumberRcb();
                }
                $operation = new Operation\Teams\GetDiscussionCommentLegacy($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Discussions\CbDiscussionNumberRcb\Comments\CbCommentNumberRcb::class], $params['team_id'], $params['discussion_number'], $params['comment_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamDiscussionComment {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\DeleteDiscussionCommentLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id', 'discussion_number', 'comment_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Teams\DeleteDiscussionCommentLegacy($params['team_id'], $params['discussion_number'], $params['comment_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\UpdateDiscussionCommentLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id', 'discussion_number', 'comment_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Teams\CbTeamIdRcb\Discussions\CbDiscussionNumberRcb\Comments\CbCommentNumberRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Discussions\CbDiscussionNumberRcb\Comments\CbCommentNumberRcb::class] = $this->hydrators->getObjectMapperOperationTeamsCbTeamIdRcbDiscussionsCbDiscussionNumberRcbCommentsCbCommentNumberRcb();
                }
                $operation = new Operation\Teams\UpdateDiscussionCommentLegacy($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Discussions\CbDiscussionNumberRcb\Comments\CbCommentNumberRcb::class], $params['team_id'], $params['discussion_number'], $params['comment_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamDiscussionComment {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Reactions\ListForTeamDiscussionCommentLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id', 'discussion_number', 'comment_number', 'content', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Teams\CbTeamIdRcb\Discussions\CbDiscussionNumberRcb\Comments\CbCommentNumberRcb\Reactions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Discussions\CbDiscussionNumberRcb\Comments\CbCommentNumberRcb\Reactions::class] = $this->hydrators->getObjectMapperOperationTeamsCbTeamIdRcbDiscussionsCbDiscussionNumberRcbCommentsCbCommentNumberRcbReactions();
                }
                $operation = new Operation\Reactions\ListForTeamDiscussionCommentLegacy($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Discussions\CbDiscussionNumberRcb\Comments\CbCommentNumberRcb\Reactions::class], $params['team_id'], $params['discussion_number'], $params['comment_number'], $params['content'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Reaction {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Reactions\CreateForTeamDiscussionCommentLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id', 'discussion_number', 'comment_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Teams\CbTeamIdRcb\Discussions\CbDiscussionNumberRcb\Comments\CbCommentNumberRcb\Reactions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Discussions\CbDiscussionNumberRcb\Comments\CbCommentNumberRcb\Reactions::class] = $this->hydrators->getObjectMapperOperationTeamsCbTeamIdRcbDiscussionsCbDiscussionNumberRcbCommentsCbCommentNumberRcbReactions();
                }
                $operation = new Operation\Reactions\CreateForTeamDiscussionCommentLegacy($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Discussions\CbDiscussionNumberRcb\Comments\CbCommentNumberRcb\Reactions::class], $params['team_id'], $params['discussion_number'], $params['comment_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Reaction {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Reactions\ListForTeamDiscussionLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id', 'discussion_number', 'content', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Teams\CbTeamIdRcb\Discussions\CbDiscussionNumberRcb\Reactions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Discussions\CbDiscussionNumberRcb\Reactions::class] = $this->hydrators->getObjectMapperOperationTeamsCbTeamIdRcbDiscussionsCbDiscussionNumberRcbReactions();
                }
                $operation = new Operation\Reactions\ListForTeamDiscussionLegacy($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Discussions\CbDiscussionNumberRcb\Reactions::class], $params['team_id'], $params['discussion_number'], $params['content'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Reaction {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Reactions\CreateForTeamDiscussionLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id', 'discussion_number')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Teams\CbTeamIdRcb\Discussions\CbDiscussionNumberRcb\Reactions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Discussions\CbDiscussionNumberRcb\Reactions::class] = $this->hydrators->getObjectMapperOperationTeamsCbTeamIdRcbDiscussionsCbDiscussionNumberRcbReactions();
                }
                $operation = new Operation\Reactions\CreateForTeamDiscussionLegacy($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Discussions\CbDiscussionNumberRcb\Reactions::class], $params['team_id'], $params['discussion_number']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Reaction {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\ListMembersLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id', 'role', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Teams\CbTeamIdRcb\Members::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Members::class] = $this->hydrators->getObjectMapperOperationTeamsCbTeamIdRcbMembers();
                }
                $operation = new Operation\Teams\ListMembersLegacy($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Members::class], $params['team_id'], $params['role'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\SimpleUser|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\GetMemberLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id', 'username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Teams\GetMemberLegacy($params['team_id'], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\AddMemberLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id', 'username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Teams\CbTeamIdRcb\Members\CbUsernameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Members\CbUsernameRcb::class] = $this->hydrators->getObjectMapperOperationTeamsCbTeamIdRcbMembersCbUsernameRcb();
                }
                $operation = new Operation\Teams\AddMemberLegacy($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Members\CbUsernameRcb::class], $params['team_id'], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\RemoveMemberLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id', 'username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Teams\RemoveMemberLegacy($params['team_id'], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\GetMembershipForUserLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id', 'username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Teams\CbTeamIdRcb\Memberships\CbUsernameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Memberships\CbUsernameRcb::class] = $this->hydrators->getObjectMapperOperationTeamsCbTeamIdRcbMembershipsCbUsernameRcb();
                }
                $operation = new Operation\Teams\GetMembershipForUserLegacy($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Memberships\CbUsernameRcb::class], $params['team_id'], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamMembership|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\AddOrUpdateMembershipForUserLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id', 'username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Teams\CbTeamIdRcb\Memberships\CbUsernameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Memberships\CbUsernameRcb::class] = $this->hydrators->getObjectMapperOperationTeamsCbTeamIdRcbMembershipsCbUsernameRcb();
                }
                $operation = new Operation\Teams\AddOrUpdateMembershipForUserLegacy($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Memberships\CbUsernameRcb::class], $params['team_id'], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamMembership|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\RemoveMembershipForUserLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id', 'username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Teams\RemoveMembershipForUserLegacy($params['team_id'], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\ListProjectsLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Teams\CbTeamIdRcb\Projects::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Projects::class] = $this->hydrators->getObjectMapperOperationTeamsCbTeamIdRcbProjects();
                }
                $operation = new Operation\Teams\ListProjectsLegacy($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Projects::class], $params['team_id'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamProject|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\CheckPermissionsForProjectLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id', 'project_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Teams\CbTeamIdRcb\Projects\CbProjectIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Projects\CbProjectIdRcb::class] = $this->hydrators->getObjectMapperOperationTeamsCbTeamIdRcbProjectsCbProjectIdRcb();
                }
                $operation = new Operation\Teams\CheckPermissionsForProjectLegacy($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Projects\CbProjectIdRcb::class], $params['team_id'], $params['project_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamProject {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\AddOrUpdateProjectPermissionsLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id', 'project_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Teams\CbTeamIdRcb\Projects\CbProjectIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Projects\CbProjectIdRcb::class] = $this->hydrators->getObjectMapperOperationTeamsCbTeamIdRcbProjectsCbProjectIdRcb();
                }
                $operation = new Operation\Teams\AddOrUpdateProjectPermissionsLegacy($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Projects\CbProjectIdRcb::class], $params['team_id'], $params['project_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Orgs\RemoveOutsideCollaborator\Response\Applicationjson\H422|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\RemoveProjectLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id', 'project_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Teams\CbTeamIdRcb\Projects\CbProjectIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Projects\CbProjectIdRcb::class] = $this->hydrators->getObjectMapperOperationTeamsCbTeamIdRcbProjectsCbProjectIdRcb();
                }
                $operation = new Operation\Teams\RemoveProjectLegacy($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Projects\CbProjectIdRcb::class], $params['team_id'], $params['project_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\ListReposLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Teams\CbTeamIdRcb\Repos::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Repos::class] = $this->hydrators->getObjectMapperOperationTeamsCbTeamIdRcbRepos();
                }
                $operation = new Operation\Teams\ListReposLegacy($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Repos::class], $params['team_id'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\MinimalRepository|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\CheckPermissionsForRepoLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id', 'owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Teams\CbTeamIdRcb\Repos\CbOwnerRcb\CbRepoRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Repos\CbOwnerRcb\CbRepoRcb::class] = $this->hydrators->getObjectMapperOperationTeamsCbTeamIdRcbReposCbOwnerRcbCbRepoRcb();
                }
                $operation = new Operation\Teams\CheckPermissionsForRepoLegacy($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Repos\CbOwnerRcb\CbRepoRcb::class], $params['team_id'], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamRepository {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\AddOrUpdateRepoPermissionsLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id', 'owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Teams\CbTeamIdRcb\Repos\CbOwnerRcb\CbRepoRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Repos\CbOwnerRcb\CbRepoRcb::class] = $this->hydrators->getObjectMapperOperationTeamsCbTeamIdRcbReposCbOwnerRcbCbRepoRcb();
                }
                $operation = new Operation\Teams\AddOrUpdateRepoPermissionsLegacy($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Repos\CbOwnerRcb\CbRepoRcb::class], $params['team_id'], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\RemoveRepoLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id', 'owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Teams\RemoveRepoLegacy($params['team_id'], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\ListChildLegacy::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('team_id', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Teams\CbTeamIdRcb\Teams::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Teams::class] = $this->hydrators->getObjectMapperOperationTeamsCbTeamIdRcbTeams();
                }
                $operation = new Operation\Teams\ListChildLegacy($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Teams\CbTeamIdRcb\Teams::class], $params['team_id'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Team|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Users\GetAuthenticated::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User::class] = $this->hydrators->getObjectMapperOperationUser();
                }
                $operation = new Operation\Users\GetAuthenticated($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Users\GetAuthenticated\Response\Applicationjson\H200|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Users\UpdateAuthenticated::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User::class] = $this->hydrators->getObjectMapperOperationUser();
                }
                $operation = new Operation\Users\UpdateAuthenticated($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\PrivateUser|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Users\ListEmailsForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Emails::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Emails::class] = $this->hydrators->getObjectMapperOperationUserEmails();
                }
                $operation = new Operation\Users\ListEmailsForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Emails::class], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Email|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Users\AddEmailForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Emails::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Emails::class] = $this->hydrators->getObjectMapperOperationUserEmails();
                }
                $operation = new Operation\Users\AddEmailForAuthenticatedUser($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Emails::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Email|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Users\DeleteEmailForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Emails::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Emails::class] = $this->hydrators->getObjectMapperOperationUserEmails();
                }
                $operation = new Operation\Users\DeleteEmailForAuthenticatedUser($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Emails::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Users\ListFollowersForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Followers::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Followers::class] = $this->hydrators->getObjectMapperOperationUserFollowers();
                }
                $operation = new Operation\Users\ListFollowersForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Followers::class], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\SimpleUser|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Users\ListFollowedByAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Following::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Following::class] = $this->hydrators->getObjectMapperOperationUserFollowing();
                }
                $operation = new Operation\Users\ListFollowedByAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Following::class], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\SimpleUser|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Users\CheckPersonIsFollowedByAuthenticated::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Following\CbUsernameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Following\CbUsernameRcb::class] = $this->hydrators->getObjectMapperOperationUserFollowingCbUsernameRcb();
                }
                $operation = new Operation\Users\CheckPersonIsFollowedByAuthenticated($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Following\CbUsernameRcb::class], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Users\Follow::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Following\CbUsernameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Following\CbUsernameRcb::class] = $this->hydrators->getObjectMapperOperationUserFollowingCbUsernameRcb();
                }
                $operation = new Operation\Users\Follow($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Following\CbUsernameRcb::class], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Users\Unfollow::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Following\CbUsernameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Following\CbUsernameRcb::class] = $this->hydrators->getObjectMapperOperationUserFollowingCbUsernameRcb();
                }
                $operation = new Operation\Users\Unfollow($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Following\CbUsernameRcb::class], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Users\ListGpgKeysForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\GpgKeys::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\GpgKeys::class] = $this->hydrators->getObjectMapperOperationUserGpgKeys();
                }
                $operation = new Operation\Users\ListGpgKeysForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\GpgKeys::class], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\GpgKey|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Users\CreateGpgKeyForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\GpgKeys::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\GpgKeys::class] = $this->hydrators->getObjectMapperOperationUserGpgKeys();
                }
                $operation = new Operation\Users\CreateGpgKeyForAuthenticatedUser($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\GpgKeys::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\GpgKey|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Users\GetGpgKeyForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('gpg_key_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\GpgKeys\CbGpgKeyIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\GpgKeys\CbGpgKeyIdRcb::class] = $this->hydrators->getObjectMapperOperationUserGpgKeysCbGpgKeyIdRcb();
                }
                $operation = new Operation\Users\GetGpgKeyForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\GpgKeys\CbGpgKeyIdRcb::class], $params['gpg_key_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\GpgKey|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Users\DeleteGpgKeyForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('gpg_key_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\GpgKeys\CbGpgKeyIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\GpgKeys\CbGpgKeyIdRcb::class] = $this->hydrators->getObjectMapperOperationUserGpgKeysCbGpgKeyIdRcb();
                }
                $operation = new Operation\Users\DeleteGpgKeyForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\GpgKeys\CbGpgKeyIdRcb::class], $params['gpg_key_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Apps\ListInstallationsForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Installations::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Installations::class] = $this->hydrators->getObjectMapperOperationUserInstallations();
                }
                $operation = new Operation\Apps\ListInstallationsForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Installations::class], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Orgs\ListAppInstallations\Response\Applicationjson\H200|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Apps\ListInstallationReposForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('installation_id', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Installations\CbInstallationIdRcb\Repositories::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Installations\CbInstallationIdRcb\Repositories::class] = $this->hydrators->getObjectMapperOperationUserInstallationsCbInstallationIdRcbRepositories();
                }
                $operation = new Operation\Apps\ListInstallationReposForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Installations\CbInstallationIdRcb\Repositories::class], $params['installation_id'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Apps\ListInstallationReposForAuthenticatedUser\Response\Applicationjson\H200|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Apps\AddRepoToInstallationForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('installation_id', 'repository_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Installations\CbInstallationIdRcb\Repositories\CbRepositoryIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Installations\CbInstallationIdRcb\Repositories\CbRepositoryIdRcb::class] = $this->hydrators->getObjectMapperOperationUserInstallationsCbInstallationIdRcbRepositoriesCbRepositoryIdRcb();
                }
                $operation = new Operation\Apps\AddRepoToInstallationForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Installations\CbInstallationIdRcb\Repositories\CbRepositoryIdRcb::class], $params['installation_id'], $params['repository_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Apps\RemoveRepoFromInstallationForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('installation_id', 'repository_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Installations\CbInstallationIdRcb\Repositories\CbRepositoryIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Installations\CbInstallationIdRcb\Repositories\CbRepositoryIdRcb::class] = $this->hydrators->getObjectMapperOperationUserInstallationsCbInstallationIdRcbRepositoriesCbRepositoryIdRcb();
                }
                $operation = new Operation\Apps\RemoveRepoFromInstallationForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Installations\CbInstallationIdRcb\Repositories\CbRepositoryIdRcb::class], $params['installation_id'], $params['repository_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Issues\ListForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('labels', 'since', 'filter', 'state', 'sort', 'direction', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Issues::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Issues::class] = $this->hydrators->getObjectMapperOperationUserIssues();
                }
                $operation = new Operation\Issues\ListForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Issues::class], $params['labels'], $params['since'], $params['filter'], $params['state'], $params['sort'], $params['direction'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Issue|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Users\ListPublicSshKeysForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Keys::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Keys::class] = $this->hydrators->getObjectMapperOperationUserKeys();
                }
                $operation = new Operation\Users\ListPublicSshKeysForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Keys::class], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Key|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Users\CreatePublicSshKeyForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Keys::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Keys::class] = $this->hydrators->getObjectMapperOperationUserKeys();
                }
                $operation = new Operation\Users\CreatePublicSshKeyForAuthenticatedUser($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Keys::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Key|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Users\GetPublicSshKeyForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('key_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Keys\CbKeyIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Keys\CbKeyIdRcb::class] = $this->hydrators->getObjectMapperOperationUserKeysCbKeyIdRcb();
                }
                $operation = new Operation\Users\GetPublicSshKeyForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Keys\CbKeyIdRcb::class], $params['key_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Key|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Users\DeletePublicSshKeyForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('key_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Keys\CbKeyIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Keys\CbKeyIdRcb::class] = $this->hydrators->getObjectMapperOperationUserKeysCbKeyIdRcb();
                }
                $operation = new Operation\Users\DeletePublicSshKeyForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Keys\CbKeyIdRcb::class], $params['key_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\ListMembershipsForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('state', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Memberships\Orgs::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Memberships\Orgs::class] = $this->hydrators->getObjectMapperOperationUserMembershipsOrgs();
                }
                $operation = new Operation\Orgs\ListMembershipsForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Memberships\Orgs::class], $params['state'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\OrgMembership|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\GetMembershipForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Memberships\Orgs\CbOrgRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Memberships\Orgs\CbOrgRcb::class] = $this->hydrators->getObjectMapperOperationUserMembershipsOrgsCbOrgRcb();
                }
                $operation = new Operation\Orgs\GetMembershipForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Memberships\Orgs\CbOrgRcb::class], $params['org']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\OrgMembership|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\UpdateMembershipForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('org')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Memberships\Orgs\CbOrgRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Memberships\Orgs\CbOrgRcb::class] = $this->hydrators->getObjectMapperOperationUserMembershipsOrgsCbOrgRcb();
                }
                $operation = new Operation\Orgs\UpdateMembershipForAuthenticatedUser($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Memberships\Orgs\CbOrgRcb::class], $params['org']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\OrgMembership|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Migrations\ListForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Migrations::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Migrations::class] = $this->hydrators->getObjectMapperOperationUserMigrations();
                }
                $operation = new Operation\Migrations\ListForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Migrations::class], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Migration|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Migrations\StartForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Migrations::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Migrations::class] = $this->hydrators->getObjectMapperOperationUserMigrations();
                }
                $operation = new Operation\Migrations\StartForAuthenticatedUser($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Migrations::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Migration|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Migrations\GetArchiveForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('migration_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Migrations\CbMigrationIdRcb\Archive::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Migrations\CbMigrationIdRcb\Archive::class] = $this->hydrators->getObjectMapperOperationUserMigrationsCbMigrationIdRcbArchive();
                }
                $operation = new Operation\Migrations\GetArchiveForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Migrations\CbMigrationIdRcb\Archive::class], $params['migration_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Migrations\ListReposForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('migration_id', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Migrations\CbMigrationIdRcb\Repositories::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Migrations\CbMigrationIdRcb\Repositories::class] = $this->hydrators->getObjectMapperOperationUserMigrationsCbMigrationIdRcbRepositories();
                }
                $operation = new Operation\Migrations\ListReposForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Migrations\CbMigrationIdRcb\Repositories::class], $params['migration_id'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\MinimalRepository|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\ListForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Orgs::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Orgs::class] = $this->hydrators->getObjectMapperOperationUserOrgs();
                }
                $operation = new Operation\Orgs\ListForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Orgs::class], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\OrganizationSimple|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Projects\CreateForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Projects::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Projects::class] = $this->hydrators->getObjectMapperOperationUserProjects();
                }
                $operation = new Operation\Projects\CreateForAuthenticatedUser($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Projects::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Project|Schema\BasicError|Schema\ValidationErrorSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Users\ListPublicEmailsForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\PublicEmails::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\PublicEmails::class] = $this->hydrators->getObjectMapperOperationUserPublicEmails();
                }
                $operation = new Operation\Users\ListPublicEmailsForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\PublicEmails::class], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Email|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('direction', 'since', 'before', 'visibility', 'affiliation', 'type', 'sort', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Repos::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Repos::class] = $this->hydrators->getObjectMapperOperationUserRepos();
                }
                $operation = new Operation\Repos\ListForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Repos::class], $params['direction'], $params['since'], $params['before'], $params['visibility'], $params['affiliation'], $params['type'], $params['sort'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Repository|Schema\ValidationError|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\CreateForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Repos::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Repos::class] = $this->hydrators->getObjectMapperOperationUserRepos();
                }
                $operation = new Operation\Repos\CreateForAuthenticatedUser($this->requestSchemaValidator, $this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Repos::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Repository|Schema\BasicError|Schema\ValidationError|Schema\ScimError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListInvitationsForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\RepositoryInvitations::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\RepositoryInvitations::class] = $this->hydrators->getObjectMapperOperationUserRepositoryInvitations();
                }
                $operation = new Operation\Repos\ListInvitationsForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\RepositoryInvitations::class], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\RepositoryInvitation|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\DeclineInvitationForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('invitation_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\RepositoryInvitations\CbInvitationIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\RepositoryInvitations\CbInvitationIdRcb::class] = $this->hydrators->getObjectMapperOperationUserRepositoryInvitationsCbInvitationIdRcb();
                }
                $operation = new Operation\Repos\DeclineInvitationForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\RepositoryInvitations\CbInvitationIdRcb::class], $params['invitation_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\AcceptInvitationForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('invitation_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\RepositoryInvitations\CbInvitationIdRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\RepositoryInvitations\CbInvitationIdRcb::class] = $this->hydrators->getObjectMapperOperationUserRepositoryInvitationsCbInvitationIdRcb();
                }
                $operation = new Operation\Repos\AcceptInvitationForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\RepositoryInvitations\CbInvitationIdRcb::class], $params['invitation_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\ListReposStarredByAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('sort', 'direction', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Starred::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Starred::class] = $this->hydrators->getObjectMapperOperationUserStarred();
                }
                $operation = new Operation\Activity\ListReposStarredByAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Starred::class], $params['sort'], $params['direction'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Repository|Schema\StarredRepository|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\CheckRepoIsStarredByAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Starred\CbOwnerRcb\CbRepoRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Starred\CbOwnerRcb\CbRepoRcb::class] = $this->hydrators->getObjectMapperOperationUserStarredCbOwnerRcbCbRepoRcb();
                }
                $operation = new Operation\Activity\CheckRepoIsStarredByAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Starred\CbOwnerRcb\CbRepoRcb::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\StarRepoForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Starred\CbOwnerRcb\CbRepoRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Starred\CbOwnerRcb\CbRepoRcb::class] = $this->hydrators->getObjectMapperOperationUserStarredCbOwnerRcbCbRepoRcb();
                }
                $operation = new Operation\Activity\StarRepoForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Starred\CbOwnerRcb\CbRepoRcb::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\UnstarRepoForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('owner', 'repo')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Starred\CbOwnerRcb\CbRepoRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Starred\CbOwnerRcb\CbRepoRcb::class] = $this->hydrators->getObjectMapperOperationUserStarredCbOwnerRcbCbRepoRcb();
                }
                $operation = new Operation\Activity\UnstarRepoForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Starred\CbOwnerRcb\CbRepoRcb::class], $params['owner'], $params['repo']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\ListWatchedReposForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Subscriptions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Subscriptions::class] = $this->hydrators->getObjectMapperOperationUserSubscriptions();
                }
                $operation = new Operation\Activity\ListWatchedReposForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Subscriptions::class], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\MinimalRepository|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Teams\ListForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\User\Teams::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\User\Teams::class] = $this->hydrators->getObjectMapperOperationUserTeams();
                }
                $operation = new Operation\Teams\ListForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\User\Teams::class], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\TeamFull|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Users\List_::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('since', 'per_page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Users::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Users::class] = $this->hydrators->getObjectMapperOperationUsers();
                }
                $operation = new Operation\Users\List_($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Users::class], $params['since'], $params['per_page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\SimpleUser {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Users\GetByUsername::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Users\CbUsernameRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb::class] = $this->hydrators->getObjectMapperOperationUsersCbUsernameRcb();
                }
                $operation = new Operation\Users\GetByUsername($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb::class], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Users\GetAuthenticated\Response\Applicationjson\H200|Schema\BasicError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\ListEventsForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Users\CbUsernameRcb\Events::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\Events::class] = $this->hydrators->getObjectMapperOperationUsersCbUsernameRcbEvents();
                }
                $operation = new Operation\Activity\ListEventsForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\Events::class], $params['username'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Event {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\ListOrgEventsForAuthenticatedUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username', 'org', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Users\CbUsernameRcb\Events\Orgs\CbOrgRcb::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\Events\Orgs\CbOrgRcb::class] = $this->hydrators->getObjectMapperOperationUsersCbUsernameRcbEventsOrgsCbOrgRcb();
                }
                $operation = new Operation\Activity\ListOrgEventsForAuthenticatedUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\Events\Orgs\CbOrgRcb::class], $params['username'], $params['org'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Event {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\ListPublicEventsForUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Users\CbUsernameRcb\Events\Public_::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\Events\Public_::class] = $this->hydrators->getObjectMapperOperationUsersCbUsernameRcbEventsPublic_();
                }
                $operation = new Operation\Activity\ListPublicEventsForUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\Events\Public_::class], $params['username'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Event {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Users\ListFollowersForUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Users\CbUsernameRcb\Followers::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\Followers::class] = $this->hydrators->getObjectMapperOperationUsersCbUsernameRcbFollowers();
                }
                $operation = new Operation\Users\ListFollowersForUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\Followers::class], $params['username'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\SimpleUser {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Users\ListFollowingForUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Users\CbUsernameRcb\Following::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\Following::class] = $this->hydrators->getObjectMapperOperationUsersCbUsernameRcbFollowing();
                }
                $operation = new Operation\Users\ListFollowingForUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\Following::class], $params['username'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\SimpleUser {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Users\CheckFollowingForUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username', 'target_user')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\Users\CheckFollowingForUser($params['username'], $params['target_user']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Gists\ListForUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username', 'since', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Users\CbUsernameRcb\Gists::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\Gists::class] = $this->hydrators->getObjectMapperOperationUsersCbUsernameRcbGists();
                }
                $operation = new Operation\Gists\ListForUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\Gists::class], $params['username'], $params['since'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\BaseGist|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Users\ListGpgKeysForUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Users\CbUsernameRcb\GpgKeys::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\GpgKeys::class] = $this->hydrators->getObjectMapperOperationUsersCbUsernameRcbGpgKeys();
                }
                $operation = new Operation\Users\ListGpgKeysForUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\GpgKeys::class], $params['username'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\GpgKey {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Users\GetContextForUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username', 'subject_type', 'subject_id')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Users\CbUsernameRcb\Hovercard::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\Hovercard::class] = $this->hydrators->getObjectMapperOperationUsersCbUsernameRcbHovercard();
                }
                $operation = new Operation\Users\GetContextForUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\Hovercard::class], $params['username'], $params['subject_type'], $params['subject_id']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Hovercard|Schema\BasicError|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Apps\GetUserInstallation::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Users\CbUsernameRcb\Installation::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\Installation::class] = $this->hydrators->getObjectMapperOperationUsersCbUsernameRcbInstallation();
                }
                $operation = new Operation\Apps\GetUserInstallation($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\Installation::class], $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Installation {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Users\ListPublicKeysForUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Users\CbUsernameRcb\Keys::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\Keys::class] = $this->hydrators->getObjectMapperOperationUsersCbUsernameRcbKeys();
                }
                $operation = new Operation\Users\ListPublicKeysForUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\Keys::class], $params['username'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\KeySimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Orgs\ListForUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Users\CbUsernameRcb\Orgs::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\Orgs::class] = $this->hydrators->getObjectMapperOperationUsersCbUsernameRcbOrgs();
                }
                $operation = new Operation\Orgs\ListForUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\Orgs::class], $params['username'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\OrganizationSimple {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Projects\ListForUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username', 'state', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Users\CbUsernameRcb\Projects::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\Projects::class] = $this->hydrators->getObjectMapperOperationUsersCbUsernameRcbProjects();
                }
                $operation = new Operation\Projects\ListForUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\Projects::class], $params['username'], $params['state'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Project|Schema\ValidationError {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\ListReceivedEventsForUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Users\CbUsernameRcb\ReceivedEvents::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\ReceivedEvents::class] = $this->hydrators->getObjectMapperOperationUsersCbUsernameRcbReceivedEvents();
                }
                $operation = new Operation\Activity\ListReceivedEventsForUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\ReceivedEvents::class], $params['username'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Event {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\ListReceivedPublicEventsForUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Users\CbUsernameRcb\ReceivedEvents\Public_::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\ReceivedEvents\Public_::class] = $this->hydrators->getObjectMapperOperationUsersCbUsernameRcbReceivedEventsPublic_();
                }
                $operation = new Operation\Activity\ListReceivedPublicEventsForUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\ReceivedEvents\Public_::class], $params['username'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Event {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Repos\ListForUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username', 'direction', 'type', 'sort', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Users\CbUsernameRcb\Repos::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\Repos::class] = $this->hydrators->getObjectMapperOperationUsersCbUsernameRcbRepos();
                }
                $operation = new Operation\Repos\ListForUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\Repos::class], $params['username'], $params['direction'], $params['type'], $params['sort'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\MinimalRepository {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\PromoteUserToBeSiteAdministrator::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\EnterpriseAdmin\PromoteUserToBeSiteAdministrator($params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\DemoteSiteAdministrator::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\EnterpriseAdmin\DemoteSiteAdministrator($params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\ListReposStarredByUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username', 'sort', 'direction', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Users\CbUsernameRcb\Starred::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\Starred::class] = $this->hydrators->getObjectMapperOperationUsersCbUsernameRcbStarred();
                }
                $operation = new Operation\Activity\ListReposStarredByUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\Starred::class], $params['username'], $params['sort'], $params['direction'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Activity\ListReposStarredByUser\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Activity\ListReposWatchedByUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username', 'per_page', 'page')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Users\CbUsernameRcb\Subscriptions::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\Subscriptions::class] = $this->hydrators->getObjectMapperOperationUsersCbUsernameRcbSubscriptions();
                }
                $operation = new Operation\Activity\ListReposWatchedByUser($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Users\CbUsernameRcb\Subscriptions::class], $params['username'], $params['per_page'], $params['page']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\MinimalRepository {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\SuspendUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\EnterpriseAdmin\SuspendUser($this->requestSchemaValidator, $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\EnterpriseAdmin\UnsuspendUser::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array('username')) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                $operation = new Operation\EnterpriseAdmin\UnsuspendUser($this->requestSchemaValidator, $params['username']);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : \Psr\Http\Message\ResponseInterface {
                    return $operation->createResponse($response);
                });
                break;
            case Operation\Meta\GetZen::OPERATION_MATCH:
                $requestBodyData = array();
                foreach (\array_keys($params) as $param) {
                    if (\in_array($param, array()) != false) {
                        \array_push($requestBodyData, $param);
                    }
                }
                if (\array_key_exists(Hydrator\Operation\Zen::class, $this->hydrator) == false) {
                    $this->hydrator[Hydrator\Operation\Zen::class] = $this->hydrators->getObjectMapperOperationZen();
                }
                $operation = new Operation\Meta\GetZen($this->responseSchemaValidator, $this->hydrator[Hydrator\Operation\Zen::class]);
                $request = $operation->createRequest($requestBodyData);
                return $this->browser->request($request->getMethod(), $request->getUri(), $request->withHeader('Authorization', $this->authentication->authHeader())->getHeaders(), $request->getBody())->then(function (\Psr\Http\Message\ResponseInterface $response) use($operation) : Schema\Operation\Gitignore\GetAllTemplates\Response\Applicationjson\H200 {
                    return $operation->createResponse($response);
                });
                break;
        }
        throw new \InvalidArgumentException();
    }
    public function webHooks() : \ApiClients\Contracts\OpenAPI\WebHooksInterface
    {
        return $this->webHooks;
    }
}
